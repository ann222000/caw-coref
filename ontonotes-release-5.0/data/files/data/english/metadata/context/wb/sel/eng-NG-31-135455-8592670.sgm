<DOC>
<DOCID> eng-NG-31-135455-8592670 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-08-07T14:50:00 </DATETIME>
<BODY>
<HEADLINE>
bash vs. python scripts - which one is better?
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T14:50:00 </POSTDATE>
Hi,

I'm about to learn bash or python scripting.

- Which one is easiest to learn?
- Which one is more powerful?
- Can I execute /bin commands from within a python script
(something like mkdir or ls)?

Or should I learn bash scripting anyway?
Please, let me know your experiences.

Thanks in advance, Manon.
</POST>
<POST>
<POSTER> Jose Luis Rivas Contreras &lt;ghostba...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T15:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Manon Metten wrote:
&gt; Hi,

&gt; I'm about to learn bash or python scripting.

&gt; - Which one is easiest to learn?
&gt; - Which one is more powerful?
&gt; - Can I execute /bin commands from within a python script
&gt;   (something like mkdir or ls)?

&gt; Or should I learn bash scripting anyway?
">

You should learn bash anyway ;).

I believe is easier that python, at least for system scripts, but if you
want to make something bigger, like an application then go for python.

Regards,
Jose Luis.
--

ghostbar on debian linux 'sid' 2.6.22 x86_64-SMP - #382503
Weblog: http://ghostbar.ath.cx/ - http://linuxtachira.org
http://debian.org.ve - irc.debian.org #debian-ve #debian-devel-es
San Cristóbal, Venezuela. http://chaslug.org.ve
Fingerprint = 3E7D 4267 AFD5 2407 2A37  20AC 38A0 AD5B CACA B118

signature.asc
1K Download
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-07T15:40:00 </POSTDATE>
On Aug 7, 2007, at 11:42 AM, Manon Metten wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi,

&gt; I'm about to learn bash or python scripting.

&gt; - Which one is easiest to learn?
">

That's debatable, I think.  Bash's syntax is more idiosyncratic, but
there's less of it.

<QUOTE PREVIOUSPOST="
&gt; - Which one is more powerful?
">

Python.

<QUOTE PREVIOUSPOST="
&gt; - Can I execute /bin commands from within a python script
&gt;   (something like mkdir or ls)?
">

I'm sure you can, although I don't know how.  (I'm not a Python
programmer.)

<QUOTE PREVIOUSPOST="
&gt; Or should I learn bash scripting anyway?
">

If you plan to do much system administration, learning bash scripting
is worthwhile.  There are three reasons I can think of right off the
bat:
- Every Unix-like system you encounter will have some version of the
Bourne shell. Not every system will have Python.
- You will often need to modify or maintain other people's bash
scripts, since that's how most startup scripts and the like are written.
- Simple bash scripts can be done right from the shell prompt, which
is sometimes handy.
Stuff like 'for FILE in `ls *.wav` ; do lame -h -b 160 $FILE
$FILE.mp3 ; done' to encode a bunch of WAV files to MP3, to give a
crude example.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T16:20:00 </POSTDATE>
Hi David,

On 8/7/07, David Brodbeck &lt;bro ... @u.washington.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I'm about to learn bash or python scripting.
&gt; &gt; - Which one is easiest to learn?

&gt; That's debatable, I think.  Bash's syntax is more idiosyncratic, but
&gt; there's less of it.

&gt; &gt; - Which one is more powerful?

&gt; Python.
&gt; Or should I learn bash scripting anyway?

&gt; If you plan to do much system administration, learning bash scripting
&gt; is worthwhile.  There are three reasons I can think of right off the
&gt; bat:
&gt; - Every Unix-like system you encounter will have some version of the
&gt; Bourne shell. Not every system will have Python.
&gt; - You will often need to modify or maintain other people's bash
&gt; scripts, since that's how most startup scripts and the like are written.
&gt; - Simple bash scripts can be done right from the shell prompt, which
&gt; is sometimes handy.
">

I wish I'd discovers Linux some ten years ago. I have literally hundreds of
AmigaDOS and ARexx scripts - some of them very powerful - that don't
even come close to converting to bash (or maybe python). Now I feel I've
to re-invent the wheel.

Thanks for your input, Manon.
</POST>
<POST>
<POSTER> &quot;Michael Marsh&quot; &lt;michael.a.ma...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T16:30:00 </POSTDATE>
On 8/7/07, Manon Metten &lt;manon.met ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I wish I'd discovers Linux some ten years ago. I have literally hundreds of
&gt; AmigaDOS and ARexx scripts - some of them very powerful - that don't
&gt; even come close to converting to bash (or maybe python). Now I feel I've
&gt; to re-invent the wheel.
">

As a stop-gap, you might want to install regina-rexx .  That'll at
least give you time to convert your scripts to something else.  I've
never used REXX, but perusing the syntax on Wikipedia, it looks like
you should be able to convert a lot of it to bash &quot;easily&quot; once you've
familiarized yourself with the syntax.

And since you asked, I like python, but a working knowledge of bash is
indispensible.

--
Michael A. Marsh
http://www.umiacs.umd.edu/~mmarsh
http://mamarsh.blogspot.com
http://36pints.blogspot.com

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T17:40:00 </POSTDATE>
Hi Michael,

On 8/7/07, Michael Marsh &lt;michael.a.ma ... @gmail.com&gt; wrote:

As a stop-gap, you might want to install regina-rexx .  That'll at

<QUOTE PREVIOUSPOST="
&gt; least give you time to convert your scripts to something else.
">

Gee, this is great. It looks very familiar. I don't think it won't take
long before I can use it. Thank you very much.

I've never used REXX, but perusing the syntax on Wikipedia, it looks

<QUOTE PREVIOUSPOST="
&gt; like you should be able to convert a lot of it to bash &quot;easily&quot; once
&gt; you've
&gt; familiarized yourself with the syntax.

&gt; And since you asked, I like python, but a working knowledge of bash is
&gt; indispensible.
">

Thanks for your input, Manon.
</POST>
<POST>
<POSTER> Vincent Lefevre &lt;vinc...@vinc17.org&gt; </POSTER>
<POSTDATE> 2007-08-07T18:00:00 </POSTDATE>
On 2007-08-07 12:39:37 -0700, David Brodbeck wrote:

<QUOTE PREVIOUSPOST="
&gt; On Aug 7, 2007, at 11:42 AM, Manon Metten wrote:
&gt;&gt; I'm about to learn bash or python scripting.
">

Why not zsh (more powerful than bash) or perl?

<QUOTE PREVIOUSPOST="
&gt;&gt; Or should I learn bash scripting anyway?

&gt; If you plan to do much system administration, learning bash scripting is
&gt; worthwhile.  There are three reasons I can think of right off the bat:
&gt; - Every Unix-like system you encounter will have some version of the Bourne
&gt; shell. Not every system will have Python.
">

Not every system has bash. If this is for compatibility, you can learn
POSIX sh, but e.g. Solaris /bin/sh is not a POSIX sh. For this reason
and because POSIX sh is limited (you can't execute a command and have
a timeout on it), I now write all my portable scripts in Perl since it
is on every system I've met.

<QUOTE PREVIOUSPOST="
&gt; - You will often need to modify or maintain other people's bash scripts,
&gt; since that's how most startup scripts and the like are written.
&gt; - Simple bash scripts can be done right from the shell prompt, which is
&gt; sometimes handy.
&gt;   Stuff like 'for FILE in `ls *.wav` ; do lame -h -b 160 $FILE $FILE.mp3 ;
&gt; done' to encode a bunch of WAV files to MP3, to give a crude example.
">

This one is bad. Really.

for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

This is another reason why sh sucks. It's too easy to write broken
things.

--
Vincent Lefèvre &lt;vinc ... @vinc17.org&gt; - Web: &lt; http://www.vinc17.org/ &gt;
100% accessible validated (X)HTML - Blog: &lt; http://www.vinc17.org/blog/ &gt;
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-07T18:20:00 </POSTDATE>
On Aug 7, 2007, at 2:39 PM, Vincent Lefevre wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt; - Every Unix-like system you encounter will have some version of
&gt;&gt; the Bourne
&gt;&gt; shell. Not every system will have Python.

&gt; Not every system has bash.
">

Well, yeah.  That's why I said &quot;Bourne shell&quot; and not &quot;bash.&quot;

<QUOTE PREVIOUSPOST="
&gt; I now write all my portable scripts in Perl since it
&gt; is on every system I've met.
">

It's not any more guaranteed than bash, though.  For example, FreeBSD
no longer includes Perl with the base system; you have to install it
as a port.

<QUOTE PREVIOUSPOST="
&gt;&gt;   Stuff like 'for FILE in `ls *.wav` ; do lame -h -b 160 $FILE
&gt;&gt; $FILE.mp3 ;
&gt;&gt; done' to encode a bunch of WAV files to MP3, to give a crude example.

&gt; This one is bad. Really.

&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

&gt; This is another reason why sh sucks. It's too easy to write broken
&gt; things.
">

Good catch, and I should have known better than to throw something
like that out there instead of using a real, debugged example.  Every
language has its issues; with bash it's argument escaping.

Personally I think filenames with spaces in them are an abomination
that should have never been permitted, but I lost that argument ages
ago. ;)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Nelson Castillo&quot; &lt;nelson...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-07T18:30:00 </POSTDATE>
On 8/7/07, Manon Metten &lt;manon.met ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi,

&gt; I'm about to learn bash or python scripting.

&gt; - Which one is easiest to learn?
">

Python I guess.

<QUOTE PREVIOUSPOST="
&gt; - Which one is more powerful?
">

Python.

<QUOTE PREVIOUSPOST="
&gt; - Can I execute /bin commands from within a python script
&gt;   (something like mkdir or ls)?
">

Yes.

http://www.oreilly.com/catalog/lpython/chapter/ch09.html#13504

<QUOTE PREVIOUSPOST="
&gt; Or should I learn bash scripting anyway?
">

Yes :) I learnt Perl because I didn't want to learn Bash. But once
in a while I'd like to be fluent in Bash so I can write nice one-liners.
Nowadays I replaced Perl with Python, but I still use Perl from time
to time (to write one-liners mostly).

<QUOTE PREVIOUSPOST="
&gt; Please, let me know your experiences.
">

Learn how to use 'find'. It's very useful.
Also regular expressions.

You might want to check the OS module, and look for some
examples.

http://docs.python.org/lib/module-os.html

Regards,
N.-

--
http://arhuaco.org
http://emQbit.com

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-07T19:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Aug 07, 2007 at 05:28:54PM -0500, Nelson Castillo wrote:

&gt; Learn how to use 'find'. It's very useful.
&gt; Also regular expressions.
">

Recently I've begun picking up (mostly by osmosis and from reading
Florian's posts) a lot more awk, find, and regex. Those three combined
with xargs or find -exec can get a pile of work done really quickly.

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-07T19:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Aug 07, 2007 at 03:14:42PM -0700, David Brodbeck wrote:

&gt; On Aug 7, 2007, at 2:39 PM, Vincent Lefevre wrote:
&gt;&gt;&gt; - Every Unix-like system you encounter will have some version of the
&gt;&gt;&gt; Bourne
&gt;&gt;&gt; shell. Not every system will have Python.

&gt;&gt; Not every system has bash.

&gt; Well, yeah.  That's why I said &quot;Bourne shell&quot; and not &quot;bash.&quot;

&gt;&gt; I now write all my portable scripts in Perl since it
&gt;&gt; is on every system I've met.

&gt; It's not any more guaranteed than bash, though.  For example, FreeBSD no
&gt; longer includes Perl with the base system; you have to install it as a
&gt; port.

&gt;&gt;&gt;   Stuff like 'for FILE in `ls *.wav` ; do lame -h -b 160 $FILE $FILE.mp3
&gt;&gt;&gt; ;
&gt;&gt;&gt; done' to encode a bunch of WAV files to MP3, to give a crude example.

&gt;&gt; This one is bad. Really.

&gt;&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

&gt;&gt; This is another reason why sh sucks. It's too easy to write broken
&gt;&gt; things.
">

So what's the right way to do this? I hacked one together the other
day:

IFS=$'\t\n'; for i in `find . -iname \*m4a`; do faad... blah blah blah

and I knew it was a hack because setting $IFS just seems
bad... possible unintended consquences, but it worked.

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-07T19:30:00 </POSTDATE>
On Aug 7, 2007, at 4:04 PM, Andrew Sackville-West wrote:

<QUOTE PREVIOUSPOST="
&gt; oh. I see. That is the right one. but, doesn't really work if you need
&gt; to recurse into stuff does it, which was my problem with that find in
&gt; the previous post.
">

To do this with find, I'd try something like this:

find . -name &quot;*.wav&quot; -exec lame -h -b 160 \{\} \{\}.mp3 \;

It's possible spaces will bite you here, too ... If you actually
attempt this on filenames with spaces, test it first and see if you
need to add another level of quoting.  Note that you have to escape
the curly brackets and the semicolon so find sees them, instead of
bash trying to interpret them.  Find's syntax for the &quot;exec&quot; action
is kind of awkward-looking, but this can be an extremely useful
tool.  For example, I once had to decompress a bunch of gzipped files
in a directory tree, so I did something like this:

find . -name &quot;*.gz&quot; -exec gunzip \{\} \;

Note that find -exec can also do a lot of damage in a hurry.  If
you're doing anything remotely destructive, you might want to
substitute &quot;echo \{\}&quot; for your command the first time you run it,
just to make sure find is only finding the stuff you want it to!
Also, before you start thinking of doing anything resembling &quot;-exec
rm&quot; note that find has a built-in ability to delete files.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-07T19:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Aug 07, 2007 at 04:23:28PM -0700, David Brodbeck wrote:

&gt; On Aug 7, 2007, at 4:04 PM, Andrew Sackville-West wrote:
&gt;&gt; oh. I see. That is the right one. but, doesn't really work if you need
&gt;&gt; to recurse into stuff does it, which was my problem with that find in
&gt;&gt; the previous post.

&gt; To do this with find, I'd try something like this:

&gt; find . -name &quot;*.wav&quot; -exec lame -h -b 160 \{\} \{\}.mp3 \;
">

I do this one frequently to tar up small video files from a
surveillance system

find ./cam{1,2} -daystart -mtime +3 -exec tar -xzf '{}' + &amp;

and its all over but for the processing.

<QUOTE PREVIOUSPOST="
&gt; It's possible spaces will bite you here, too ... If you actually attempt
&gt; this on filenames with spaces, test it first and see if you need to add
&gt; another level of quoting.
">

its inevitable that these sorts of tasks have to be done on exactly
the kinds of files systems that have space: music folders or some
such...

Note that you have to escape the curly brackets

<QUOTE PREVIOUSPOST="
&gt; and the semicolon so find sees them, instead of bash trying to interpret
&gt; them.  Find's syntax for the &quot;exec&quot; action is kind of awkward-looking, but
&gt; this can be an extremely useful tool.  For example, I once had to
&gt; decompress a bunch of gzipped files in a directory tree, so I did something
&gt; like this:

&gt; find . -name &quot;*.gz&quot; -exec gunzip \{\} \;

&gt; Note that find -exec can also do a lot of damage in a hurry.  If you're
&gt; doing anything remotely destructive, you might want to substitute &quot;echo
&gt; \{\}&quot; for your command the first time you run it, just to make sure find is
&gt; only finding the stuff you want it to!   Also, before you start thinking of
&gt; doing anything resembling &quot;-exec rm&quot; note that find has a built-in ability
&gt; to delete files.
">

hmm... i'll look into that rm feature, but yes I routinely use -exec
echo '{}' first...

Regardless, its powerful and fun and once you've learned it, its
incredibly efficient. my wife gets frustrated watching over my
shoulder as I usually have to take a few cracks at it before I get it
right. She says something about how she could be done already using
the mouse and then I change from my sample tree to the real one and
process several hundred files in about 20 keystrokes... then I get to
be smug. :)

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> Ken Irving &lt;fn...@uaf.edu&gt; </POSTER>
<POSTDATE> 2007-08-07T20:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Aug 07, 2007 at 04:23:28PM -0700, David Brodbeck wrote:
&gt; To do this with find, I'd try something like this:

&gt; find . -name &quot;*.wav&quot; -exec lame -h -b 160 \{\} \{\}.mp3 \;

&gt; It's possible spaces will bite you here, too ... If you actually attempt
&gt; this on filenames with spaces, test it first and see if you need to add
&gt; another level of quoting.  Note that you have to escape the curly brackets
&gt; and the semicolon so find sees them, instead of bash trying to interpret
&gt; them.  Find's syntax for the &quot;exec&quot; action is kind of awkward-looking, but
&gt; ...
">

A minor point, but I use find a lot and never see the need to escape the
curly brackets under bash. I suppose this may take (mis)advantage of the
following statement in bash(1), under Brace Expansion:

A  correctly-formed  brace  expansion must contain unquoted opening and
closing braces, and at least one unquoted comma  or  a  valid  sequence
expression.   Any incorrectly formed brace expansion is left unchanged.
A { or , may be quoted with a backslash to prevent its being considered
part  of  a brace expression.  To avoid conflicts with parameter expan-
sion, the string ${ is not considered eligible for brace expansion.

So, for what it's worth, I'd write the above as:

find . -name \*.wav -exec lame -h -b 160 {} {}.mp3 \;

<QUOTE PREVIOUSPOST="
&gt; Note that find -exec can also do a lot of damage in a hurry.  If you're
&gt; doing anything remotely destructive, you might want to substitute &quot;echo
&gt; \{\}&quot; for your command the first time you run it, just to make sure find is
&gt; only finding the stuff you want it to!   Also, before you start thinking of
">

Good advice, but I often do this even for non-destructive commands, just to
make sure what's going to happen. You really only need to insert 'echo' in
front of the command, and will see the expanded command in the output. E.g.,
the previous command would be:

find . -name \*.wav -exec echo lame -h -b 160 {} {}.mp3 \;

If it looks good remove the 'echo', or maybe pipe the resulting list of
commands into xargs.

Ken

--
Ken Irving, fn ... @uaf.edu

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Vincent Lefevre &lt;vinc...@vinc17.org&gt; </POSTER>
<POSTDATE> 2007-08-07T21:00:00 </POSTDATE>
On 2007-08-07 15:14:42 -0700, David Brodbeck wrote:

<QUOTE PREVIOUSPOST="
&gt; On Aug 7, 2007, at 2:39 PM, Vincent Lefevre wrote:
&gt;&gt;&gt; - Every Unix-like system you encounter will have some version of the
&gt;&gt;&gt; Bourne
&gt;&gt;&gt; shell. Not every system will have Python.

&gt;&gt; Not every system has bash.

&gt; Well, yeah.  That's why I said &quot;Bourne shell&quot; and not &quot;bash.&quot;
">

But you said &quot;learning bash scripting&quot; just before that. And bash
is not really a Bourne shell anyway, since it is incompatible with
the traditional Bourne shell (in particular concerning the signal
handling). So, one has two kinds of Bourne-like (&quot;sh&quot;) shells:
the traditional Bourne shell and POSIX shells. This makes writing
portable sh scripts very difficult.

<QUOTE PREVIOUSPOST="
&gt;&gt; I now write all my portable scripts in Perl since it
&gt;&gt; is on every system I've met.

&gt; It's not any more guaranteed than bash, though. For example, FreeBSD
&gt; no longer includes Perl with the base system; you have to install it
&gt; as a port.
">

One can hope that every sensible admin would install it.

<QUOTE PREVIOUSPOST="
&gt; Personally I think filenames with spaces in them are an abomination that
&gt; should have never been permitted, but I lost that argument ages ago. ;)
">

I agree. This can even make confusion when mentioning filenames in
text files (not just in scripts...). Non-ASCII characters should also
be avoided (because of Unicode's NFC/NFD forms, but also homoglyphs).

--
Vincent Lefèvre &lt;vinc ... @vinc17.org&gt; - Web: &lt; http://www.vinc17.org/ &gt;
100% accessible validated (X)HTML - Blog: &lt; http://www.vinc17.org/blog/ &gt;
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Nate Duehr &lt;n...@natetech.com&gt; </POSTER>
<POSTDATE> 2007-08-07T22:40:00 </POSTDATE>
On Aug 7, 2007, at 12:42 PM, Manon Metten wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi,

&gt; I'm about to learn bash or python scripting.

&gt; - Which one is easiest to learn?
">

Doesn't matter.  Learn one or the other or both if you need them.

<QUOTE PREVIOUSPOST="
&gt; - Which one is more powerful?
">

Doesn't matter.  As a friend puts it... &quot;If it can't be done in a
shell script, it probably wasn't worth doing in the first place.&quot;

You can find endless debates amongst programmers and even non-
programmers on the web about how &quot;powerful&quot; something is, or how
&quot;extensible&quot;, or the semantics of syntax or any of a million other
banal repetitive debates about software.  Only once you reach the
almost zen-like realization that the computer is just a machine and
it's either doing everything you want it to, or it isn't, and that
you can fix it if you feel like it in ANY language... then you start
to understand why the debates don't matter, and good programmers know
multiple languages.

<QUOTE PREVIOUSPOST="
&gt; - Can I execute /bin commands from within a python script
&gt;   (something like mkdir or ls)?
">

Don't know.

<QUOTE PREVIOUSPOST="
&gt; Or should I learn bash scripting anyway?
">

I don't know.  Should I learn Swedish?

What exactly are you attempting to accomplish?  Have you searched for
software that does it?  Or software that comes close?  Perhaps the
best thing you could do would be to find software that comes close
and then code in whatever language THAT software is in, to make your
finished program do what you want.

<QUOTE PREVIOUSPOST="
&gt; Please, let me know your experiences.
">

My experience is that folks that need to get something done, pick a
language and do it.  They end up either enjoying writing code and
learn multiple languages over time, or they quit.  They don't ask
others to tell them what to do or learn.

<QUOTE PREVIOUSPOST="
&gt; Thanks in advance, Manon.
">

Quite welcome.

--
Nate Duehr
n ... @natetech.com

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-08T00:00:00 </POSTDATE>
On Aug 7, 2007, at 7:37 PM, Nate Duehr wrote:

<QUOTE PREVIOUSPOST="
&gt; My experience is that folks that need to get something done, pick a
&gt; language and do it.  They end up either enjoying writing code and
&gt; learn multiple languages over time, or they quit.  They don't ask
&gt; others to tell them what to do or learn.
">

And the best part: The more languages you learn, the easier each new
one comes.  At least, that's how it worked for me.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Jon Dowland &lt;li...@alcopop.org&gt; </POSTER>
<POSTDATE> 2007-08-08T05:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; IFS=$'\t\n'; for i in `find . -iname \*m4a`; do faad...
&gt; blah blah blah
&gt; and I knew it was a hack because setting $IFS just seems
&gt; bad... possible unintended consquences, but it worked.
">

it's the backtick sub-shell that stands out to me. As
others have pointed out, find's -exec argument is very
useful:

find . -iname '*m4a' -exec faad .... {} \;

However I haven't used it in a long time, preferring to
instead use -print0 and xargs -r0

find . -iname '*m4a' -print0 | xargs -r0 -n1 faad ...

In many cases (such as the mass-gzip someone else provided)
xargs will be significantly more efficient as it will only
spawn as many sub-processes as is required. In your faad
example, I expect you need one faad process per input file,
so -n1 is necessary.

--
Jon Dowland

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:10:00 </POSTDATE>
Hi Nelson,

On 8/8/07, Nelson Castillo &lt;nelson ... @gmail.com&gt; wrote:

Nowadays I replaced Perl with Python, but I still use Perl from time

<QUOTE PREVIOUSPOST="
&gt; to time (to write one-liners mostly).
">

Why did you switch from Perl to Python?

Learn how to use 'find'. It's very useful.

<QUOTE PREVIOUSPOST="
&gt; Also regular expressions.
">

I will. I noticed already that I probably could do the same with 'find' as
I was used to with 'list' on my old Amiga.

Thanks for the tip, Manon.
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:10:00 </POSTDATE>
Hi Vincent,

On 8/7/07, Vincent Lefevre &lt;vinc ... @vinc17.org&gt; wrote:

Why not zsh (more powerful than bash) or perl?

<QUOTE PREVIOUSPOST="

">

Could you explain in short why you prefer zsh over bash?

Thanks, Manon.
</POST>
<POST>
<POSTER> &quot;Oscar Dulzaides&quot; &lt;degas1...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:20:00 </POSTDATE>
Hi,
I am new to debian and am trying to get certified on Linux. Know very
little about linux but everyday I find out more.
I loaded debian into my P3 Laptop and I get a message when I start the
system that the kernel will stop pcmcia : need more tools.
I already have installed pcmcia cs util etc. what else do I need to do to
get hte ocmcia services to work as I have a D- link wireless card I want to
use.
Do I have to recompile the kernel (which I don't know how to do) ? thanks
for any help you can give me

On 8/7/07, Jose Luis Rivas Contreras &lt;ghostba ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Manon Metten wrote:
&gt; &gt; Hi,

&gt; &gt; I'm about to learn bash or python scripting.

&gt; &gt; - Which one is easiest to learn?
&gt; &gt; - Which one is more powerful?
&gt; &gt; - Can I execute /bin commands from within a python script
&gt; &gt;   (something like mkdir or ls)?

&gt; &gt; Or should I learn bash scripting anyway?

&gt; You should learn bash anyway ;).

&gt; I believe is easier that python, at least for system scripts, but if you
&gt; want to make something bigger, like an application then go for python.

&gt; Regards,
&gt; Jose Luis.
&gt; --

&gt; ghostbar on debian linux 'sid' 2.6.22 x86_64-SMP - #382503
&gt; Weblog: http://ghostbar.ath.cx/ - http://linuxtachira.org
&gt; http://debian.org.ve - irc.debian.org #debian-ve #debian-devel-es
&gt; San Cristóbal, Venezuela. http://chaslug.org.ve
&gt; Fingerprint = 3E7D 4267 AFD5 2407 2A37  20AC 38A0 AD5B CACA B118
">
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:20:00 </POSTDATE>
Hi Andrew,

On 8/8/07, Andrew Sackville-West &lt;and ... @farwestbilliards.com&gt; wrote:

Recently I've begun picking up (mostly by osmosis and from reading

<QUOTE PREVIOUSPOST="
&gt; Florian's posts) a lot more awk, find, and regex. Those three combined
&gt; with xargs or find -exec can get a pile of work done really quickly.
">

Thanks for the tip. Those are very useful commands. I will certainly
check this out and start using them.

Greetings, Manon.
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Aug 08, 2007 at 12:15:09PM -0400, Oscar Dulzaides wrote:
&gt; Hi,
&gt;  I am new to debian and am trying to get certified on Linux. Know very
&gt; little about linux but everyday I find out more.
&gt; I loaded debian into my P3 Laptop and I get a message when I start the
&gt; system that the kernel will stop pcmcia : need more tools.
&gt; I already have installed pcmcia cs util etc. what else do I need to do to
&gt; get hte ocmcia services to work as I have a D- link wireless card I want to
&gt; use.
&gt; Do I have to recompile the kernel (which I don't know how to do) ? thanks
&gt; for any help you can give me
">

Oscar, this message is unrelated to the thread you replied to. Please
start a _new_ message with an appropriate subject. you will get better
response. What you have done is &quot;hijack&quot; a thread and it is frowned up
here.

But, so that this is not a complete waste of time for you, I can
confirm that I have seen these messages as well on my laptop, but
haven't had time to research it. I suggest you read the changelogs,
TODOs, and README.Debian files associated with these packages. Also
read the bug reports, there may be information there as well. It looks
like there is a transistion going on in card services, so be prepared.

hth

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> &quot;Nelson Castillo&quot; &lt;nelson...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T12:40:00 </POSTDATE>
On 8/8/07, Manon Metten &lt;manon.met ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi Nelson,

&gt; On 8/8/07, Nelson Castillo &lt;nelson ... @gmail.com&gt; wrote:

&gt; &gt; Nowadays I replaced Perl with Python, but I still use Perl from time
&gt; &gt; to time (to write one-liners mostly).

&gt; Why did you switch from Perl to Python?
">

I found the code I wrote easier to understand. But as I said before,
I still use Perl for some tasks. I guess you don't actually switch
languages, but learn new ones and then you end up writing
more code with what you're comfortable with. Or with the
best one for a given task.

I'm also learning new languages (Scheme, Verilog this time). As
someone pointed out, many people just try to learn many languages.

Regards.

--
http://arhuaco.org
http://emQbit.com

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T13:00:00 </POSTDATE>
Hi Nelson,

On 8/8/07, Nelson Castillo &lt;nelson ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Why did you switch from Perl to Python?

&gt; I found the code I wrote easier to understand. But as I said before,
&gt; I still use Perl for some tasks.
">

OK. I forgot to mention Perl in my initial question. But if the code is
easier to understand I guess I better try to learn Python first.

But for now, I'm very happy with regina-rexx, to which Michael Marsh
pointed me. I've used it for many years on my old Amiga and still do.
Yesterday I installed it on Linux, and I've already written my first
script :-) But that won't keep me away from learning other languages.

I guess you don't actually switch languages, but learn new ones

<QUOTE PREVIOUSPOST="
&gt; and then you end up writing more code with what you're comfortable
&gt; with. Or with the best one for a given task.
">

Good point; I agree. Thanks and greetings, Manon.
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-08T13:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Aug 08, 2007 at 10:29:27AM +0100, Jon Dowland wrote:

&gt; &gt; IFS=$'\t\n'; for i in `find . -iname \*m4a`; do faad...
&gt; &gt; blah blah blah

&gt; &gt; and I knew it was a hack because setting $IFS just seems
&gt; &gt; bad... possible unintended consquences, but it worked.

&gt; it's the backtick sub-shell that stands out to me. As
&gt; others have pointed out, find's -exec argument is very
&gt; useful:

&gt;     find . -iname '*m4a' -exec faad .... {} \;

&gt; However I haven't used it in a long time, preferring to
&gt; instead use -print0 and xargs -r0

&gt;     find . -iname '*m4a' -print0 | xargs -r0 -n1 faad ...

&gt; In many cases (such as the mass-gzip someone else provided)
&gt; xargs will be significantly more efficient as it will only
&gt; spawn as many sub-processes as is required. In your faad
&gt; example, I expect you need one faad process per input file,
&gt; so -n1 is necessary.
">

well that's the first in a long line of statements operating on $i,
extracting tag information from .m4a, converting to .mp3 (I know I
know, don't start, its got to do with the WAF, conformance with
existing 40GB library etc etc), parsing tag information for proper
retagging, and finally removing the originals, all nice and pretty so
she can just plunk the files down somewhere and have them magically
appear ready to go.

Anyway, I'm not sure I would gain much by mashing it all into one find
-exec... I'd certainly lose readability. ;)

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-08T13:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Aug 08, 2007 at 06:52:11PM +0200, Manon Metten wrote:
&gt; Hi Nelson,

&gt; On 8/8/07, Nelson Castillo &lt;nelson ... @gmail.com&gt; wrote:

&gt; &gt; Why did you switch from Perl to Python?

&gt; &gt; I found the code I wrote easier to understand. But as I said before,
&gt; &gt; I still use Perl for some tasks.

&gt; OK. I forgot to mention Perl in my initial question. But if the code is
&gt; easier to understand I guess I better try to learn Python first.
">

I think you're missing the point. Write in whatever suits you and the
task at hand. If you're hacking on a project that has already started,
then learn the appropriate language. If you're starting from scratch,
then learn whichever one seems intuitive to you at the outset. Be
prepared to realise that you've made the wrong choice and port it
something else. ;)

Don't pick a language because someone else told you it was easier to
read. Lots of people can read perl-splatter with ease others can read
scheme-nested-parenthesis madness like its their native tongue. YOu
have to find some compromise that 1) works for YOU and 2) meets the
needs of the project.

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-08T14:50:00 </POSTDATE>
Hi Andrew,

On 8/8/07, Andrew Sackville-West &lt;and ... @farwestbilliards.com&gt; wrote:

I think you're missing the point. Write in whatever suits you and the

<QUOTE PREVIOUSPOST="
&gt; task at hand. If you're hacking on a project that has already started,
&gt; then learn the appropriate language. If you're starting from scratch,
&gt; then learn whichever one seems intuitive to you at the outset. Be
&gt; prepared to realise that you've made the wrong choice and port it
&gt; something else. ;)
">

I guess you're an experienced programmer, which I'm not. I don't learn
another programming language that easy, coz I only master two:
AmigaDOS and ARexx. But now I feel the need switch to Linux and
either become familiar with bash/perl/python or whatever. That's why I
asked my initial question: to not find out at some point that I've made
the wrong choice.

Don't pick a language because someone else told you it was easier to

<QUOTE PREVIOUSPOST="
&gt; read. Lots of people can read perl-splatter with ease others can read
&gt; scheme-nested-parenthesis madness like its their native tongue.
">

Well, maybe than, it's a matter of programming habits. That's why I didn't
think of that, coz my code mostly is pretty neatly.

You have to find some compromise that 1) works for YOU and 2) meets

<QUOTE PREVIOUSPOST="
&gt; the needs of the project.
">

I agree. Thanks again. I appreciate your precious advise. I hope I make the
right choice, but if I don't, I'm prepared now to switch. Not regarding the
things I already learned as a waste of time, but as maybe to be valuable
at some other point in time, or at least giving me some more experience
that'll make it easier to learn something new.

Greetings, Manon.
</POST>
<POST>
<POSTER> Andrew Sackville-West &lt;and...@farwestbilliards.com&gt; </POSTER>
<POSTDATE> 2007-08-08T16:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Aug 08, 2007 at 08:42:22PM +0200, Manon Metten wrote:
&gt; Hi Andrew,

&gt; On 8/8/07, Andrew Sackville-West &lt;and ... @farwestbilliards.com&gt; wrote:

&gt; I think you're missing the point. Write in whatever suits you and the
&gt; &gt; task at hand. If you're hacking on a project that has already started,
&gt; &gt; then learn the appropriate language. If you're starting from scratch,
&gt; &gt; then learn whichever one seems intuitive to you at the outset. Be
&gt; &gt; prepared to realise that you've made the wrong choice and port it
&gt; &gt; something else. ;)

&gt; I guess you're an experienced programmer, which I'm not.
">

I'm not either. Its been literally 15 years since I did any real
coding... but it is fun...

I don't learn

<QUOTE PREVIOUSPOST="
&gt; another programming language that easy, coz I only master two:
&gt; AmigaDOS and ARexx. But now I feel the need switch to Linux and
&gt; either become familiar with bash/perl/python or whatever. That's why I
&gt; asked my initial question: to not find out at some point that I've made
&gt; the wrong choice.
">

again, that's the point, there is no *wrong* choice, just perhaps a
choice that is not suitable for the task at hand. That doesn't mean it
won't be useful in the future, or teach you some concept now. While a
choice of language to learn may not benefit the current project, it
will surely be a benefit at some point.

As an example, I learned a little rudimentary lisp back in about
1987 and I *never* used it beyond that brief introduction. Then about
two years ago, I had an itch to scratch and did some work on the
reports system in Gnucash. The reports are all written in Scheme, a
derivative of lisp. I was able to draw on that rudimentary knowledge
of lisp and get myself moving pretty quickly. So that little bit from
two decades ago came in handy eventually.

<QUOTE PREVIOUSPOST="
&gt; Don't pick a language because someone else told you it was easier to
&gt; &gt; read. Lots of people can read perl-splatter with ease others can read
&gt; &gt; scheme-nested-parenthesis madness like its their native tongue.

&gt; Well, maybe than, it's a matter of programming habits. That's why I didn't
&gt; think of that, coz my code mostly is pretty neatly.

&gt; You have to find some compromise that 1) works for YOU and 2) meets
&gt; &gt; the needs of the project.

&gt; I agree. Thanks again. I appreciate your precious advise. I hope I make the
&gt; right choice, but if I don't, I'm prepared now to switch.
">

You will make the right choice because there is no wrong choice. :)
And the more languages you learn the better and easier it becomes...

enjoy and best regards.

A

signature.asc
1K Download
</POST>
<POST>
<POSTER> Florian Kulzer &lt;florian.kulzer+deb...@icfo.es&gt; </POSTER>
<POSTDATE> 2007-08-08T17:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Aug 08, 2007 at 18:15:12 +0200, Manon Metten wrote:
&gt; Hi Andrew,

&gt; On 8/8/07, Andrew Sackville-West wrote:

&gt; &gt; Recently I've begun picking up (mostly by osmosis and from reading
&gt; &gt; posts) a lot more awk, find, and regex. Those three combined with
&gt; &gt; xargs or find -exec can get a pile of work done really quickly.

&gt; Thanks for the tip. Those are very useful commands. I will certainly
&gt; check this out and start using them.
">

I am not sure if this has been mentioned already: There is a very nice
introduction to bash, grep, sed, awk and regular expressions available
from The Linux Documentation Project:

http://www.tldp.org/LDP/Bash-Beginners-Guide/html/index.html

I would start with that before grinding through the manpages of bash,
grep, sed, awk, regex, and the abs-guide.

For Perl this is still a suitable introduction even though it is based
on an older version of the language:

http://www.comp.leeds.ac.uk/Perl/start.html

For Python:

http://hetland.org/writing/instant-python.html

These links should give you a reasonably good &quot;first impression&quot;.

--
Regards,            | http://users.icfo.es/Florian.Kulzer
Florian   |

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Vincent Lefevre &lt;vinc...@vinc17.org&gt; </POSTER>
<POSTDATE> 2007-08-09T00:10:00 </POSTDATE>
On 2007-08-08 18:03:38 +0200, Manon Metten wrote:

<QUOTE PREVIOUSPOST="
&gt; Could you explain in short why you prefer zsh over bash?
">

zsh is more powerful, e.g. recursive globbing, MULTIOS, more powerful
parameter expansion, tied parameters...

In fact, zsh is better mainly for interactive use (better completion
mechanisms, multiline editor).

--
Vincent Lefèvre &lt;vinc ... @vinc17.org&gt; - Web: &lt; http://www.vinc17.org/ &gt;
100% accessible validated (X)HTML - Blog: &lt; http://www.vinc17.org/blog/ &gt;
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Vincent Lefevre &lt;vinc...@vinc17.org&gt; </POSTER>
<POSTDATE> 2007-08-09T11:20:00 </POSTDATE>
On 2007-08-08 18:52:11 +0200, Manon Metten wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi Nelson,

&gt; On 8/8/07, Nelson Castillo &lt;nelson ... @gmail.com&gt; wrote:

&gt; &gt; Why did you switch from Perl to Python?

&gt; &gt; I found the code I wrote easier to understand. But as I said before,
&gt; &gt; I still use Perl for some tasks.

&gt; OK. I forgot to mention Perl in my initial question. But if the code is
&gt; easier to understand I guess I better try to learn Python first.
">

Well, I find Perl easier to understand. The problem may be with some
programmers who don't know how to write readable code... Now, the thing
I really hate concerning python is that it is sensitive to indentation;
this means that some operations like copy-paste or inserting a loop can
easily destroy code. And &quot;diff -b&quot; or &quot;diff -w&quot; can't be used reliably.

Also you need to take other things into account:
* What the language can express and what you need (e.g. closures,
etc.).
* The stability of the language (i.e. if features are removed or
added to new versions).

--
Vincent Lefèvre &lt;vinc ... @vinc17.org&gt; - Web: &lt; http://www.vinc17.org/ &gt;
100% accessible validated (X)HTML - Blog: &lt; http://www.vinc17.org/blog/ &gt;
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Steve Lamb &lt;g...@dmiyu.org&gt; </POSTER>
<POSTDATE> 2007-08-09T12:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Vincent Lefevre wrote:
&gt; Why not zsh (more powerful than bash) or perl?
">

Because to some Perl is horrible compared to Python.

<QUOTE PREVIOUSPOST="
&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done
">

Correct me if I'm wrong but wouldn't I just end up with with a bunch of
files named blahblah.wav.mp3?

grey@teleute:/misc/Music$ for FILE in *.mp3; do echo &quot;$FILE.mp3&quot;; done
Eric Cartman-ComeSailAway.mp3.mp3
Happy Rhodes - Summer.mp3.mp3
Happy Rhodes - The Wretches Gone Awry.mp3.mp3
Happy Rhodes - When The Rain Came Down.mp3.mp3
Johnny Lang -  Breakin' Me.mp3.mp3
johnny lang - hit the ground running (1).mp3.mp3
Johnny Lang - Matchbox.mp3.mp3
Johnny Lang - Still Raining.mp3.mp3
Johnny Lang - sugarman.mp3.mp3

So now we have to strip stuff out of the filename which involves at least
a call to cut (properly escaped, of course).  Meh, even simple examples in
shell should be avoided.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Jeff D &lt;fixedo...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T12:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Thu, 9 Aug 2007, Steve Lamb wrote:
&gt; Vincent Lefevre wrote:
&gt;&gt; Why not zsh (more powerful than bash) or perl?

&gt;    Because to some Perl is horrible compared to Python.

&gt;&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

&gt;    Correct me if I'm wrong but wouldn't I just end up with with a bunch of
&gt; files named blahblah.wav.mp3?

&gt; grey@teleute:/misc/Music$ for FILE in *.mp3; do echo &quot;$FILE.mp3&quot;; done
&gt; Eric Cartman-ComeSailAway.mp3.mp3
&gt; Happy Rhodes - Summer.mp3.mp3
&gt; Happy Rhodes - The Wretches Gone Awry.mp3.mp3
&gt; Happy Rhodes - When The Rain Came Down.mp3.mp3
&gt; Johnny Lang -  Breakin' Me.mp3.mp3
&gt; johnny lang - hit the ground running (1).mp3.mp3
&gt; Johnny Lang - Matchbox.mp3.mp3
&gt; Johnny Lang - Still Raining.mp3.mp3
&gt; Johnny Lang - sugarman.mp3.mp3

&gt;    So now we have to strip stuff out of the filename which involves at least
&gt; a call to cut (properly escaped, of course).  Meh, even simple examples in
&gt; shell should be avoided.
">

It has nothing to do with shell, python, perl or what ever.  You would
still have rename the file extention:

for FILE in *wav ; do lame -h -b 160 &quot;$FILE&quot; &quot;`echo $FILE |sed
s/.wav/.mp3/g ` &quot; ; done

-+-
8 out of 10 Owners who Expressed a Preference said Their Cats Preferred Techno.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Steve Lamb &lt;g...@dmiyu.org&gt; </POSTER>
<POSTDATE> 2007-08-09T12:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Manon Metten wrote:
&gt; - Which one is easiest to learn?
">

Between Bash and Python, Python.

<QUOTE PREVIOUSPOST="
&gt; - Which one is more powerful?
">

Python.

<QUOTE PREVIOUSPOST="
&gt; - Can I execute /bin commands from within a python script
&gt;   (something like mkdir or ls)?
">

Yes, though for those examples you don't need to.  The os library gives
you the ability to do the above and much more.  There is also a module called
shutil which provides the basic functionality of different shell utilities
available natively in Python.  I have rarely had to resort to calling
something in shell to do anything shell can do.

<QUOTE PREVIOUSPOST="
&gt; Or should I learn bash scripting anyway?
">

Learn enough to be able to parse it and convert it to your language of
choice.  There are exceptions, of course, but by and large it has been my
experience that any place you're required to use shell Python is also
available and a far better choice.  As an example here is the shell example
given earlier:

for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

The same in Python but with far greater functionality:

import os
for file in os.listdir('.'):
root, ext = os.path.splitext(file)
if ext.lower() == 'wav':
mp3 = root + '.mp3'
result = os.system(&quot;lame -h -b 160 '%s' '%s'&quot; % (file, mp3))
if result:
print '%s not converted' % file

Longer, yes.  Easier to follow?  Most certainly.  Superior, no doubt.  The
shell example would miss WAV, Wav, wAv, etc.  Secondly the only place we need
to escape the variable is when we need shell to do some work, namely the call
to lame.  Finally we don't end up with '.wav.mp3' files all over the place.
We can check the results easily and handle failures gracefully.  Can all of
that be done in shell?  Certainly.  Is it worth doing in shell?  Not hardly.

I don't use shell even for one liners these days because of the errors
introduced by globbing and spaces in filenames.  Yes, if one keeps them in
mind when writing shell then they aren't /too/ much of a problem.  But in a
proper language like Python (Perl, Ruby, take your pick) one doesn't have to
keep it in mind *at all* except when dealing with shell.  Not to mention the
native methods for dealing with some issues, like stripping the extension from
the root of a file, are trivial in Python while an exercise in frustration in
pure shell.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T13:00:00 </POSTDATE>
Hi Florian,

On 8/8/07, Florian Kulzer &lt;florian.kulzer+deb ... @icfo.es&gt; wrote:

http://www.tldp.org/LDP/Bash-Beginners-Guide/html/index.html

<QUOTE PREVIOUSPOST="
&gt; http://www.comp.leeds.ac.uk/Perl/start.html
&gt; http://hetland.org/writing/instant-python.html
">

Thanks for the links. They are very useful. Although I did already
some reading of Bash-Beginners-Guide I still find it hard to
understand. But I think I gradually will make some progress.

Greetings, Manon.
</POST>
<POST>
<POSTER> Florian Kulzer &lt;florian.kulzer+deb...@icfo.es&gt; </POSTER>
<POSTDATE> 2007-08-09T13:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Thu, Aug 09, 2007 at 09:25:20 -0700, Steve Lamb wrote:
&gt; Vincent Lefevre wrote:
&gt; &gt; Why not zsh (more powerful than bash) or perl?

&gt;     Because to some Perl is horrible compared to Python.

&gt; &gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

&gt;     Correct me if I'm wrong but wouldn't I just end up with with a bunch of
&gt; files named blahblah.wav.mp3?
">

[...]

<QUOTE PREVIOUSPOST="
&gt;     So now we have to strip stuff out of the filename which involves at least
&gt; a call to cut (properly escaped, of course).  Meh, even simple examples in
&gt; shell should be avoided.
">

You don't need to use cut; bash can do it directly if you use
&quot;${FILE%wav}mp3&quot; as the output filename in the for loop.

--
Regards,            | http://users.icfo.es/Florian.Kulzer
Florian   |

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Steve Lamb &lt;g...@dmiyu.org&gt; </POSTER>
<POSTDATE> 2007-08-09T13:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Manon Metten wrote:
&gt;     Well, I find Perl easier to understand. The problem may be with some
&gt;     programmers who don't know how to write readable code... Now, the thing
&gt;     I really hate concerning python is that it is sensitive to indentation;
&gt;     this means that some operations like copy-paste or inserting a loop can
&gt;     easily destroy code. And &quot;diff -b&quot; or &quot;diff -w&quot; can't be used reliably.
&gt; Well, that's a major disadvantage to me too.
">

Actually, it isn't.  At no time have I ever had any problems with Python
code which would not also be an issue in other code as well.  The only
difference being you have to be careful about indention in one case, braces in
the other.  Besides, let's face it, if there is a person who puts code into
place and then doesn't make the indention make sense to ensure they did the
job properly is that someone who's opinion we're going to trust when it comes
to decent coding practices?  Most people are going to make the indention match
*anyway*.  Since pretty much every programmer's editor comes with de/indent a
block of text there is no problem.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T13:20:00 </POSTDATE>
Hi Vincent,

On 8/9/07, Vincent Lefevre &lt;vinc ... @vinc17.org&gt; wrote:

zsh is more powerful, e.g. recursive globbing, MULTIOS, more powerful

<QUOTE PREVIOUSPOST="
&gt; parameter expansion, tied parameters...

&gt; In fact, zsh is better mainly for interactive use (better completion
&gt; mechanisms, multiline editor).
">

I'll take a look at their website.

Well, I find Perl easier to understand. The problem may be with some

<QUOTE PREVIOUSPOST="
&gt; programmers who don't know how to write readable code... Now, the thing
&gt; I really hate concerning python is that it is sensitive to indentation;
&gt; this means that some operations like copy-paste or inserting a loop can
&gt; easily destroy code. And &quot;diff -b&quot; or &quot;diff -w&quot; can't be used reliably.
">

Well, that's a major disadvantage to me too.

Also you need to take other things into account:

<QUOTE PREVIOUSPOST="
&gt;   * What the language can express and what you need (e.g. closures,
&gt;     etc.).
">

OK. On my Amiga I had not so much choice, so in many cases, I had to
do some work-around in order to achieve what I wanted. But in Linux, waw,
it is so comprehensive that the choices are somewhat overwhelming.

Thanks for your reply, Manon.
</POST>
<POST>
<POSTER> Steve Lamb &lt;g...@dmiyu.org&gt; </POSTER>
<POSTDATE> 2007-08-09T13:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jeff D wrote:
&gt; It has nothing to do with shell, python, perl or what ever.  You would
&gt; still have rename the file extention:
">

Yes, you would.  And therein lies the point.  One liners often aren't.
Quite often something comes up and &quot;whoops, need to do this&quot; and then &quot;d'oh,
need to do that&quot; and pretty soon that one liner is taking up 3 lines on the
screen and would be far easier to read if it were written in a text file.

I prefer to just skip the &quot;whoops, need to add this step&quot; prior to getting
to the text file and just write in a language that is far better suited to the
task.  For extremely small operations I lose a small amount of time.  For
anything barely above the most basic complexity I gain time.  Not only that
but I gain a metric buttload of functionality for a minimum of trouble.

Quick, take your one liner, have it traverse an entire directory tree
converting all the wavs (regardless of capitalization) to mp3s, oggs and flac,
sorting all 4 into their own directory trees.

For me I just need to change my small script into a function, wrap it
inside os.walk() and have calls to os.makedirs() and shutil.copy() to do all
the work.  Several more minutes of work and I can add in checks for the same
files with different names, prompt the user to pick a name to use, convert
that one and delete the rest.  Then for my final trick I can wrap it all up as
a library, still retaining its ability to run as a stand alone script, and
import it into other Python scripts.

That is where shell falls down.  A decent tinkerer starts with a &quot;this'd
be neat&quot; few lines of code and expands it to a dozen, several dozen, hundreds
of lines of code.  I have not found a person who would argue that shell is
viable outside a dozen or so lines of code; at least not when there are
alternatives like Python, Perl or Ruby laying around to be used.  It is that
capacity to keep adding, and adding, and adding, growing it larger, splitting
it into parts, reusing all those parts that shell simply cannot do as
effectively as languages designed to do that from the get go.

Real world example.  At work there was a daily reports process that I
wanted to automate.  Since we're working on Windows conventional shell was
right out.  So I convinced them to install Python on that machine.  In the 10
months since that time the original report-filing script has exploded into 3
discrete libraries, 3 main scripts which call approximately 8 other scripts
(which are usable stand alone).  It does everything from report-filing to
account verification and a baby-DB query.  It all grew from a simple 2kb
script which was replacing a badly broken batch file to the current size in
excess of 40kb of Python code.  Note that none of the functionality in it
today was planned from the first day.  I would have tore my hair out doing the
simplest things in shell much less when the time came to rewrite all of that
from shell to Python.  Better that I started in Python and grew from there.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T13:40:00 </POSTDATE>
Hi Steve,

On 8/9/07, Steve Lamb &lt;g ... @dmiyu.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Or should I learn bash scripting anyway?

&gt; Learn enough to be able to parse it and convert it to your language of
&gt; choice.
">

That's a valuable advice. It'll save me a lot of time and yet I'll be able
to achieve what I want.

import os

<QUOTE PREVIOUSPOST="
&gt; for file in os.listdir('.'):
&gt;     root, ext = os.path.splitext(file)
&gt;     if ext.lower() == 'wav':
&gt;         mp3 = root + '.mp3'
&gt;         result = os.system(&quot;lame -h -b 160 '%s' '%s'&quot; % (file, mp3))
&gt;         if result:
&gt;             print '%s not converted' % file
">

Longer, yes.  Easier to follow?  Most certainly.  Superior, no

<QUOTE PREVIOUSPOST="
&gt; doubt.  The
&gt; shell example would miss WAV, Wav, wAv, etc.  Secondly the only place we
&gt; need
&gt; to escape the variable is when we need shell to do some work, namely the
&gt; call
&gt; to lame.  Finally we don't end up with '.wav.mp3' files all over the
&gt; place.
&gt; We can check the results easily and handle failures gracefully.  Can all
&gt; of
&gt; that be done in shell?  Certainly.  Is it worth doing in shell?  Not
&gt; hardly.
">

On my Amiga I'm used to ARexx. It has some same advantages over AmigaDOS
like you describe above about bash vs. python. Fortunately there's
regina-rexx for
Linux. It has the same syntax and I've already written some scripts
combining
regina-rexx and grep. But I think the scope of regina-rexx is somewhat
limited
compared to python. But for the moment I can use it and gradually learn
bash,
python, perl or whatever suits me.

Greetings, Manon.
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T13:50:00 </POSTDATE>
Hi Steve,

On 8/9/07, Steve Lamb &lt;g ... @dmiyu.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt;  python ... is sensitive to indentation;

&gt; &gt; Well, that's a major disadvantage to me too.

&gt;     Actually, it isn't.  At no time have I ever had any problems with
&gt; Python
&gt; code which would not also be an issue in other code as well.  The only
&gt; difference being you have to be careful about indention in one case,
&gt; braces in
&gt; the other.  Besides, let's face it, if there is a person who puts code
&gt; into
&gt; place and then doesn't make the indention make sense to ensure they did
&gt; the
&gt; job properly is that someone who's opinion we're going to trust when it
&gt; comes
&gt; to decent coding practices?  Most people are going to make the indention
&gt; match
&gt; *anyway*.  Since pretty much every programmer's editor comes with
&gt; de/indent a
&gt; block of text there is no problem.
">

Than, probably I didn't understand it correct. I thought of it as some
prefixed
indentation. I like eg. to indent with two spaces and not four or six. But
then I
consequently stick to it. If that's what you mean, then it ain't no problem
for me.

Manon.

--

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
&gt; with a subject of &quot;unsubscribe&quot;. Trouble? Contact
&gt; listmas ... @lists.debian.org
">
</POST>
<POST>
<POSTER> Ron Johnson &lt;ron.l.john...@cox.net&gt; </POSTER>
<POSTDATE> 2007-08-09T13:50:00 </POSTDATE>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 08/09/07 11:51, Florian Kulzer wrote:

<QUOTE PREVIOUSPOST="
&gt; On Thu, Aug 09, 2007 at 09:25:20 -0700, Steve Lamb wrote:
&gt;&gt; Vincent Lefevre wrote:
&gt;&gt;&gt; Why not zsh (more powerful than bash) or perl?
&gt;&gt;     Because to some Perl is horrible compared to Python.

&gt;&gt;&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done
&gt;&gt;     Correct me if I'm wrong but wouldn't I just end up with with a bunch of
&gt;&gt; files named blahblah.wav.mp3?

&gt; [...]

&gt;&gt;     So now we have to strip stuff out of the filename which involves at least
&gt;&gt; a call to cut (properly escaped, of course).  Meh, even simple examples in
&gt;&gt; shell should be avoided.

&gt; You don't need to use cut; bash can do it directly if you use
&gt; &quot;${FILE%wav}mp3&quot; as the output filename in the for loop.
">

Or use basename(1).

- --
Ron Johnson, Jr.
Jefferson LA  USA

Give a man a fish, and he eats for a day.
Hit him with a fish, and he goes away for good!

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGu1HnS9HxQb37XmcRAuxhAKDROJfK9dx2QPwvr+jgyUFz7cXQ8QCfVyvb
LVICBc+TtSyr1djleMIEK1k=
=PqqS
-----END PGP SIGNATURE-----

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Ron Johnson &lt;ron.l.john...@cox.net&gt; </POSTER>
<POSTDATE> 2007-08-09T14:00:00 </POSTDATE>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 08/09/07 12:19, Steve Lamb wrote:

<QUOTE PREVIOUSPOST="
&gt; Manon Metten wrote:
&gt;&gt;     Well, I find Perl easier to understand. The problem may be with some
&gt;&gt;     programmers who don't know how to write readable code... Now, the thing
&gt;&gt;     I really hate concerning python is that it is sensitive to indentation;
&gt;&gt;     this means that some operations like copy-paste or inserting a loop can
&gt;&gt;     easily destroy code. And &quot;diff -b&quot; or &quot;diff -w&quot; can't be used reliably.

&gt;&gt; Well, that's a major disadvantage to me too.

&gt;     Actually, it isn't.  At no time have I ever had any problems with Python
&gt; code which would not also be an issue in other code as well.  The only
&gt; difference being you have to be careful about indention in one case, braces in
&gt; the other.  Besides, let's face it, if there is a person who puts code into
&gt; place and then doesn't make the indention make sense to ensure they did the
&gt; job properly is that someone who's opinion we're going to trust when it comes
&gt; to decent coding practices?  Most people are going to make the indention match
&gt; *anyway*.  Since pretty much every programmer's editor comes with de/indent a
&gt; block of text there is no problem.
">

Just remember to tell you editor to &quot;inserts spaces as tab&quot; and set
the tab width to something reasonable like 4.

- --
Ron Johnson, Jr.
Jefferson LA  USA

Give a man a fish, and he eats for a day.
Hit him with a fish, and he goes away for good!

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)

iD8DBQFGu1TRS9HxQb37XmcRAhLsAJ9jaJ+/CsXhjkiATKufjrJcUB1T+ACg3rPP
tJLPLTlCgvVtnsxumbRUXiM=
=4+Bb
-----END PGP SIGNATURE-----

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> mmiller3 &lt;mmill...@iupui.edu&gt; </POSTER>
<POSTDATE> 2007-08-09T14:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt;&gt;&gt;&gt;&gt; &quot;Jeff&quot; == Jeff D &lt;fixedo ... @gmail.com&gt; writes:
">

&gt; You would still have rename the file extention:

&gt; for FILE in *wav ; do lame -h -b 160 &quot;$FILE&quot; &quot;`echo $FILE
&gt; |sed s/.wav/.mp3/g ` &quot; ; done

Or just use the shell itself:

for FILE in *wav ; do lame -h -b 160 \&quot;$FILE\&quot; \&quot;${FILE%.*}.mp3\&quot;; done

Mike

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Steve Lamb &lt;g...@dmiyu.org&gt; </POSTER>
<POSTDATE> 2007-08-09T14:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Manon Metten wrote:
&gt; Than, probably I didn't understand it correct. I thought of it as some
&gt; prefixed indentation. I like eg. to indent with two spaces and not four or
&gt; six. But then I consequently stick to it. If that's what you mean, then it
&gt; ain't no problem for me.
">

It is but it isn't.  Take my previous example of code.  There are 3 blocks
in it.  The indention tells both the human and the interpretor which block is
which.

import os
for file in os.listdir('.'):
root, ext = os.path.splitext(file)
if ext.lower() == 'wav':
mp3 = root + '.mp3'
result = os.system(&quot;lame -h -b 160 '%s' '%s'&quot; % (file, mp3))
if result:
print '%s not converted' % file

I chose 4 spaces because that is the standard of the Python community.
You can do 2, as I did when I converted from Perl to Python, and as long as
you're consistent then you'll have no problems in your code.  You will have
some minute problems importing code intended with 4 spaces but it really is
trivial to fix.  On the other hand switching to 4 spaces makes it uniform and
I have found that the reasons I used 2 in Perl don't occur much in Python
though that might be more a function of my experience resulting in more
concise code than anything else.

Also you don't have to worry about indention as slavishly as in Fortran
which is what some people's experience with significant indention comes from.
The following is perfectly legal and identical in Python:

if something or that_thing and not something_else:

if something or
that_thing and
not something_else:

Also things like this:

foo = [spam,
ham,
eggs,
baked beans,
special sauce]

Significant indention does not apply inside statements or declarations.
It really is quite natural if you indent properly in the first place.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> Jeff D &lt;fixedo...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T14:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Thu, 9 Aug 2007, mmiller3 wrote:
&gt;&gt;&gt;&gt;&gt;&gt; &quot;Jeff&quot; == Jeff D &lt;fixedo ... @gmail.com&gt; writes:

&gt;    &gt; You would still have rename the file extention:

&gt;    &gt; for FILE in *wav ; do lame -h -b 160 &quot;$FILE&quot; &quot;`echo $FILE
&gt;    &gt; |sed s/.wav/.mp3/g ` &quot; ; done

&gt; Or just use the shell itself:

&gt;  for FILE in *wav ; do lame -h -b 160 \&quot;$FILE\&quot; \&quot;${FILE%.*}.mp3\&quot;; done

&gt; Mike
">

Makes even more sense! Thanks! I don't know how many times I've read over
shell substitution, just never clicked I guess.  But, it's always good to
learn new tricks!

-+-
8 out of 10 Owners who Expressed a Preference said Their Cats Preferred Techno.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> &quot;Manon Metten&quot; &lt;manon.met...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-09T14:40:00 </POSTDATE>
Hi Steve,

Thanks for explaining. I'll examine some scripts I'll find on the web,
to get an idea of how it looks.

Manon.
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-09T16:30:00 </POSTDATE>
On Aug 9, 2007, at 9:25 AM, Steve Lamb wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt;   for FILE in *.wav; do lame -h -b 160 &quot;$FILE&quot; &quot;$FILE.mp3&quot;; done

&gt;     Correct me if I'm wrong but wouldn't I just end up with with a
&gt; bunch of
&gt; files named blahblah.wav.mp3?
">

Follow it with &quot;rename .wav.mp3 .mp3 *&quot;. :)

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
<POST>
<POSTER> David Brodbeck &lt;bro...@u.washington.edu&gt; </POSTER>
<POSTDATE> 2007-08-09T16:30:00 </POSTDATE>
On Aug 9, 2007, at 10:19 AM, Steve Lamb wrote:

<QUOTE PREVIOUSPOST="
&gt;     Actually, it isn't.  At no time have I ever had any problems
&gt; with Python
&gt; code which would not also be an issue in other code as well.  The only
&gt; difference being you have to be careful about indention in one
&gt; case, braces in
&gt; the other.
">

Still, after dealing with all the nightmares of things like 'make'
that care about tabs vs. spaces, etc., I'm inclined to shy away from
languages where whitespace is critically important.  Whitespace is so
fragile.

--
To UNSUBSCRIBE, email to debian-user-REQU ... @lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmas ... @lists.debian.org
</POST>
</TEXT>
</BODY>
</DOC>
