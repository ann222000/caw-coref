<DOC>
<DOCID> eng-NG-31-147312-8791050 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-09-24T15:23:00 </DATETIME>
<BODY>
<HEADLINE>
project for interested people
</HEADLINE>
<TEXT>
<POST>
<POSTER> Jonathan LaCour &lt;jonathan-li...@cleverdevil.org&gt; </POSTER>
<POSTDATE> 2007-09-24T15:23:00 </POSTDATE>
I just had a great discussion with Ben Bangert on IM about the wonders
and perils of developing with Elixir.  We've been discussing this
for some time, some of that discussion taking place in public as we
exchanged blog posts.  Ben and I were discussing how one of the issues
that you may run into when using Elixir is that you may not understand
*exactly* what Elixir is doing under the covers, which makes utilizing
the excellent SQLAlchemy documentation a bit difficult sometimes.

We came up with the concept of a utility function in Elixir that could
dump out your entire model as a plain SQLAlchemy model, complete
with table and object definitions.  This would give users a way to
see precisely what is being generated by Elixir, and would help them
correlate their questions back to the SQLAlchemy documentation when
their own understanding fails them.

I think that this would be a fantastic project for someone who is
interested in taking a more active role in Elixir development, but
doesn't know where to start.  If you're interested in helping create
this useful tool, please let me (and the list) know, and I'll help you
get started.

--
Jonathan LaCour
http://cleverdevil.org
</POST>
<POST>
<POSTER> Ben Bangert &lt;gasp...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T15:46:00 </POSTDATE>
On Sep 24, 12:23 pm, Jonathan LaCour

<QUOTE PREVIOUSPOST="
&gt; We came up with the concept of a utility function in Elixir that could
&gt; dump out your entire model as a plain SQLAlchemy model, complete
&gt; with table and object definitions.  This would give users a way to
&gt; see precisely what is being generated by Elixir, and would help them
&gt; correlate their questions back to the SQLAlchemy documentation when
&gt; their own understanding fails them.
">

I should note that in addition tot he object definitions, the mapper
and relation setup would also be dumped out. Off-hand, I think the
tables can be generated fairly easily off the table objects by
crawling the metadata to see what tables its tracking and going
through and printing out their columns, etc.

The mapper might be a little harder, as one would need to reverse
engineer (or track during mapper/relation construction), what mapper
was applied to what objects, and what properties it had (including all
its relations, and their setup).

My thought being that if you see some unexpected behavior, perhaps you
forgot to pass cascade=&quot;all, delete-orphan&quot; into one of your m2m
relations, etc. it'd be easier to view a dump of what Elixir did for
you, then to try and recreate what it did in your head looking at some
big doc explaining all the steps Elixir takes when constructing the
mapper and tables.

Cheers,
Ben
</POST>
<POST>
<POSTER> Jonathan LaCour &lt;jonathan-li...@cleverdevil.org&gt; </POSTER>
<POSTDATE> 2007-09-24T16:12:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ben Bangert wrote:
&gt; I should note that in addition tot he object definitions, the mapper
&gt; and relation setup would also be dumped out.
">

Yes, this is really the most important part.

<QUOTE PREVIOUSPOST="
&gt; Off-hand, I think the tables can be generated fairly easily off the
&gt; table objects by crawling the metadata to see what tables its tracking
&gt; and going through and printing out their columns, etc.
">

Its much easier than this, actually.  You pretty much just need to do a
repr() on the table object, and it'll dump out its own definition.  I
wish it was the same thing for mappers, but unfortunately this isn't the
case as of right now :/

<QUOTE PREVIOUSPOST="
&gt; The mapper might be a little harder, as one would need to reverse
&gt; engineer (or track during mapper/relation construction), what mapper
&gt; was applied to what objects, and what properties it had (including all
&gt; its relations, and their setup).
">

Yes, this is indeed the difficult part.  The easiest thing to do would
likely be to put some code in elixir itself, since it creates all of the
mappers, so you'll have everything you need at your fingertips to dump
out the mapper definitions.

The better thing would probably be to submit a patch to SQLAlchemy
to make it so that repr(some_mapper) did the same thing as
repr(some_table), and maybe an additional patch to cleanup both outputs
so that they are formatted and indented nicely.

<QUOTE PREVIOUSPOST="
&gt; My thought being that if you see some unexpected behavior, perhaps
&gt; you forgot to pass cascade=&quot;all, delete-orphan&quot; into one of your m2m
&gt; relations, etc. it'd be easier to view a dump of what Elixir did for
&gt; you, then to try and recreate what it did in your head looking at some
&gt; big doc explaining all the steps Elixir takes when constructing the
&gt; mapper and tables.
">

Agreed.

--
Jonathan LaCour
http://cleverdevil.org
</POST>
<POST>
<POSTER> &quot;Gaetan de Menten&quot; &lt;gdemen...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T04:27:00 </POSTDATE>
On 9/24/07, Ben Bangert &lt;gasp ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Sep 24, 12:23 pm, Jonathan LaCour
&gt; &gt; We came up with the concept of a utility function in Elixir that could
&gt; &gt; dump out your entire model as a plain SQLAlchemy model, complete
&gt; &gt; with table and object definitions.  This would give users a way to
&gt; &gt; see precisely what is being generated by Elixir, and would help them
&gt; &gt; correlate their questions back to the SQLAlchemy documentation when
&gt; &gt; their own understanding fails them.

&gt; I should note that in addition tot he object definitions, the mapper
&gt; and relation setup would also be dumped out. Off-hand, I think the
&gt; tables can be generated fairly easily off the table objects by
&gt; crawling the metadata to see what tables its tracking and going
&gt; through and printing out their columns, etc.

&gt; The mapper might be a little harder, as one would need to reverse
&gt; engineer (or track during mapper/relation construction), what mapper
&gt; was applied to what objects, and what properties it had (including all
&gt; its relations, and their setup).
&gt; My thought being that if you see some unexpected behavior, perhaps you
&gt; forgot to pass cascade=&quot;all, delete-orphan&quot; into one of your m2m
&gt; relations, etc. it'd be easier to view a dump of what Elixir did for
&gt; you, then to try and recreate what it did in your head looking at some
&gt; big doc explaining all the steps Elixir takes when constructing the
&gt; mapper and tables.
">

I entirely agree on this. Actually I already had that very same idea a
few times when trying to debug things. I didn't think it could be used
for something else than debugging though. And what prevented me of
actually doing it is that I would like that to be an extension to
Elixir, and not in the core. And I thought that doing it that way
wouldn't be easy or even possible to do reliably and consistently as
it's up to the statements to &quot;save&quot; any arguments they receive.

Now, your post prompted me to rethink that, and now I think it would
be fairly doable but most of the work should happen on SQLAlchemy's
side of things. I see two options:

Either we do a accurate emulation of what Elixir does, by
monkey-patching a few methods in SQLAlchemy to do some special logging
(or, more cleanly, implement that in SQLAlchemy as a special logger
that we can just turn on).

The methods in question are all those SQLAlchemy &quot;mutator&quot; methods
that we use, ie:

Table.__init__
Table.append_column
Table.append_constraint
Mapper.__init__
Mapper.add_property

and maybe a few more (I didn't check).

The other option is to output a dump of the table and mapper after
everything has been initialized. This would lead to much more readable
code BUT would be way less accurate and could hide some bugs (related
to the initialization sequence). Besides, if the setup doesn't
complete, you are left in the dark, which is precisely when such
functionality would be most useful, so I'd favor the first option,
even though the second one has some merit. And either way, I think
this should be done mostly on SQLAlchemy's side.

--
Gaëtan de Menten
http://openhex.org
</POST>
<POST>
<POSTER> Jonathan LaCour &lt;jonathan-li...@cleverdevil.org&gt; </POSTER>
<POSTDATE> 2007-09-25T10:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Gaetan wrote:
&gt; Now, your post prompted me to rethink that, and now I think it would
&gt; be fairly doable but most of the work should happen on SQLAlchemy's
&gt; side of things.
">

Ideally, I agree.  I had some discussions with Ben about this yesterday,
and he talked with Mike briefly.  Mike seemed to be of the opinion that
it wouldn't be very easy to do this on the SQLAlchemy side.  I think he
might just be saying it would be hard to reflect the data out of the
existing mappers, which is probably true, but I can't imagine that it
would be all *that* difficult if you enhanced the SQLAlchemy mapper so
that it recorded some additional metadata as the mapper was created and
modified.

<QUOTE PREVIOUSPOST="
&gt; I see two options:

&gt; Either we do a accurate emulation of what Elixir does, by
&gt; monkey-patching a few methods in SQLAlchemy to do some special logging
&gt; (or, more cleanly, implement that in SQLAlchemy as a special logger
&gt; that we can just turn on).
">

If we're going to monkeypatch, we might as well just do the entire thing
on the Elixir side of things, IMO.  It'll probably be easier, and it'll
be less fragile.  If we're to do it on the SQLAlchemy side, I'd like
to see if we can work with Mike to get it integrated into SQLAlchemy
proper, so that it'll be stable, and generally useful.  I am not sure
how receptive Mike would be to a patch, though.

<QUOTE PREVIOUSPOST="
&gt; The other option is to output a dump of the table and mapper after
&gt; everything has been initialized. This would lead to much more readable
&gt; code BUT would be way less accurate and could hide some bugs (related
&gt; to the initialization sequence). Besides, if the setup doesn't
&gt; complete, you are left in the dark, which is precisely when such
&gt; functionality would be most useful, so I'd favor the first option,
&gt; even though the second one has some merit.
">

The table dump already works, after the fact, as I mentioned earlier.
All you have to do is call `repr(MyEntity.table)` after `setup_all` has
been called, and you'll get back a dump of the full table definition.
Obviously, this isn't true for the mapper yet.

I don't think that there would necessarily be bugs in the post
initialization method relating to initialization sequence, since we
could just ensure that `setup_all` has been called before the dump
occurs.  That being said, your point about this approach being fragile
when initialization is failing is a good one.  I had thought of the
primary use case for this to dump out a working model, not to debug a
broken one.  If we want to support the broken model case then we'll have
to take another approach.

Personally, I don't see dumping a broken model as being that compelling
of a use case.  I'd prefer to make sure that the exceptions we raise
when a model is broken are clear enough to help users fix their model.
Once their model is working, they can get a dump of what it looks like
as tables and mappers.  What do you think?

--
Jonathan LaCour
http://cleverdevil.org
</POST>
<POST>
<POSTER> Isaac Csandl &lt;nerk...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T15:32:00 </POSTDATE>
-1 on dumping a broken model. It seems like a lot of effort just to
produce also-broken SA code.

--Isaac
</POST>
</TEXT>
</BODY>
</DOC>
