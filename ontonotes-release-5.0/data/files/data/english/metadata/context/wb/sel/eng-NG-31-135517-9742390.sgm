<DOC>
<DOCID> eng-NG-31-135517-9742390 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2008-01-04T00:11:00 </DATETIME>
<BODY>
<HEADLINE>
Problem with recursion? (was [plt-scheme] Re: Novice needs help writing function )
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;Grant Rettke&quot; &lt;gret...@acm.org&gt; </POSTER>
<POSTDATE> 2008-01-04T00:11:00 </POSTDATE>
This thread had mentioned helping students understand recursion, and
for some reason, this topic of understanding recursion has come up a
lot lately &quot;by the water cooler&quot;, among other things.

I recently heard that a particular teacher quit trying to teach
recursion because &quot;it is too hard for students to understand&quot;.

Is there an epidemic of sorts that students don't understand recursion?

What are the challenges to understanding recursion?
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Carl Eastlund&quot; &lt;c...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T00:48:00 </POSTDATE>
On Jan 4, 2008 12:11 AM, Grant Rettke &lt;gret ... @acm.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I recently heard that a particular teacher quit trying to teach
&gt; recursion because &quot;it is too hard for students to understand&quot;.

&gt; Is there an epidemic of sorts that students don't understand recursion?

&gt; What are the challenges to understanding recursion?
">

My guess?  Teachers that don't understand recursion are probably the
biggest obstacle to students learning recursion.  That, and curricula
based in imperative, iterative programming.  Get students hopelessly
mired in spaghetti code based on &quot;bang this ref cell here&quot; and &quot;jump
to that label there&quot;, and then try to explain recursion in terms of
that, and yeah, it's gonna look tricky.

I'll admit that I haven't seen an introductory course other than How
To Design Programs in years, though.  So I don't have my finger on the
pulse of all these classrooms having problems.

--
Carl Eastlund
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T06:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Grant Rettke wrote:
&gt; This thread had mentioned helping students understand recursion, and
&gt; for some reason, this topic of understanding recursion has come up a
&gt; lot lately &quot;by the water cooler&quot;, among other things.

&gt; I recently heard that a particular teacher quit trying to teach
&gt; recursion because &quot;it is too hard for students to understand&quot;.

&gt; Is there an epidemic of sorts that students don't understand recursion?

&gt; What are the challenges to understanding recursion?
&gt; _________________________________________________
&gt;   For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

I am not sure that there is anything wrong with students or the teaching
of recursion. Not every student is a quick study and not every concept
can be taught easily. Teachers shouldn't give up a useful concept
because of perceived teaching difficulties, and students who don't get
it the first time, should take another class with similar subject matter
or study on their own.

Having said that, the only difficulty I had with learning recursion is
that the examples typically used to introduce it do not benefit from
recursion. Fibonacci does not need recursion, its just as easy to
express it iteratively. When you are presented with such an example as
your first recursive program, it may hard to see the point, even if you
get the mechanics of it.

I can vaguely remember that SPIC had an exercise about figuring out how
many different ways you could change x dollars into coins that was much
easier to solve recursively than iteratively. Personally, I would start
with something like that, let the students struggle a bit trying to
solve it &quot;the usual way&quot; then come to the rescue with recursion.

And while I am on the subject of examples, why do introductory
programming books use so many mathematical examples? IMVHO, there are
only three subjects that can interest a young student: sex, video games
and programming tools. Putting the first two aside for PC, an example
about an text editor would be much more interesting than, say, Fibonacci.

Yavuz
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Bill Wood &lt;william.wo...@comcast.net&gt; </POSTER>
<POSTDATE> 2008-01-04T06:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Fri, 2008-01-04 at 13:00 +0200, Yavuz Arkun wrote:
">

. . .

<QUOTE PREVIOUSPOST="
&gt; And while I am on the subject of examples, why do introductory
&gt; programming books use so many mathematical examples? IMVHO, there are
&gt; only three subjects that can interest a young student: sex, video games
&gt; and programming tools. Putting the first two aside for PC, an example
&gt; about an text editor would be much more interesting than, say, Fibonacci.
">

Careful with that.  I was entranced with numbers as early as the third
grade, and I had friends all the way through school who were also.
Don't disenfranchise such youth in the name of broad appeal.  I came
upon programming much later (college age), and I found recursion
fascinating and appealing precisely because you could compute my old
friends the Fibs in the same way they were defined.  The efficiency
difference between recursion and iteration was such a let-down.

-- Bill Wood

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Dave Griffiths&quot; &lt;d...@pawfal.org&gt; </POSTER>
<POSTDATE> 2008-01-04T07:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; And while I am on the subject of examples, why do introductory
&gt; programming books use so many mathematical examples? IMVHO, there are
&gt; only three subjects that can interest a young student: sex, video games
&gt; and programming tools. Putting the first two aside for PC, an example
&gt; about an text editor would be much more interesting than, say, Fibonacci.
">

I've taught recursion to arty types with no prior programming experience
in the context of graphics, usually by drawing a row of cubes, followed by
a tree of cubes in fluxus (as it's a simple modification from one to the
other).

Predictably Escher usually comes into it somewhere too:
http://www.flickr.com/photos/transphormetic/279760855/in/set-72157594...

I'm not trained as a teacher (or computer scientist) so I'm probably not
very good at it, and also I throw it at them very early on. I've noticed
it's the difference between the process and the procedure definition that
some people have a hard time following - the idea of a procedure calling
itself means that they are forced to separate them.

I don't think this is better than a mathematical explanation, it really
depends on the individual I guess.

cheers,

dave

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T09:16:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bill Wood wrote:
&gt; On Fri, 2008-01-04 at 13:00 +0200, Yavuz Arkun wrote:
&gt;    . . .

&gt;&gt; And while I am on the subject of examples, why do introductory
&gt;&gt; programming books use so many mathematical examples? IMVHO, there are
&gt;&gt; only three subjects that can interest a young student: sex, video games
&gt;&gt; and programming tools. Putting the first two aside for PC, an example
&gt;&gt; about an text editor would be much more interesting than, say, Fibonacci.

&gt; Careful with that.  I was entranced with numbers as early as the third
&gt; grade, and I had friends all the way through school who were also.
&gt; Don't disenfranchise such youth in the name of broad appeal.  I came
&gt; upon programming much later (college age), and I found recursion
&gt; fascinating and appealing precisely because you could compute my old
&gt; friends the Fibs in the same way they were defined.  The efficiency
&gt; difference between recursion and iteration was such a let-down.

&gt;  -- Bill Wood
">

Yes, I agree that mathematics is interesting for some people, including
me. However, I took the OP to mean that there is a large chunk
(majority? sizable minority? undesirably large in any case) of the
student body who are unable to understand recursion as it is usually
covered. For them, something else needs to be done (other then giving up
teaching recursion.)

BTW, I first learned about the Fibonacci series in high school, and we
were told they are generated by &quot;start with 1, 1, and then add the last
2 together to get the next one...&quot;, e.g. iteratively. For me the
recursive definition is contrived, and I saw it for the first time in
intro programming books. I guess this shows that prior teaching of
iterative style kills some neurons forever.

Anyway, probably everyone has their favorite example/exercise style.
Mine happens to be programming tools. My ideal introductory programming
text would be built around an extended series of examples/exercises that
construct increasingly complete instances of a tool, say a text editor,
or even a compiler, that leads to a simple, but real-world program.
Maybe someone could deconstruct Emacs and rebuild it as a teaching
exercise? ;)

Yavuz
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T09:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; I recently heard that a particular teacher quit trying to teach
&gt; recursion because &quot;it is too hard for students to understand&quot;.

&gt; Is there an epidemic of sorts that students don't understand recursion?

&gt; What are the challenges to understanding recursion?
&gt; _________________________________________________
">

There is nothing inherently hard about teaching recursion or having
students understand recursion if it is done right and _before_
teaching iteration with assignment. IMHO, if you follow the design
recipe and the &quot;shape of the data tells you the shape of your program&quot;
principle you really get recursion for free (i.e. it just comes
natural). If students never &quot;learn&quot; that a function calling itself is
&quot;weird&quot; or &quot;hard to design,&quot; students usually do not get stuck with
it. The important thing is that students can see that there is a
structure that a program follows.

In my experience, the biggest problem I have seen others have is that
they bang iteration and assignment into students head and then
students instinctively reach for assignment to solve every problem.
These students do not have the benefit of understanding the connection
between tail-recursion and iteration. These students are focusing much
more on trying to put statements in the right order rather than
solving the problem at hand.

Finally, starting with recursion on an integer is IMHO a poor way to
start. For me, it is much easier to introduce recursion when working
with compound data like lists and trees. Students seem to have less
trouble at the beginning with this type of data for resursion than
with a range of numbers represented by a single integer.

Cheers,

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T09:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt; recursive definition is contrived, and I saw it for the first time in
&gt; intro programming books. I guess this shows that prior teaching of
&gt; iterative style kills some neurons forever.
">

;;; fib: number -&gt; number
(define (fib n)
;;; if n is 1 or 2 the nth fib. number is 1
;;; if n &gt; 2
;;;    (fib (- n 1)) is the (n-1)th fib. number
;;;    (fib (- n 2)) is the (n-2)th fib. number
;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
(cond [(or (= n 1) (= n 2)) 1]
[else (+ (fib (- n 1))  (fib (- n 2)))]))

What is contrived about this? It precisely follows the definition you outlined.

Now, the iterative version:

if (n &lt;= 2)
{return(1);}
else
f1 = 1;
f2 = 1;
curr = 2;
k = 3;
while (k &lt; n)
{
k = k + 1;
f1 = f2;
f2 = curr;
curr = f1 + f2;
}
return(curr);

That looks contrived to me. All of the sudden we have 5 variables
(i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
recursive version. Furthermore, I have to carefully place my
statements. If the order is changed it will not work.

Cheers,

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> jerzy.karczmarc...@info.unicaen.fr </POSTER>
<POSTDATE> 2008-01-04T10:36:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Yavuz Arkun writes:
&gt; Bill Wood wrote:
&gt;&gt; On Fri, 2008-01-04 at 13:00 +0200, Yavuz Arkun wrote:
&gt;&gt;    . . .

&gt;&gt;&gt; ...IMVHO, there are
&gt;&gt;&gt; only three subjects that can interest a young student: sex, video games
&gt;&gt;&gt; and programming tools. Putting the first two aside for PC, an example
&gt;&gt;&gt; about an text editor would be much more interesting than, say,
&gt;&gt;&gt; Fibonacci.

&gt;&gt; Careful with that.  I was entranced with numbers as early as the third
&gt;&gt; grade, and I had friends all the way through school who were also.
&gt;&gt;  -- Bill Wood
&gt; Yes, I agree that mathematics is interesting for some people, including
&gt; me. However, I took the OP to mean that there is a large chunk (majority?
&gt; sizable minority? undesirably large in any case) of the student body who
&gt; are unable to understand recursion as it is usually covered. For them,
&gt; something else needs to be done (other then giving up teaching recursion.)

&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt; were told they are generated by &quot;start with 1, 1, and then add the last 2
&gt; together to get the next one...&quot;, e.g. iteratively. For me the recursive
&gt; definition is contrived, and I saw it for the first time in intro
&gt; programming books. I guess this shows that prior teaching of iterative
&gt; style kills some neurons forever.

&gt; Anyway, probably everyone has their favorite example/exercise style. Mine
&gt; happens to be programming tools. My ideal introductory programming text
&gt; would be built around an extended series of examples/exercises that
&gt; construct increasingly complete instances of a tool, say a text editor, or
&gt; even a compiler, that leads to a simple, but real-world program. Maybe
&gt; someone could deconstruct Emacs and rebuild it as a teaching exercise? ;)
">

Frankly, it is difficult for me to imagine a more BORING exercise than a
construction of a text editor. There is nothing there, but chores. Emacs is
a complicated machine, not just a text editor. It is an integration of
programming tools extremely heterogeneous, which should be taught separately
even if the possibility of their assembly must be recognized early.

Getting back to the first posting.
I propose that somebody finds a way of teaching recursion through sex.

Or vice-versa.

Jerzy Karczmarczuk

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Jos Koot&quot; &lt;jos.k...@telefonica.net&gt; </POSTER>
<POSTDATE> 2008-01-04T11:00:00 </POSTDATE>
For me the following is the most simple recursive:

(define (make-fib-stream n m)
(cons n (lambda () (make-fib-stream m (+ n m)))))

(define (fib n) ; return n-th fib number
(if (zero? n) 1
(fib-aux n (make-fib-stream 1 1))))

(define (fib-aux n stream)
(if (zero? n) (car stream)
(fib-aux (sub1 n) ((cdr stream)))))

(time (fib 300))
(map fib '(0 1 2 3 4 5 6 7 8 9))

Welcome to DrScheme, version 371.3-svn26oct2007 [3m].
Language: Textual (MzScheme, includes R5RS) custom.
cpu time: 0 real time: 0 gc time: 0
359579325206583560961765665172189099052367214309267232255589801
(1 1 2 3 5 8 13 21 34 55)

<QUOTE PREVIOUSPOST="

">

Jos Koot

<QUOTE PREVIOUSPOST="
----- Original Message -----
From: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;
To: &quot;Yavuz Arkun&quot; &lt;yar ... @gmail.com&gt;

Cc: &lt;plt-sch ... @list.cs.brown.edu&gt;
Sent: Friday, January 04, 2008 3:52 PM
Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
helpwriting function )

&gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt;&gt; iterative style kills some neurons forever.

&gt; ;;; fib: number -&gt; number
&gt; (define (fib n)
&gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt; ;;; if n &gt; 2
&gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt;  (cond [(or (= n 1) (= n 2)) 1]
&gt;           [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt; What is contrived about this? It precisely follows the definition you
&gt; outlined.

&gt; Now, the iterative version:

&gt; if (n &lt;= 2)
&gt;  {return(1);}
&gt; else
&gt;  f1 = 1;
&gt;  f2 = 1;
&gt;  curr = 2;
&gt;  k = 3;
&gt;  while (k &lt; n)
&gt;  {
&gt;    k = k + 1;
&gt;    f1 = f2;
&gt;    f2 = curr;
&gt;    curr = f1 + f2;
&gt;  }
&gt;  return(curr);

&gt; That looks contrived to me. All of the sudden we have 5 variables
&gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
&gt; recursive version. Furthermore, I have to carefully place my
&gt; statements. If the order is changed it will not work.

&gt; Cheers,

&gt; Marco
&gt; _________________________________________________
&gt;  For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">
</POST>
<POST>
<POSTER> &quot;Grant Rettke&quot; &lt;gret...@acm.org&gt; </POSTER>
<POSTDATE> 2008-01-04T11:10:00 </POSTDATE>
On Jan 4, 2008 8:30 AM, Marco Morazan &lt;moraz ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; There is nothing inherently hard about teaching recursion or having
&gt; students understand recursion if it is done right and _before_
&gt; teaching iteration with assignment.
&gt; If students never &quot;learn&quot; that a function calling itself is
&gt; &quot;weird&quot; or &quot;hard to design,&quot; students usually do not get stuck with
&gt; it. The important thing is that students can see that there is a
&gt; structure that a program follows.
">

When I was taught about programming, recursion was taught as something
normal, so I thought it was normal.

There wasn't much of a focus, though, on the concept itself, of
iteration. The focus was more on the &quot;how&quot; rather than the &quot;what&quot;.

--
&quot;Wisdom begins in wonder!&quot;
http://www.wisdomandwonder.com/
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Robby Findler&quot; &lt;ro...@cs.uchicago.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T11:16:00 </POSTDATE>
I think maybe you use the word &quot;simple&quot; in a way different from the
way others are using it here. For you &quot;simple&quot; means &quot;best, clearest
way after you already know everything&quot; not &quot;best clearest way to
present to novices&quot;.

:)

Robby

On Jan 4, 2008 10:00 AM, Jos Koot &lt;jos.k ... @telefonica.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; For me the following is the most simple recursive:

&gt; (define (make-fib-stream n m)
&gt;  (cons n (lambda () (make-fib-stream m (+ n m)))))

&gt; (define (fib n) ; return n-th fib number
&gt;  (if (zero? n) 1
&gt;   (fib-aux n (make-fib-stream 1 1))))

&gt; (define (fib-aux n stream)
&gt;  (if (zero? n) (car stream)
&gt;   (fib-aux (sub1 n) ((cdr stream)))))

&gt; (time (fib 300))
&gt; (map fib '(0 1 2 3 4 5 6 7 8 9))

&gt; Welcome to DrScheme, version 371.3-svn26oct2007 [3m].
&gt; Language: Textual (MzScheme, includes R5RS) custom.
&gt; cpu time: 0 real time: 0 gc time: 0
&gt; 359579325206583560961765665172189099052367214309267232255589801
&gt; (1 1 2 3 5 8 13 21 34 55)

&gt; Jos Koot

&gt; ----- Original Message -----
&gt; From: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;
&gt; To: &quot;Yavuz Arkun&quot; &lt;yar ... @gmail.com&gt;
&gt; Cc: &lt;plt-sch ... @list.cs.brown.edu&gt;
&gt; Sent: Friday, January 04, 2008 3:52 PM
&gt; Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
&gt; helpwriting function )

&gt; &gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt; &gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt; &gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt; &gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt; &gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt; &gt;&gt; iterative style kills some neurons forever.

&gt; &gt; ;;; fib: number -&gt; number
&gt; &gt; (define (fib n)
&gt; &gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt; &gt; ;;; if n &gt; 2
&gt; &gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt; &gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt; &gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt; &gt;  (cond [(or (= n 1) (= n 2)) 1]
&gt; &gt;           [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt; &gt; What is contrived about this? It precisely follows the definition you
&gt; &gt; outlined.

&gt; &gt; Now, the iterative version:

&gt; &gt; if (n &lt;= 2)
&gt; &gt;  {return(1);}
&gt; &gt; else
&gt; &gt;  f1 = 1;
&gt; &gt;  f2 = 1;
&gt; &gt;  curr = 2;
&gt; &gt;  k = 3;
&gt; &gt;  while (k &lt; n)
&gt; &gt;  {
&gt; &gt;    k = k + 1;
&gt; &gt;    f1 = f2;
&gt; &gt;    f2 = curr;
&gt; &gt;    curr = f1 + f2;
&gt; &gt;  }
&gt; &gt;  return(curr);

&gt; &gt; That looks contrived to me. All of the sudden we have 5 variables
&gt; &gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
&gt; &gt; recursive version. Furthermore, I have to carefully place my
&gt; &gt; statements. If the order is changed it will not work.

&gt; &gt; Cheers,

&gt; &gt; Marco
&gt; &gt; _________________________________________________
&gt; &gt;  For list-related administrative tasks:
&gt; &gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

&gt; _________________________________________________
&gt;   For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Jos Koot&quot; &lt;jos.k...@telefonica.net&gt; </POSTER>
<POSTDATE> 2008-01-04T11:40:00 </POSTDATE>
Your remark about 'simple' is right, of course. My conclusion is that an
example as the Fibonacci numbers (or binomials) should not be the first one.
The Little Schemer/LISPer introduces streams very naturally in the exercises
of Chapter 9 (out of 10) and then uses streams for a very beautiful example
of recursion: (define P ...) (define Q ...) (No I am not going to tell what
P and Q do, for it's an exercise :)

The procedure

(define (fib n)
(cond [(or (= n 1) (= n 2)) 1]
[else (+ (fib (- n 1))  (fib (- n 2)))]))

is a  horrible example of recursion considering the number of recursive
calls needed and the number of duplicated computations. That's why I could
not withstand posting my example. :)
Jos

<QUOTE PREVIOUSPOST="
----- Original Message -----
From: &quot;Robby Findler&quot; &lt;ro ... @cs.uchicago.edu&gt;
To: &quot;Jos Koot&quot; &lt;jos.k ... @telefonica.net&gt;

Cc: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;; &quot;Yavuz Arkun&quot; &lt;yar ... @gmail.com&gt;;
&lt;plt-sch ... @list.cs.brown.edu&gt;
Sent: Friday, January 04, 2008 5:16 PM
Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
helpwriting function )

&gt;I think maybe you use the word &quot;simple&quot; in a way different from the
&gt; way others are using it here. For you &quot;simple&quot; means &quot;best, clearest
&gt; way after you already know everything&quot; not &quot;best clearest way to
&gt; present to novices&quot;.

&gt; :)

&gt; Robby

&gt; On Jan 4, 2008 10:00 AM, Jos Koot &lt;jos.k ... @telefonica.net&gt; wrote:
&gt;&gt; For me the following is the most simple recursive:

&gt;&gt; (define (make-fib-stream n m)
&gt;&gt;  (cons n (lambda () (make-fib-stream m (+ n m)))))

&gt;&gt; (define (fib n) ; return n-th fib number
&gt;&gt;  (if (zero? n) 1
&gt;&gt;   (fib-aux n (make-fib-stream 1 1))))

&gt;&gt; (define (fib-aux n stream)
&gt;&gt;  (if (zero? n) (car stream)
&gt;&gt;   (fib-aux (sub1 n) ((cdr stream)))))

&gt;&gt; (time (fib 300))
&gt;&gt; (map fib '(0 1 2 3 4 5 6 7 8 9))

&gt;&gt; Welcome to DrScheme, version 371.3-svn26oct2007 [3m].
&gt;&gt; Language: Textual (MzScheme, includes R5RS) custom.
&gt;&gt; cpu time: 0 real time: 0 gc time: 0
&gt;&gt; 359579325206583560961765665172189099052367214309267232255589801
&gt;&gt; (1 1 2 3 5 8 13 21 34 55)

&gt;&gt; Jos Koot

&gt;&gt; ----- Original Message -----
&gt;&gt; From: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;
&gt;&gt; To: &quot;Yavuz Arkun&quot; &lt;yar ... @gmail.com&gt;
&gt;&gt; Cc: &lt;plt-sch ... @list.cs.brown.edu&gt;
&gt;&gt; Sent: Friday, January 04, 2008 3:52 PM
&gt;&gt; Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
&gt;&gt; helpwriting function )

&gt;&gt; &gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt;&gt; &gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the
&gt;&gt; &gt;&gt; last
&gt;&gt; &gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt;&gt; &gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt;&gt; &gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt;&gt; &gt;&gt; iterative style kills some neurons forever.

&gt;&gt; &gt; ;;; fib: number -&gt; number
&gt;&gt; &gt; (define (fib n)
&gt;&gt; &gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt;&gt; &gt; ;;; if n &gt; 2
&gt;&gt; &gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt;&gt; &gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt;&gt; &gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt;&gt; &gt;  (cond [(or (= n 1) (= n 2)) 1]
&gt;&gt; &gt;           [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt;&gt; &gt; What is contrived about this? It precisely follows the definition you
&gt;&gt; &gt; outlined.

&gt;&gt; &gt; Now, the iterative version:

&gt;&gt; &gt; if (n &lt;= 2)
&gt;&gt; &gt;  {return(1);}
&gt;&gt; &gt; else
&gt;&gt; &gt;  f1 = 1;
&gt;&gt; &gt;  f2 = 1;
&gt;&gt; &gt;  curr = 2;
&gt;&gt; &gt;  k = 3;
&gt;&gt; &gt;  while (k &lt; n)
&gt;&gt; &gt;  {
&gt;&gt; &gt;    k = k + 1;
&gt;&gt; &gt;    f1 = f2;
&gt;&gt; &gt;    f2 = curr;
&gt;&gt; &gt;    curr = f1 + f2;
&gt;&gt; &gt;  }
&gt;&gt; &gt;  return(curr);

&gt;&gt; &gt; That looks contrived to me. All of the sudden we have 5 variables
&gt;&gt; &gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
&gt;&gt; &gt; recursive version. Furthermore, I have to carefully place my
&gt;&gt; &gt; statements. If the order is changed it will not work.

&gt;&gt; &gt; Cheers,

&gt;&gt; &gt; Marco
&gt;&gt; &gt; _________________________________________________
&gt;&gt; &gt;  For list-related administrative tasks:
&gt;&gt; &gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

&gt;&gt; _________________________________________________
&gt;&gt;   For list-related administrative tasks:
&gt;&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T11:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; The procedure

&gt;  (define (fib n)
&gt;     (cond [(or (= n 1) (= n 2)) 1]
&gt;          [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt; is a  horrible example of recursion considering the number of recursive
&gt; calls needed and the number of duplicated computations. That's why I could
&gt; not withstand posting my example. :)
">

Well, &quot;horrible&quot; means different things in different contexts. My
posting was addressing the claim that the recursive definition is
&quot;contrived.&quot; No claim was made that this is the best or most efficient
way of computing fib numbers. Issues of efficiency need to be studied,
but not while getting your first exposure to recursion.

The naive definition above is elegant, not contrived, and something
inexperienced students can understand. I would certainly not use
streams and fib numbers to teach recursion to those who are seeing it
for the first time.

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Grant Rettke&quot; &lt;gret...@acm.org&gt; </POSTER>
<POSTDATE> 2008-01-04T12:00:00 </POSTDATE>
On Jan 4, 2008 10:56 AM, Marco Morazan &lt;moraz ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; The naive definition above is elegant, not contrived, and something
&gt; inexperienced students can understand.
">

Is it true that once students get the &quot;what&quot; of recursion, they will
immediately understand the &quot;how&quot;?
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T12:07:00 </POSTDATE>
On Jan 4, 2008 12:00 PM, Grant Rettke &lt;gret ... @acm.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Jan 4, 2008 10:56 AM, Marco Morazan &lt;moraz ... @gmail.com&gt; wrote:
&gt; &gt; The naive definition above is elegant, not contrived, and something
&gt; &gt; inexperienced students can understand.

&gt; Is it true that once students get the &quot;what&quot; of recursion, they will
&gt; immediately understand the &quot;how&quot;?
">

Immediately? No IMHO. It takes time to digest and lots of practice. At
the beginning, following the structure of the data provides a context
for understanding. Once experience leads to an understanding of
structural recursion, students have a base to move onto tail- and
generative-recursion. For example, you really need to have some
understanding about recursion to understand quicksort.

Cheers,

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Jos Koot&quot; &lt;jos.k...@telefonica.net&gt; </POSTER>
<POSTDATE> 2008-01-04T12:18:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
----- Original Message -----
From: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;
To: &quot;Jos Koot&quot; &lt;jos.k ... @telefonica.net&gt;

Cc: &quot;Robby Findler&quot; &lt;ro ... @cs.uchicago.edu&gt;; &quot;Yavuz Arkun&quot;
&lt;yar ... @gmail.com&gt;; &lt;plt-sch ... @list.cs.brown.edu&gt;
Sent: Friday, January 04, 2008 5:56 PM
Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
helpwriting function )

&gt;&gt; The procedure

&gt;&gt;  (define (fib n)
&gt;&gt;     (cond [(or (= n 1) (= n 2)) 1]
&gt;&gt;          [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt;&gt; is a  horrible example of recursion considering the number of recursive
&gt;&gt; calls needed and the number of duplicated computations. That's why I
&gt;&gt; could
&gt;&gt; not withstand posting my example. :)

&gt; Well, &quot;horrible&quot; means different things in different contexts. My
&gt; posting was addressing the claim that the recursive definition is
&gt; &quot;contrived.&quot; No claim was made that this is the best or most efficient
&gt; way of computing fib numbers.

Ok, it was certainly not my intention to offend you. If you felt offended,
accept my appologies please

&gt; Issues of efficiency need to be studied,
&gt; but not while getting your first exposure to recursion.

That is correct. Nevertheless it seems not right to me to present the
example to novices. They could be tempted to acquire a habbit of thoughtless
application of recursion. Starting with lists and (later) trees and showing
the connection between data structure and program structure, seems a better
approach to me (as in HtDP and The Little Schemer) Then after a feeling of
the flow of evaluation, more complicated examples can come in. Just MHO.
Jos

&gt; The naive definition above is elegant, not contrived, and something
&gt; inexperienced students can understand. I would certainly not use
&gt; streams and fib numbers to teach recursion to those who are seeing it
&gt; for the first time.

Agreed. I already made a remark to the same extent in my earlier posting.
Jos

&gt; Marco

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">
</POST>
<POST>
<POSTER> Bill Wood &lt;william.wo...@comcast.net&gt; </POSTER>
<POSTDATE> 2008-01-04T12:29:00 </POSTDATE>
On Fri, 2008-01-04 at 16:36 +0100, jerzy.karczmarc ... @info.unicaen.fr
. . .

<QUOTE PREVIOUSPOST="
&gt; Getting back to the first posting.
&gt; I propose that somebody finds a way of teaching recursion through sex.

&gt; Or vice-versa.
">

A text on recursion theory that would be banned in Boston?  Hmmm ... .
Better not mention category theory -- get to the chapter on functors and
it's all over.

-- Bill Wood

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Todd O&#39;Bryan&quot; &lt;toddobr...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T12:52:00 </POSTDATE>
I think the key is to teach structural recursion before generative
recursion, as HtDP does. Interestingly, Bruce, Danyluk, and Murtagh
(2005) [1] make the point that teaching structural recursion before
arrays is helpful in an objects-early approach and cite HtDP. Other
papers [2] cite Bruce, but don't mention HtDP, when I think it's clear
that the PLT group can easily lay claim to being in the forefront of
this pedagogical insight.

Todd

[1]: http://www.google.com/url?sa=t&amp;ct;=res&amp;cd;=3&amp;url;=http%3A%2F%2Fwww.cs.wi...
[2]: http://72.14.205.104/search?q=cache:VEuO5_d2C-MJ:dehn.slu.edu/researc...
(this paper is only available in a cached version, but appears to have
been published in OOPSLA 2007)
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T13:41:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Marco Morazan wrote:
&gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt;&gt; iterative style kills some neurons forever.

&gt; ;;; fib: number -&gt; number
&gt; (define (fib n)
&gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt; ;;; if n &gt; 2
&gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt;   (cond [(or (= n 1) (= n 2)) 1]
&gt;            [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt; What is contrived about this? It precisely follows the definition you outlined.

&gt; Now, the iterative version:

&gt; if (n &lt;= 2)
&gt;   {return(1);}
&gt; else
&gt;   f1 = 1;
&gt;   f2 = 1;
&gt;   curr = 2;
&gt;   k = 3;
&gt;   while (k &lt; n)
&gt;   {
&gt;     k = k + 1;
&gt;     f1 = f2;
&gt;     f2 = curr;
&gt;     curr = f1 + f2;
&gt;   }
&gt;   return(curr);

&gt; That looks contrived to me. All of the sudden we have 5 variables
&gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
&gt; recursive version. Furthermore, I have to carefully place my
&gt; statements. If the order is changed it will not work.

&gt; Cheers,

&gt; Marco
">

The iterative model I had in mind was something more like:

int fib(N) {
int i, a[2] = {1, 1};
for(i= 3; i &lt;= N; i++) a[i % 2] += a[(i + 1) % 2];
return a[N % 2];

<QUOTE PREVIOUSPOST="
}
">

You are right that there are at least 4 explicit variables in iterative
versions, since you need to keep track of the limit, current iteration
and 2 members. To balance, there are no implicit values that need to be
passed around.

The number of explicit variables in the recursive version is deceptive.
When I am trying to understand a program, I put myself in the place of
the computer and work through the program in my mind. For the iterative
version, everything I need to remember are explicitly named. For
recursive algorithms, I need to keep track of the implicit variables as
well, such as how deep I am into the recursion, and what the
intermediate values are, because I will need them on my way back.

Personally, I can manage 1 or 2 levels mentally, and if I use pen and
paper maybe a few more. After that, I need to take a leap of faith, and
inductively conclude that if it works for the simplest case, and for the
one after that, it should work for all cases.

In other words, neither the conciseness of the program text, nor the
elegance of the expressed ideas necessarily means &quot;easy to understand&quot;,
unless you are prepared to take the leap.

I can do that, because I know recursion works as a general concept. It
may be more difficult if you are new to the idea. Even more so, when you
realize that the 'elegant' method can have rather inelegant space and/or
time characteristics. Then you start to feel like you must be missing
something and become frustrated.

Therefore, recursion (like any other method) should be illustrated using
examples that can be best solved with recursion.

Yavuz
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> jerzy.karczmarc...@info.unicaen.fr </POSTER>
<POSTDATE> 2008-01-04T14:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Yavuz Arkun writes:
&gt; When I am trying to understand a program, I put myself in the place of the
&gt; computer and work through the program in my mind.
">

Sorry to be a bit nasty once more, but this attitude - even if it works
for you - should be absolutely screened from students, especially newbies.
They should grasp the meaning, and if it can be done in a stateless, static
way, the better. Your technique is pedagogically murderous! My goodness,
squeezing students heads into computers...
And what do you mean by that?: assembler? Surely you don't reduce yourself
to the dataflow of binary impulses through electronic gates! At what level
you *should* stop??

<QUOTE PREVIOUSPOST="
&gt; Therefore, recursion (like any other method) should be illustrated using
&gt; examples that can be best solved with recursion.
">

Yessir. And there are plenty of.
Not necessarily linear. I had a programming course to high-school pupils
(not in school, but a club, so they were all specifically motivated), and
I had no real problems.

* Towers of Hanoi/Benares. Try to do it iteratively.
* Generation of all permutations. The same comment.

Notice that the first and the second example are very different, the first
reduces, the second extrapolates, moreover needs such data as lists, but
this is OK.

* Quicksort.
* Generating of some functions known to them, such as sin(x) through the
triplication algorithm.
* Power x^n through the binary splitting of the exponent.

==
The point is, my dear fellows, NOT the teaching of those concepts to
newbies. The problem is with convincing their teachers to do it early, and
this should begin with putting more brains into heads of people who teach
teachers!

I have still around me some physicists who feel entitled to teach
programming to physics students (and who do it), and who shrug, saying that
comp. sci. teachers nearby are useless, since they teach such stupidities
as recursion, without any relation to real physics examples.
But I ask usually then how do they teach Fast Fourier, and we have a good
laugh.

Jerzy Karczmarczuk

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Matthias Felleisen &lt;matth...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T14:15:00 </POSTDATE>
On Jan 4, 2008, at 12:52 PM, Todd O'Bryan wrote:

<QUOTE PREVIOUSPOST="
&gt; I think the key is to teach structural recursion before generative
&gt; recursion, as HtDP does.
">

Thanks for the message.

<QUOTE PREVIOUSPOST="
&gt; Interestingly, Bruce, Danyluk, and Murtagh
&gt; (2005) [1] make the point that teaching structural recursion before
&gt; arrays is helpful in an objects-early approach and cite HtDP. Other
&gt; papers [2] cite Bruce, but don't mention HtDP, when I think it's clear
&gt; that the PLT group can easily lay claim to being in the forefront of
&gt; this pedagogical insight.
">

That's not surprising. The CS education community has proven less
research-oriented and less scholarly than the already no so great CS
community. (And no, I am not asking for perfection, just academic
credit, which is what academics live from.)

-- Matthias

<QUOTE PREVIOUSPOST="
&gt; Todd

&gt; [1]: http://www.google.com/url?sa=t&amp;ct;=res&amp;cd;=3&amp;url;=http%3A%2F%
&gt; 2F www.cs.williams.edu%2F~andrea%2FPublications%2Fp266-
&gt; bruce.pdf&amp;ei=LHB-
&gt; R__iA6KShALtpLw1&amp;usg=AFQjCNE6z4oJu6aW2zTTICjWetE1Y0jaDw&amp;sig2=qKl8qsKqK
&gt; vtLKNNp1Ze9fg
&gt; [2]: http://72.14.205.104/search?q=cache:VEuO5_d2C-MJ:dehn.slu.edu/
&gt; research/papers/recursion.pdf+Kim+Bruce+structural
&gt; +recursion&amp;hl=en&amp;ct=clnk&amp;cd=7&amp;gl=us&amp;client=firefox-a
&gt; (this paper is only available in a cached version, but appears to have
&gt; been published in OOPSLA 2007)
&gt; _________________________________________________
&gt;   For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Robby Findler&quot; &lt;ro...@cs.uchicago.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T14:21:00 </POSTDATE>
On Jan 4, 2008 12:41 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Marco Morazan wrote:
&gt; &gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt; &gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt; &gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt; &gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt; &gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt; &gt;&gt; iterative style kills some neurons forever.

&gt; &gt; ;;; fib: number -&gt; number
&gt; &gt; (define (fib n)
&gt; &gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt; &gt; ;;; if n &gt; 2
&gt; &gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt; &gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt; &gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt; &gt;   (cond [(or (= n 1) (= n 2)) 1]
&gt; &gt;            [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt; &gt; What is contrived about this? It precisely follows the definition you outlined.

&gt; &gt; Now, the iterative version:

&gt; &gt; if (n &lt;= 2)
&gt; &gt;   {return(1);}
&gt; &gt; else
&gt; &gt;   f1 = 1;
&gt; &gt;   f2 = 1;
&gt; &gt;   curr = 2;
&gt; &gt;   k = 3;
&gt; &gt;   while (k &lt; n)
&gt; &gt;   {
&gt; &gt;     k = k + 1;
&gt; &gt;     f1 = f2;
&gt; &gt;     f2 = curr;
&gt; &gt;     curr = f1 + f2;
&gt; &gt;   }
&gt; &gt;   return(curr);

&gt; &gt; That looks contrived to me. All of the sudden we have 5 variables
&gt; &gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in the
&gt; &gt; recursive version. Furthermore, I have to carefully place my
&gt; &gt; statements. If the order is changed it will not work.

&gt; &gt; Cheers,

&gt; &gt; Marco

&gt; The iterative model I had in mind was something more like:

&gt; int fib(N) {
&gt;     int i, a[2] = {1, 1};
&gt;     for(i= 3; i &lt;= N; i++) a[i % 2] += a[(i + 1) % 2];
&gt;     return a[N % 2];
&gt; }
">

And yet your English text suggests this definition:

fib(0)=1
fib(1)=1
fib(n+2) = fib(n) + fib(n+1)

which, I believe, is even executable code in some programming language
or other (not that that's particular relevant, tho).

As far as the mental model of the computer that you seem to work with
(below), I am amazed at your ability to burrow through (a couple)
abstractions. I'm remarkably bad at that, myself. But lets not forget
that the purpose of abstractions to let people build bigger and bigger
things on top of them and, to that end, it is important to make them
seamless and then rely on that. Esp. for novices.

Robby

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; You are right that there are at least 4 explicit variables in iterative
&gt; versions, since you need to keep track of the limit, current iteration
&gt; and 2 members. To balance, there are no implicit values that need to be
&gt; passed around.

&gt; The number of explicit variables in the recursive version is deceptive.
&gt; When I am trying to understand a program, I put myself in the place of
&gt; the computer and work through the program in my mind. For the iterative
&gt; version, everything I need to remember are explicitly named. For
&gt; recursive algorithms, I need to keep track of the implicit variables as
&gt; well, such as how deep I am into the recursion, and what the
&gt; intermediate values are, because I will need them on my way back.

&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen and
&gt; paper maybe a few more. After that, I need to take a leap of faith, and
&gt; inductively conclude that if it works for the simplest case, and for the
&gt; one after that, it should work for all cases.

&gt; In other words, neither the conciseness of the program text, nor the
&gt; elegance of the expressed ideas necessarily means &quot;easy to understand&quot;,
&gt; unless you are prepared to take the leap.

&gt; I can do that, because I know recursion works as a general concept. It
&gt; may be more difficult if you are new to the idea. Even more so, when you
&gt; realize that the 'elegant' method can have rather inelegant space and/or
&gt; time characteristics. Then you start to feel like you must be missing
&gt; something and become frustrated.

&gt; Therefore, recursion (like any other method) should be illustrated using
&gt; examples that can be best solved with recursion.

&gt; Yavuz

&gt; _________________________________________________
&gt;   For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Phil Rand&quot; &lt;philr...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T14:36:00 </POSTDATE>
On Jan 4, 2008 11:15 AM,  &lt;jerzy.karczmarc ... @info.unicaen.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Yavuz Arkun writes:

&gt; &gt; When I am trying to understand a program, I put myself in the place of the
&gt; &gt; computer and work through the program in my mind.

&gt; Sorry to be a bit nasty once more, but this attitude - even if it works
&gt; for you - should be absolutely screened from students, especially newbies.
&gt; They should grasp the meaning, and if it can be done in a stateless, static
&gt; way, the better. Your technique is pedagogically murderous! My goodness,
&gt; squeezing students heads into computers...
">

Yes.  If I recall correctly, my first serious exposure to recursion
was in a data-structures class taught in C.  I remember getting
hopelessly tangled up in how the recursion would be implemented --
stacks, activation records, local variables, etc.  It was much later,
while reading The Little Lisper, that I learned to relax and not worry
about the fact that the functions I was calling recursively happened
to have the same name as the function I was defining.  Of course
there's less to worry about when doing this in scheme and avoiding
assignment.

--
Phil Rand
philr ... @pobox.com
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Matthias Felleisen &lt;matth...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T15:28:00 </POSTDATE>
On Jan 4, 2008, at 1:41 PM, Yavuz Arkun wrote:

<QUOTE PREVIOUSPOST="
&gt; The number of explicit variables in the recursive version is
&gt; deceptive. When I am trying to understand a program, I put myself
&gt; in the place of the computer and work through the program in my
&gt; mind. For the iterative version, everything I need to remember are
&gt; explicitly named. For recursive algorithms, I need to keep track of
&gt; the implicit variables as well, such as how deep I am into the
&gt; recursion, and what the intermediate values are, because I will
&gt; need them on my way back.

&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen
&gt; and paper maybe a few more. After that, I need to take a leap of
&gt; faith, and inductively conclude that if it works for the simplest
&gt; case, and for the one after that, it should work for all cases.

&gt; In other words, neither the conciseness of the program text, nor
&gt; the elegance of the expressed ideas necessarily means &quot;easy to
&gt; understand&quot;, unless you are prepared to take the leap.

&gt; I can do that, because I know recursion works as a general concept.
&gt; It may be more difficult if you are new to the idea. Even more so,
&gt; when you realize that the 'elegant' method can have rather
&gt; inelegant space and/or time characteristics. Then you start to feel
&gt; like you must be missing something and become frustrated.

&gt; Therefore, recursion (like any other method) should be illustrated
&gt; using examples that can be best solved with recursion.
">

Please do take a look at HtDP. Your message suggests that you were
trained by or as an EE :-)

-- Matthias

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T15:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Robby Findler wrote:
&gt; On Jan 4, 2008 12:41 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

&gt;&gt; Marco Morazan wrote:

&gt;&gt;&gt;&gt; BTW, I first learned about the Fibonacci series in high school, and we
&gt;&gt;&gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the last
&gt;&gt;&gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt;&gt;&gt;&gt; recursive definition is contrived, and I saw it for the first time in
&gt;&gt;&gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt;&gt;&gt;&gt; iterative style kills some neurons forever.

&gt;&gt; The iterative model I had in mind was something more like:

&gt;&gt; int fib(N) {
&gt;&gt;     int i, a[2] = {1, 1};
&gt;&gt;     for(i= 3; i &lt;= N; i++) a[i % 2] += a[(i + 1) % 2];
&gt;&gt;     return a[N % 2];
&gt;&gt; }

&gt; And yet your English text suggests this definition:

&gt;  fib(0)=1
&gt;  fib(1)=1
&gt;  fib(n+2) = fib(n) + fib(n+1)

&gt; which, I believe, is even executable code in some programming language
&gt; or other (not that that's particular relevant, tho).
">

Well, my English text had the &quot;...&quot; which in my mind was the explicit
loop. The mathematical version you gave makes that an implicit one. I
believe my C version is closer to the English text's spirit because its
formulated as an explicit iteration. What may be confusing in the C
version is the use of % operator to translate the &quot;last 2&quot; into C code.
(BTW, I am no C expert...I am sure it can be written more idiomatically.)

<QUOTE PREVIOUSPOST="
&gt; As far as the mental model of the computer that you seem to work with
&gt; (below), I am amazed at your ability to burrow through (a couple)
&gt; abstractions. I'm remarkably bad at that, myself. But lets not forget
&gt; that the purpose of abstractions to let people build bigger and bigger
&gt; things on top of them and, to that end, it is important to make them
&gt; seamless and then rely on that. Esp. for novices.

&gt; Robby
">

I didn't mean that I can go down 2 levels in terms of abstraction (e.g.,
Scheme code -&gt; Scheme interpreter -&gt; assembly operations). I mean that I
can follow through only a few recursive calls of Fibonacci before
forgetting where I was. My little brain hurts already.

Yavuz
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T16:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; The number of explicit variables in the recursive version is deceptive.
&gt; When I am trying to understand a program, I put myself in the place of
&gt; the computer and work through the program in my mind. For the iterative
&gt; version, everything I need to remember are explicitly named. For
&gt; recursive algorithms, I need to keep track of the implicit variables as
&gt; well, such as how deep I am into the recursion, and what the
&gt; intermediate values are, because I will need them on my way back.
">

Gee whiz.....this seems like a terribly painful way to try to
understand a program. In fact, I would discourage such a low-level of
abstraction to explain recursion to new students. If someone needs to
think about what is &quot;remembered&quot; on a stack, then chances are they do
not really understand the recursive program they have written (or
trying to write). I certainly do not tell my fresnmen students that
values are remembered by the computer on a stack.

<QUOTE PREVIOUSPOST="
&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen and
&gt; paper maybe a few more. After that, I need to take a leap of faith, and
&gt; inductively conclude that if it works for the simplest case, and for the
&gt; one after that, it should work for all cases.
">

Why do you describe it as a leap of faith? Let me ask, what requires a
bigger &quot;leap of faith&quot; that new students can understand what a base
case and an inductive step are or that they can develop the skills to
manually trace values being stored on a stack to implement recursive
calls? The whole point is to _not_ think in terms of values being
pushed onto a stack! To this one person, that is just too hard.

It seems to me that there is a great deal about abstraction that you
are &quot;sweeping under the rug.&quot;

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Robby Findler&quot; &lt;ro...@cs.uchicago.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T16:45:00 </POSTDATE>
On Jan 4, 2008 2:43 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I didn't mean that I can go down 2 levels in terms of abstraction (e.g.,
&gt; Scheme code -&gt; Scheme interpreter -&gt; assembly operations). I mean that I
&gt; can follow through only a few recursive calls of Fibonacci before
&gt; forgetting where I was. My little brain hurts already.
">

:)

Here's a way to think about it without having to think about stacks or
loops or pushing or popping or cells or anything like that. Just go
back to grade-school algebra. Plug 'n Chug, as they called it when I
was in school (maybe more recently than many here... but getting
surprisingly distant when I think back one it ...):

definition:
fib(0)=1
fib(1)=1
fib(n+2) = fib(n) + fib(n+1)

example use:

fib(4)
=  ;; by last case in the definition, with n=2
fib(2) + fib (3)

-- lets put that on hold, and compute fib(2) and then come back to it.

fib(2)
= ;; by the last case in the definition, with n=0
fib(0) + fib(1)
= ;; by the first two cases in the definition
1 + 1
=
2

--- coming back to the main computation:

fib(4)
=
fib(2) + fib(3)
= ;; by our factored out computation
2 + fib(3)
= ;; by the last case in the definition, with n=1
2 + fib(1) + fib(2)
= ;; by the second case in the definition
2 + 1 + fib(2)
= ;; by out factored out computation
2 + 1 + 2
=
5

So, you might say to me &quot;but that's just the mathematical way of
thinking, not how computation works&quot; but I would say that stepwise
refinement like that is the essence of how computation works. I took a
shortcut and re-used work in a way that a computer would probably not
figure out how to do (altho I wouldn't be surprised if there have been
optimizations proposed that would discover how to turn the very
expensive fib I wrote above into a fib that used two accumulators) but
that doesn't matter: those are valid steps of reasoning and they have
all been proven to be sound ways of thinking wrt to naive ordering
that most implementations do.

Even better: you can see this in action yourself, if you were to type
in the Scheme version of the definition above and then try it in the
stepper. Here's a screenshot, showing a random step in the middle of
the reduction sequence:

http://people.cs.uchicago.edu/~robby/tmp/fib-stepper.png

Robby
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T17:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Marco Morazan wrote:
&gt;&gt; The number of explicit variables in the recursive version is deceptive.
&gt;&gt; When I am trying to understand a program, I put myself in the place of
&gt;&gt; the computer and work through the program in my mind. For the iterative
&gt;&gt; version, everything I need to remember are explicitly named. For
&gt;&gt; recursive algorithms, I need to keep track of the implicit variables as
&gt;&gt; well, such as how deep I am into the recursion, and what the
&gt;&gt; intermediate values are, because I will need them on my way back.

&gt; Gee whiz.....this seems like a terribly painful way to try to
&gt; understand a program. In fact, I would discourage such a low-level of
&gt; abstraction to explain recursion to new students. If someone needs to
&gt; think about what is &quot;remembered&quot; on a stack, then chances are they do
&gt; not really understand the recursive program they have written (or
&gt; trying to write). I certainly do not tell my fresnmen students that

&gt; values are remembered by the computer on a stack.
">

Heh, I didn't say anything about stacks or assembly level thinking, but
everyone thinks that I meant that. (I wonder if that reveals anything
about the phobias of CS academics...hmm.)

In this case the &quot;computer&quot; that I am emulating is like the stepper that
Robby linked a few post back, i.e. works in terms of scheme functions,
variables etc. And as you calculate the fibonacci recursively, you do
need to keep track of where you are and what the passed actual parameter
values are, as shown nicely  in the same post using a pen-and-paper
approach.

<QUOTE PREVIOUSPOST="
&gt;&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen and
&gt;&gt; paper maybe a few more. After that, I need to take a leap of faith, and
&gt;&gt; inductively conclude that if it works for the simplest case, and for the
&gt;&gt; one after that, it should work for all cases.

&gt; Why do you describe it as a leap of faith? Let me ask, what requires a
&gt; bigger &quot;leap of faith&quot; that new students can understand what a base
&gt; case and an inductive step are or that they can develop the skills to
&gt; manually trace values being stored on a stack to implement recursive
&gt; calls? The whole point is to _not_ think in terms of values being
&gt; pushed onto a stack! To this one person, that is just too hard.
">

Again, no stack, just the need to track of the values of the actual
parameters. And, yes, it is not difficult to learn at the end, as
millions of programmers have. The OP was about why recursion is
difficult to teach. Since as a (virtual) student I cannot answer to
that, I contributed my personal view about why it is difficult to learn.
It is (minimally) difficult to grasp at first because it requires the
inductive leap, whereas the iterative versions do not.

Drawing on the students' prior exposure to mathematical induction could
help understanding, of course, but shouldn't come at the cost of ending
up with obviously inefficient code, because that would unfairly
associate &quot;recursion&quot; with &quot;inefficiency&quot; in students' minds.

Yavuz

<QUOTE PREVIOUSPOST="
&gt; It seems to me that there is a great deal about abstraction that you
&gt; are &quot;sweeping under the rug.&quot;

&gt; Marco
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Yavuz Arkun &lt;yar...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T18:09:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Matt Jadud wrote:
&gt; On Jan 4, 2008 5:24 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

&gt;&gt; Heh, I didn't say anything about stacks or assembly level thinking, but
&gt;&gt; everyone thinks that I meant that. (I wonder if that reveals anything
&gt;&gt; about the phobias of CS academics...hmm.)

&gt; [snip]

&gt;&gt; Drawing on the students' prior exposure to mathematical induction could
&gt;&gt; help understanding, of course, but shouldn't come at the cost of ending
&gt;&gt; up with obviously inefficient code, because that would unfairly
&gt;&gt; associate &quot;recursion&quot; with &quot;inefficiency&quot; in students' minds.

&gt;&gt; Yavuz

&gt; Hi Yavuz,

&gt; What is your particular experience with teaching computing? You seem
&gt; to have a lot of insights about computing academics and students in
&gt; this context---where are you from? What do you teach?

&gt; Cheers,
&gt; Matt
">

I gave my background a few posts back.  I am not a teacher. You could
say that I have been at the receiving end a lot though. I thought that
people who are teachers might be interested in what someone who is
(re)learning some of these concepts these very days is thinking. After
all, when you design a product, even if it is a product that you
yourself use, you are supposed to go to a sample of consumers and ask
them what they think.

As for the &quot;insights&quot; about academics, maybe I am a bit biased because
the bits that I have been exposed to do not have much in common with the
&quot;science&quot; part of CS. As far as I am concerned, Computer Science should
have been called Programming Engineering. (As I am an relapsed engineer
myself, this is not intended as slur.)

I am sorry if you feel that I am speaking out of turn.

Yavuz
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Joe Marshall&quot; &lt;jmarsh...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2008-01-04T18:10:00 </POSTDATE>
On Jan 3, 2008 9:11 PM, Grant Rettke &lt;gret ... @acm.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; This thread had mentioned helping students understand recursion, and
&gt; for some reason, this topic of understanding recursion has come up a
&gt; lot lately &quot;by the water cooler&quot;, among other things.

&gt; I recently heard that a particular teacher quit trying to teach
&gt; recursion because &quot;it is too hard for students to understand&quot;.
">

Programming is hard.  Let's not bother teaching it.

----
A few years back on comp.lang.lisp someone was working on this problem:

First challenge:
; Call fun for each subsets of 0, 2, ..., n-1 of length k with the following
; constraint: let p be an &quot;ordered&quot; partition of n, eg. (3,2,4,1) |- 10.  If x
; is a chosen number, then it is required that all numbers in the same part of
; the partition smaller than x are chosen, too.

; it may be easier to think of p as a vector where all elements within one
; &quot;part&quot; given by the partition are the same.

; eg: for n=10, k=4, p=(3,2,4,1)==(0,0,0,1,1,2,2,2,2,3)
; (0,1,2,3), (0,1,3,5), (3,5,6,7) are all allowed (there are a lot more...)
; (1,2,3,4), (0,1,4,5) are forbidden

The poster had attempted to write an iterative solution (included below)
that was a true dogs breakfast of arrays, pointer smashing, looping,
modifying index variables, etc.  It didn't work, either.

The recursive solution is 7 lines long (plus an auxiliary function
of 1 line).

Here is the iterative (non-working) version:

(defun strange-combinations (n k l fun vec &amp;optional debug)
(and debug (print (list 'strange-combinations n k l vec)))
(let ((level -1))
(labels ((swap (i j)
(and debug (format T &quot;~%swapping ~A and ~A: &quot; i j))
(rotatef (aref vec (1- i)) (aref vec (1- j)))
(funcall fun))
(init (n k)
(and debug (format T &quot;~%initialise ~A, ~A:  &quot; n k))
(fill vec 1 :start 0 :end k)
(fill vec 0 :start k :end n))
(gen (n k l)
;      (1 . . . . 1 0 . . 0 | 0 . . . . . . 0)
; bzw. (1 . . . . . . . . 1 | 1 . . 1 0 . . 0)
;
;  -&gt;  (1 . . 1 0 . . . . 0 | 1 . . . . . . 1)
; bzw. (0 . . . . . . . . 0 | 1 . . 1 0 . . 0)
(incf level)
(and debug (print (list (make-string level) 'gen n k l)))
(when (and (&lt; 0 k n) (&lt; (car l) n))
(let* ((n-rec (- n (car l)))
(0-aft (if (&lt; k n-rec) (car l) (- n k)))
(1-bef (min k n-rec))
(first-0-aft (1+ (max k n-rec))))
(dotimes (i (min 0-aft 1-bef))
(cond ((evenp i)
(gen n-rec (- 1-bef i) (cdr l))
(swap (+ first-0-aft i)
(if (plusp (- 1-bef (cadr l) i))
; (1 . . 1 0 . . 0 | 1 . . . . . . 1 | ...)
(- 1-bef (cadr l) i)
; (0 . . . . . . 0 | 1 . . 1 0 . . 0 | ...)
(+ (- n-rec (cadr l) i) 1-bef))))
(T
(neg n-rec (- 1-bef i) (cdr l))
(swap (+ first-0-aft i)
; (1 . . 1 0 . . . . . . . . . . . 0 | ...)
(- 1-bef i)))))
(if (evenp (min 0-aft 1-bef))
(progn (gen n-rec (max 0 (- k (car l))) (cdr l))
(init n-rec (max 0 (- k (car l)))))
(neg n-rec (max 0 (- k (car l))) (cdr l)))))
(decf level))
(neg (n k l)
;      (1 . . 1 0 . . . . 0 | 1 . . . . . . 1)
; bzw. (0 . . . . . . . . 0 | 1 . . 1 0 . . 0)

;  -&gt;  (1 . . . . 1 0 . . 0 | 0 . . . . . . 0)
; bzw. (1 . . . . . . . . 1 | 1 . . 1 0 . . 0)
(incf level)
(and debug (print (list (make-string level) 'neg n k l)))
(when (and (&lt; 0 k n) (&lt; (car l) n))
(let* ((n-rec (- n (car l)))
(1-aft (min k (car l)))
(0-bef (if (&lt; k (car l)) n-rec (- n k)))
; = n-rec - 1-bef
(1-bef (if (&lt; k (car l)) 0 (- k (car l))))
; = n-rec - 0-bef
(last-1-aft (if (&lt; k (car l)) (+ n-rec k) n)))
(dotimes (i (min 1-aft 0-bef))
(cond ((evenp i)
(gen n-rec (+ 1-bef i) (cdr l))
(swap (- last-1-aft i)
(if (plusp (- (cadr l) 1-bef i))
; 0 . . . . . . 0 | 1 . . 1 0 . . 0 | 1
(- (+ n-rec 1-bef i 1) (cadr l))
; 1 . . 1 0 . . 0 | 1 . . . . . . 1 | 1
(+ (- 1-bef (cadr l)) i 1))))
(T
(neg n-rec (+ 1-bef i) (cdr l))
(swap (- last-1-aft i)
; (1 . . 1 0 . . . . . . . . . . . 0 | 1
(+ 1-bef i 1)))))
(if (evenp (min 1-aft 0-bef))
(progn (gen n-rec (min k n-rec) (cdr l))
(init n-rec (min k n-rec)))
(neg n-rec (min k n-rec) (cdr l)))))
(decf level)))
(init n k)
(funcall fun)
(gen n k l))))

(defun strange-comb-list (n k l fun &amp;optional debug)
(let ((vec (make-array n)))
(strange-combinations n k l
#'(lambda ()
(and debug (print vec))
(let (pos)
(dotimes (i n)
(or (zerop (aref vec i))
(push i pos)))
(funcall fun pos)))
vec debug)))

For what it is worth, I've used this problem as an interview question.
Most applicants fail spectacularly, so I've stopped.
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T18:15:00 </POSTDATE>
OK, how you choose to remember values for the way back from the
recursion is up to you. A stack was my way of describing that
mechanism. Nonetheless, my point was that we need not think about
remembered values. Robby has given you a nice example. It's now up to
you to try writing recursive functions without trying to explicitly
think about remembering values.

The stepper is a wonderful tool if this kind of visualization is
useful to you. I for one try to get students to think about the
problem and, if applicable, the shape of their data and to rely very
little on the stepper.

Cheers,

Marco

On Jan 4, 2008 5:24 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Marco Morazan wrote:
&gt; &gt;&gt; The number of explicit variables in the recursive version is deceptive.
&gt; &gt;&gt; When I am trying to understand a program, I put myself in the place of
&gt; &gt;&gt; the computer and work through the program in my mind. For the iterative
&gt; &gt;&gt; version, everything I need to remember are explicitly named. For
&gt; &gt;&gt; recursive algorithms, I need to keep track of the implicit variables as
&gt; &gt;&gt; well, such as how deep I am into the recursion, and what the
&gt; &gt;&gt; intermediate values are, because I will need them on my way back.

&gt; &gt; Gee whiz.....this seems like a terribly painful way to try to
&gt; &gt; understand a program. In fact, I would discourage such a low-level of
&gt; &gt; abstraction to explain recursion to new students. If someone needs to
&gt; &gt; think about what is &quot;remembered&quot; on a stack, then chances are they do
&gt; &gt; not really understand the recursive program they have written (or
&gt; &gt; trying to write). I certainly do not tell my fresnmen students that

&gt; &gt; values are remembered by the computer on a stack.

&gt; Heh, I didn't say anything about stacks or assembly level thinking, but
&gt; everyone thinks that I meant that. (I wonder if that reveals anything
&gt; about the phobias of CS academics...hmm.)

&gt; In this case the &quot;computer&quot; that I am emulating is like the stepper that
&gt; Robby linked a few post back, i.e. works in terms of scheme functions,
&gt; variables etc. And as you calculate the fibonacci recursively, you do
&gt; need to keep track of where you are and what the passed actual parameter
&gt; values are, as shown nicely  in the same post using a pen-and-paper
&gt; approach.
&gt; &gt;&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen and
&gt; &gt;&gt; paper maybe a few more. After that, I need to take a leap of faith, and
&gt; &gt;&gt; inductively conclude that if it works for the simplest case, and for the
&gt; &gt;&gt; one after that, it should work for all cases.

&gt; &gt; Why do you describe it as a leap of faith? Let me ask, what requires a
&gt; &gt; bigger &quot;leap of faith&quot; that new students can understand what a base
&gt; &gt; case and an inductive step are or that they can develop the skills to
&gt; &gt; manually trace values being stored on a stack to implement recursive
&gt; &gt; calls? The whole point is to _not_ think in terms of values being
&gt; &gt; pushed onto a stack! To this one person, that is just too hard.

&gt; Again, no stack, just the need to track of the values of the actual
&gt; parameters. And, yes, it is not difficult to learn at the end, as
&gt; millions of programmers have. The OP was about why recursion is
&gt; difficult to teach. Since as a (virtual) student I cannot answer to
&gt; that, I contributed my personal view about why it is difficult to learn.
&gt; It is (minimally) difficult to grasp at first because it requires the
&gt; inductive leap, whereas the iterative versions do not.

&gt; Drawing on the students' prior exposure to mathematical induction could
&gt; help understanding, of course, but shouldn't come at the cost of ending
&gt; up with obviously inefficient code, because that would unfairly
&gt; associate &quot;recursion&quot; with &quot;inefficiency&quot; in students' minds.

&gt; Yavuz

&gt; &gt; It seems to me that there is a great deal about abstraction that you
&gt; &gt; are &quot;sweeping under the rug.&quot;

&gt; &gt; Marco

&gt; _________________________________________________
&gt;  For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Geoffrey S. Knauth&quot; &lt;ge...@knauth.org&gt; </POSTER>
<POSTDATE> 2008-01-04T19:19:00 </POSTDATE>
On Jan 4, 2008, at 12:29, Bill Wood quoted Jerzy Karczmarczuk:

<QUOTE PREVIOUSPOST="
&gt;&gt; I propose that somebody finds a way of teaching recursion through
&gt;&gt; sex.
">

I wonder if computational biology could rewind or unzip genetic
combinations and mutations to recreate previous generations going back
in time?

Biologists have figured out how much DNA we share with chimpanzees,
mice, fruit flies and bananas.

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T20:33:00 </POSTDATE>
P.S. I am not discouraging you from asking for help or insight. I am
sure there are many people on the list that would be happy to respond
after you think about everything that has been stated and, as Matthias
suggested, work through a bit of HtDP.

On Jan 4, 2008 6:15 PM, Marco Morazan &lt;moraz ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; OK, how you choose to remember values for the way back from the
&gt; recursion is up to you. A stack was my way of describing that
&gt; mechanism. Nonetheless, my point was that we need not think about
&gt; remembered values. Robby has given you a nice example. It's now up to
&gt; you to try writing recursive functions without trying to explicitly
&gt; think about remembering values.

&gt; The stepper is a wonderful tool if this kind of visualization is
&gt; useful to you. I for one try to get students to think about the
&gt; problem and, if applicable, the shape of their data and to rely very
&gt; little on the stepper.

&gt; Cheers,

&gt; Marco

&gt; On Jan 4, 2008 5:24 PM, Yavuz Arkun &lt;yar ... @gmail.com&gt; wrote:

&gt; &gt; Marco Morazan wrote:
&gt; &gt; &gt;&gt; The number of explicit variables in the recursive version is deceptive.
&gt; &gt; &gt;&gt; When I am trying to understand a program, I put myself in the place of
&gt; &gt; &gt;&gt; the computer and work through the program in my mind. For the iterative
&gt; &gt; &gt;&gt; version, everything I need to remember are explicitly named. For
&gt; &gt; &gt;&gt; recursive algorithms, I need to keep track of the implicit variables as
&gt; &gt; &gt;&gt; well, such as how deep I am into the recursion, and what the
&gt; &gt; &gt;&gt; intermediate values are, because I will need them on my way back.

&gt; &gt; &gt; Gee whiz.....this seems like a terribly painful way to try to
&gt; &gt; &gt; understand a program. In fact, I would discourage such a low-level of
&gt; &gt; &gt; abstraction to explain recursion to new students. If someone needs to
&gt; &gt; &gt; think about what is &quot;remembered&quot; on a stack, then chances are they do
&gt; &gt; &gt; not really understand the recursive program they have written (or
&gt; &gt; &gt; trying to write). I certainly do not tell my fresnmen students that

&gt; &gt; &gt; values are remembered by the computer on a stack.

&gt; &gt; Heh, I didn't say anything about stacks or assembly level thinking, but
&gt; &gt; everyone thinks that I meant that. (I wonder if that reveals anything
&gt; &gt; about the phobias of CS academics...hmm.)

&gt; &gt; In this case the &quot;computer&quot; that I am emulating is like the stepper that
&gt; &gt; Robby linked a few post back, i.e. works in terms of scheme functions,
&gt; &gt; variables etc. And as you calculate the fibonacci recursively, you do
&gt; &gt; need to keep track of where you are and what the passed actual parameter
&gt; &gt; values are, as shown nicely  in the same post using a pen-and-paper
&gt; &gt; approach.
&gt; &gt; &gt;&gt; Personally, I can manage 1 or 2 levels mentally, and if I use pen and
&gt; &gt; &gt;&gt; paper maybe a few more. After that, I need to take a leap of faith, and
&gt; &gt; &gt;&gt; inductively conclude that if it works for the simplest case, and for the
&gt; &gt; &gt;&gt; one after that, it should work for all cases.

&gt; &gt; &gt; Why do you describe it as a leap of faith? Let me ask, what requires a
&gt; &gt; &gt; bigger &quot;leap of faith&quot; that new students can understand what a base
&gt; &gt; &gt; case and an inductive step are or that they can develop the skills to
&gt; &gt; &gt; manually trace values being stored on a stack to implement recursive
&gt; &gt; &gt; calls? The whole point is to _not_ think in terms of values being
&gt; &gt; &gt; pushed onto a stack! To this one person, that is just too hard.

&gt; &gt; Again, no stack, just the need to track of the values of the actual
&gt; &gt; parameters. And, yes, it is not difficult to learn at the end, as
&gt; &gt; millions of programmers have. The OP was about why recursion is
&gt; &gt; difficult to teach. Since as a (virtual) student I cannot answer to
&gt; &gt; that, I contributed my personal view about why it is difficult to learn.
&gt; &gt; It is (minimally) difficult to grasp at first because it requires the
&gt; &gt; inductive leap, whereas the iterative versions do not.

&gt; &gt; Drawing on the students' prior exposure to mathematical induction could
&gt; &gt; help understanding, of course, but shouldn't come at the cost of ending
&gt; &gt; up with obviously inefficient code, because that would unfairly
&gt; &gt; associate &quot;recursion&quot; with &quot;inefficiency&quot; in students' minds.

&gt; &gt; Yavuz

&gt; &gt; &gt; It seems to me that there is a great deal about abstraction that you
&gt; &gt; &gt; are &quot;sweeping under the rug.&quot;

&gt; &gt; &gt; Marco

&gt; &gt; _________________________________________________
&gt; &gt;  For list-related administrative tasks:
&gt; &gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> jerzy.karczmarc...@info.unicaen.fr </POSTER>
<POSTDATE> 2008-01-04T22:18:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Geoffrey S. Knauth writes:
&gt; I wonder if computational biology could rewind or unzip genetic
&gt; combinations and mutations to recreate previous generations going back  in
&gt; time?

&gt; Biologists have figured out how much DNA we share with chimpanzees,  mice,
&gt; fruit flies and bananas.
">

And sausages. But still, only Almighty and some German butchers know what's
inside, as the French saying goes. And the reconstruction of a nice swine
from it doesn't seem computationally easy...
But, on the other hand, computations have finally found the missing link
between Apes and /Homo Sapiens/. It is the Computer Scientist. We share
plenty of DNA with them, hopefully not 100%.

Jerzy Karczmarczuk

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Jos Koot&quot; &lt;jos.k...@telefonica.net&gt; </POSTER>
<POSTDATE> 2008-01-05T09:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
----- Original Message -----
From: &quot;Geoffrey S. Knauth&quot; &lt;ge ... @knauth.org&gt;
To: &quot;Jos Koot&quot; &lt;jos.k ... @telefonica.net&gt;
Sent: Saturday, January 05, 2008 1:05 AM
Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
helpwriting function )

&gt;I like your solution!

Thanks.
Earlier I said that Fibonacci would be to difficult for novices, but that
may depend on how the problem is presented. See below.
Jos

; Compute i-th number of fib sequence starting with m and n.
; The first number of the sequence has index i=0.
; A fib sequence is an infinite sequence determined by:
; (fib 0 m n) = m
; (fib i m n) = (fib (- i 1) n (+ m n)) if i&gt;0
; With this definition a novice easily comes up with

(define (fib i m n)
(if (zero? i) m
(fib (sub1 i) n (+ m n))))

; I think the generalization to (fib i m n) from (fib i 1 1)
; simplifies the problem too.

; List of first k fib numbers starting with m and n.
; Somewhat more difficult.
(define (first-fibs k m n)
(if (zero? k) ()
(cons m (first-fibs (sub1 k) n (+ m n)))))

#| A novice easily runs into trouble if the definition is presented as:
(fib 0) = m
(fib 1) = n
(fib i) = (+ (fib (- i 2)) (fib (- i 1))) if i&gt;1
Mathematically this is a correct definition, of course,
but a novice may have trouble finding the loop invariant:
(fib i m n) = (fib (sub1 i) n (+ m n)) if i&gt;0
Finding this loop invariant is a mathematical problem
rather than one of programming. |#

&gt; On Jan 4, 2008, at 11:00, Jos Koot wrote:

&gt;&gt; For me the following is the most simple recursive:

&gt;&gt; (define (make-fib-stream n m)
&gt;&gt; (cons n (lambda () (make-fib-stream m (+ n m)))))

&gt;&gt; (define (fib n) ; return n-th fib number
&gt;&gt; (if (zero? n) 1
&gt;&gt; (fib-aux n (make-fib-stream 1 1))))

&gt;&gt; (define (fib-aux n stream)
&gt;&gt; (if (zero? n) (car stream)
&gt;&gt; (fib-aux (sub1 n) ((cdr stream)))))

&gt;&gt; (time (fib 300))
&gt;&gt; (map fib '(0 1 2 3 4 5 6 7 8 9))

&gt;&gt; Welcome to DrScheme, version 371.3-svn26oct2007 [3m].
&gt;&gt; Language: Textual (MzScheme, includes R5RS) custom.
&gt;&gt; cpu time: 0 real time: 0 gc time: 0
&gt;&gt; 359579325206583560961765665172189099052367214309267232255589801
&gt;&gt; (1 1 2 3 5 8 13 21 34 55)

&gt;&gt; Jos Koot

&gt;&gt; ----- Original Message ----- From: &quot;Marco Morazan&quot;  &lt;moraz ... @gmail.com&gt;
&gt;&gt; To: &quot;Yavuz Arkun&quot; &lt;yar ... @gmail.com&gt;
&gt;&gt; Cc: &lt;plt-sch ... @list.cs.brown.edu&gt;
&gt;&gt; Sent: Friday, January 04, 2008 3:52 PM
&gt;&gt; Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice  needs
&gt;&gt; helpwriting function )

&gt;&gt;&gt;&gt; BTW, I first learned about the Fibonacci series in high school,  and we
&gt;&gt;&gt;&gt; were told they are generated by &quot;start with 1, 1, and then add the
&gt;&gt;&gt;&gt; last
&gt;&gt;&gt;&gt; 2 together to get the next one...&quot;, e.g. iteratively. For me the
&gt;&gt;&gt;&gt; recursive definition is contrived, and I saw it for the first time  in
&gt;&gt;&gt;&gt; intro programming books. I guess this shows that prior teaching of
&gt;&gt;&gt;&gt; iterative style kills some neurons forever.

&gt;&gt;&gt; ;;; fib: number -&gt; number
&gt;&gt;&gt; (define (fib n)
&gt;&gt;&gt; ;;; if n is 1 or 2 the nth fib. number is 1
&gt;&gt;&gt; ;;; if n &gt; 2
&gt;&gt;&gt; ;;;    (fib (- n 1)) is the (n-1)th fib. number
&gt;&gt;&gt; ;;;    (fib (- n 2)) is the (n-2)th fib. number
&gt;&gt;&gt; ;;;    (+ (fib (- n 1))  (fib (- n 2)) is the nth fib. number
&gt;&gt;&gt; (cond [(or (= n 1) (= n 2)) 1]
&gt;&gt;&gt;          [else (+ (fib (- n 1))  (fib (- n 2)))]))

&gt;&gt;&gt; What is contrived about this? It precisely follows the definition  you
&gt;&gt;&gt; outlined.

&gt;&gt;&gt; Now, the iterative version:

&gt;&gt;&gt; if (n &lt;= 2)
&gt;&gt;&gt; {return(1);}
&gt;&gt;&gt; else
&gt;&gt;&gt; f1 = 1;
&gt;&gt;&gt; f2 = 1;
&gt;&gt;&gt; curr = 2;
&gt;&gt;&gt; k = 3;
&gt;&gt;&gt; while (k &lt; n)
&gt;&gt;&gt; {
&gt;&gt;&gt;   k = k + 1;
&gt;&gt;&gt;   f1 = f2;
&gt;&gt;&gt;   f2 = curr;
&gt;&gt;&gt;   curr = f1 + f2;
&gt;&gt;&gt; }
&gt;&gt;&gt; return(curr);

&gt;&gt;&gt; That looks contrived to me. All of the sudden we have 5 variables
&gt;&gt;&gt; (i.e. n, k, f1, f2, and curr) instead of just one (i.e. n) like in  the
&gt;&gt;&gt; recursive version. Furthermore, I have to carefully place my
&gt;&gt;&gt; statements. If the order is changed it will not work.

&gt;&gt;&gt; Cheers,

&gt;&gt;&gt; Marco
&gt;&gt;&gt; _________________________________________________
&gt;&gt;&gt; For list-related administrative tasks:
&gt;&gt;&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

&gt;&gt; _________________________________________________
&gt;&gt; For list-related administrative tasks:
&gt;&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">
</POST>
<POST>
<POSTER> &quot;Marco Morazan&quot; &lt;moraz...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-05T10:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; ; Compute i-th number of fib sequence starting with m and n.
&gt; ; The first number of the sequence has index i=0.
&gt; ; A fib sequence is an infinite sequence determined by:
&gt; ; (fib 0 m n) = m
&gt; ; (fib i m n) = (fib (- i 1) n (+ m n)) if i&gt;0
&gt; ; With this definition a novice easily comes up with

&gt; (define (fib i m n)
&gt;  (if (zero? i) m
&gt;  (fib (sub1 i) n (+ m n))))
">

Essentially, you have now changed the contract on the fib function
from fib: num -&gt; num to num num num -&gt; num if you leave the problem at
this point. This tail-recursive version is efficient and only requires
one more step to meet the original contract by making the above
function an auxilary function. :-)

The point is that any user of the fib function is likely to want to
only be interested in (and only want to be bothered with) inputing the
i for the ith fib number of their interest. There is no need for them
to be bothered with the m and n.

;;; fibonacci: num -&gt; num
(define (fibonacci i)
(fib i 0 1))

Cheers,

Marco
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> &quot;Jos Koot&quot; &lt;jos.k...@telefonica.net&gt; </POSTER>
<POSTDATE> 2008-01-05T11:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
----- Original Message -----
From: &quot;Marco Morazan&quot; &lt;moraz ... @gmail.com&gt;
To: &quot;Jos Koot&quot; &lt;jos.k ... @telefonica.net&gt;

Cc: &quot;Geoffrey S. Knauth&quot; &lt;ge ... @knauth.org&gt;; &lt;plt-sch ... @list.cs.brown.edu&gt;
Sent: Saturday, January 05, 2008 4:53 PM
Subject: Re: Problem with recursion? (was [plt-scheme] Re: Novice needs
helpwriting function )

&gt;&gt; ; Compute i-th number of fib sequence starting with m and n.
&gt;&gt; ; The first number of the sequence has index i=0.
&gt;&gt; ; A fib sequence is an infinite sequence determined by:
&gt;&gt; ; (fib 0 m n) = m
&gt;&gt; ; (fib i m n) = (fib (- i 1) n (+ m n)) if i&gt;0
&gt;&gt; ; With this definition a novice easily comes up with

&gt;&gt; (define (fib i m n)
&gt;&gt;  (if (zero? i) m
&gt;&gt;  (fib (sub1 i) n (+ m n))))

&gt; Essentially, you have now changed the contract on the fib function
&gt; from fib: num -&gt; num to num num num -&gt; num if you leave the problem at
&gt; this point. This tail-recursive version is efficient and only requires
&gt; one more step to meet the original contract by making the above
&gt; function an auxilary function. :-)

Right

&gt; The point is that any user of the fib function is likely to want to
&gt; only be interested in (and only want to be bothered with) inputing the
&gt; i for the ith fib number of their interest. There is no need for them
&gt; to be bothered with the m and n.

Essentially I changed the exercise such as to make a function that
represents ALL Fibonacci sequences. If I remember well, Fibonacci sequences
are not restricted to
(1 1 2 etc) or (0 1 1 2 etc)
They may start with two arbitrary numbers, I think, although
(lambda (i) (fib i 0 0))
is not very interesting, of course.
The more general exercise is much easier than the particular one. To come up
with the generalization may be too difficult a step for a novice and rather
is mathematics than programming, I think.

&gt; ;;; fibonacci: num -&gt; num
&gt; (define (fibonacci i)
&gt;  (fib i 0 1))

This is sequence (0 1 1 2 etc) not (1 1 2 etc)  :)

Cheers, Jos

&gt; Cheers,

&gt; Marco

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">
</POST>
<POST>
<POSTER> &quot;dbtleo...@gmail.com&quot; &lt;dbtleo...@gmail.com&gt; </POSTER>
<POSTDATE> 2008-01-04T12:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt;From my experience, the HtDP approach to teaching recursion works
">

well: teach recursive *data structures* before teaching recursive
*functions*.  I find students understand recursive data structures
more easily because data structures are concrete -- you can write down
examples and see where the recursion comes in.  Then once the students
have got that part down, moving on to functions over recursive data is
a much smaller conceptual leap.

I think the examples in this thread using Fibonacci are harder for
beginners to grasp.  Stick with lists or kebabs or whatnot.

Dave

On Jan 4, 12:11 am, &quot;Grant Rettke&quot; &lt;gret ... @acm.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; This thread had mentioned helping students understand recursion, and
&gt; for some reason, this topic of understanding recursion has come up a
&gt; lot lately &quot;by the water cooler&quot;, among other things.

&gt; I recently heard that a particular teacher quit trying to teach
&gt; recursion because &quot;it is too hard for students to understand&quot;.

&gt; Is there an epidemic of sorts that students don't understand recursion?

&gt; What are the challenges to understanding recursion?
&gt; _________________________________________________
&gt;   For list-related administrative tasks:
&gt; http://list.cs.brown.edu/mailman/listinfo/plt-scheme
">

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Richard Cobbe &lt;co...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-06T10:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Fri, Jan 04, 2008 at 09:46:15AM -0800, dbtleo ... @gmail.com wrote:
&gt; &gt;From my experience, the HtDP approach to teaching recursion works
&gt; well: teach recursive *data structures* before teaching recursive
&gt; *functions*.  I find students understand recursive data structures
&gt; more easily because data structures are concrete -- you can write down
&gt; examples and see where the recursion comes in.  Then once the students
&gt; have got that part down, moving on to functions over recursive data is
&gt; a much smaller conceptual leap.

&gt; I think the examples in this thread using Fibonacci are harder for
&gt; beginners to grasp.  Stick with lists or kebabs or whatnot.
">

Amen!

<QUOTE PREVIOUSPOST="
&gt;From &quot;Can We Make Mathematics Intelligible?&quot;, R. P. Boas, The American
">

Mathematical Monthly, vol 10, pp727--731 (Dec 1981):

Suppose you want to teach the &quot;cat&quot; concept to a very young child.  Do
you explain that a cat is a relatively small, primarily carnivorous
mammal with retractile claws, a distinctive sonic output, etc.?  I'll
bet not.  You probably show the kid a lot of different cats, saying
&quot;kitty&quot; each time, until it gets the idea.  To put it more generally,
generalizations are best made by abstraction from experience.

One of the major strengths of the HtDP model, IMO, is the emphasis it
places on examples -- both of data structures and of functions.  Among
other things, this forces students (and professors, for that matter) to
approach generalizations from the concrete.  Most of us, myself included,
aren't so different from the child in the story above in that respect.

Richard
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Prabhakar Ragde &lt;plra...@uwaterloo.ca&gt; </POSTER>
<POSTDATE> 2008-01-06T13:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Richard Cobbe wrote:
&gt; One of the major strengths of the HtDP model, IMO, is the emphasis it
&gt; places on examples -- both of data structures and of functions.  Among
&gt; other things, this forces students (and professors, for that matter) to
&gt; approach generalizations from the concrete.  Most of us, myself included,
&gt; aren't so different from the child in the story above in that respect.
">

I would suggest the opposite -- that HtDP encourages one to develop in
generality, as opposed to just about every other approach, which
presents a bunch of examples and then leaves students to form their own
(possibly imperfect) generalizations. As the book proceeds, fewer
examples are used. Before each of the data definitions for ancestor and
descendant family trees, there is exactly one example. There is no
example presented before the data definition for binary trees. Templates
encourage students to proceed from the general to the specific.

As for the difficulty of recursion, it is not the concrete nature of
data structures that makes recursion on them easier. The non-negative
integers are pretty concrete, also. But students have had much
experience working with the non-negative integers in a non-recursive
fashion, whereas this is not true for lists and trees. This novelty
provides sufficient motivation for recursion, and the substitution model
which needs no change or augmentation to work for recursive functions
provides proper support to understand the mechanism.

I find it amusing that section 9 of HtDP tiptoes into both
self-referential data definitions and recursive functions, whereas
section 8.2 presents a Scheme grammar, naturally self-referential, with
absolutely no fanfare or fuss. --PR
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> jerzy.karczmarc...@info.unicaen.fr </POSTER>
<POSTDATE> 2008-01-06T15:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Prabhakar Ragde writes:
&gt; Richard Cobbe wrote:

&gt;&gt; One of the major strengths of the HtDP model, IMO, is the emphasis it
&gt;&gt; places on examples ... this forces students (and professors, for that
&gt;&gt; matter) to approach generalizations from the concrete.  Most of us,
&gt;&gt; myself included, aren't so different from the child in the story above in
&gt;&gt; that respect.
&gt; I would suggest the opposite -- that HtDP encourages one to develop in
&gt; generality, as opposed to just about every other approach, which presents
&gt; a bunch of examples and then leaves students to form their own (possibly
&gt; imperfect) generalizations. As the book proceeds, fewer examples are used.
">

Gentlemen, I see in this discussion two scholastic currents.

1. What is The True and Good Way to teach recursion. Shrug.
2. What is The True Interpretation and Assessment of HowToDesignWhatever.

Perhaps you should take into account that since the awakening of the human
spirit, BOTH concept flows: generalisation from examples, AND instantiation
are equally important and unavoidable?

You will find these antithetic flows everywhere. In the building of our
knowledge, when we have to get rid of the building from examples, survive
a Spark, and descend back from axioms. All attempts to get rid of one side
of this process failed. Quite spectacular is the failure of positivists,
who wanted to reduce everything to concrete sensations, and to build
theories therefrom...

You will find it in the Piagetian theory of learning, where the assimilation
and accomodation must cooperate. A child who after some attempts stands up
and begins to walk is NOT emulating examples around it.

The categorical reconstruction of math, definitions of a product (or co-...)
is not an &quot;upward generalization&quot; of the traditional, banal examples, but
a downward reconstruction of known entities.

Etc.

The same problems concern the teaching of programming, and concepts as this
damned recursion. Eventually, *all* must be conveyed. The structural
recursion on data, reducing recursion such as [n! = n*(n-1)!], and also
the co-recursion and its generative aspects. And the notion of
self-reference, and the notion of fixed point.

The order to do all that will never be resolved unambiguously, all this
depends on the teacher, on the level/attitude of the students group, etc.
No doctrine can really help, and no statistics on the superiority of one
method wrt. another helps either. What I read here, reminds me when I was
married to a language teacher. My goodness, she passed through at least 15
different &quot;pedagogical methods&quot;, all based on some *doctrines*. All these
teachers/methodologists met sometimes together and quarreled, and they
still do so. And nothing really changes, often they revert to the &quot;old&quot;
style, abandoned some years before because of some rational consensus...

I learned one thing, though.
Do your best, speak about concepts *you* understand, individualize your
teaching, and *NEVER* say to anybody that something is difficult.

But of course, all this, and especially the last point is difficult...

Jerzy Karczmarczuk

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Richard Cobbe &lt;co...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-06T15:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sun, Jan 06, 2008 at 01:46:57PM -0500, Prabhakar Ragde wrote:
&gt; Richard Cobbe wrote:

&gt;&gt; One of the major strengths of the HtDP model, IMO, is the emphasis it
&gt;&gt; places on examples -- both of data structures and of functions.  Among
&gt;&gt; other things, this forces students (and professors, for that matter) to
&gt;&gt; approach generalizations from the concrete.  Most of us, myself included,
&gt;&gt; aren't so different from the child in the story above in that respect.

&gt; I would suggest the opposite -- that HtDP encourages one to develop in
&gt; generality, as opposed to just about every other approach, which presents a
&gt; bunch of examples and then leaves students to form their own (possibly
&gt; imperfect) generalizations. As the book proceeds, fewer examples are used.
&gt; Before each of the data definitions for ancestor and descendant family
&gt; trees, there is exactly one example. There is no example presented before
&gt; the data definition for binary trees. Templates encourage students to
&gt; proceed from the general to the specific.
">

It's been a while since I've looked at the textbook in any detail, but as I
remember it, we're both right (for various values of HtDP).

That is to say, the times that I've TA'd for Matthias doing this class, he
has emphasized the importance of examples in lecture, lab, etc. far more
than the text does, and I had forgotten this when I wrote the message
up-thread.  Indeed, while the sections of the text that describe the design
recipe for structures, unions, and lists show examples of values of those
types, they don't really emphasize that construction of these examples is a
crucial part of the design recipe.  (I'm looking specifically at sections
6.5, 7.2, and 9.4 on the web.)

But my experience in working with students in the HtDP curriculum is that
they have immense problems writing functions for tricky data structures
unless they start with examples of those structures.

Richard
_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
<POST>
<POSTER> Matthias Felleisen &lt;matth...@ccs.neu.edu&gt; </POSTER>
<POSTDATE> 2008-01-06T15:44:00 </POSTDATE>
On Jan 6, 2008, at 1:46 PM, Prabhakar Ragde wrote:

<QUOTE PREVIOUSPOST="
&gt; I would suggest the opposite -- that HtDP encourages one to develop
&gt; in generality, as opposed to just about every other approach, which
&gt; presents a bunch of examples and then leaves students to form their
&gt; own (possibly
">

wrong: usually not possibly

<QUOTE PREVIOUSPOST="
&gt; imperfect) generalizations.
">

You're both correct. Think about it!

<QUOTE PREVIOUSPOST="
&gt; I find it amusing that section 9 of HtDP tiptoes into both self-
&gt; referential data definitions and recursive functions, whereas
&gt; section 8.2 presents a Scheme grammar, naturally self-referential,
&gt; with absolutely no fanfare or fuss.
">

I consider it a nice trick -- anticipate w/o 'I told you so.' --
Matthias

_________________________________________________
For list-related administrative tasks:
http://list.cs.brown.edu/mailman/listinfo/plt-scheme
</POST>
</TEXT>
</BODY>
</DOC>
