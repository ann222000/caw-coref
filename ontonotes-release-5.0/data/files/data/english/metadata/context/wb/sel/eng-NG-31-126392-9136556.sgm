<DOC>
<DOCID> eng-NG-31-126392-9136556 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-10-03T16:05:00 </DATETIME>
<BODY>
<HEADLINE>
C needs a BOOST
</HEADLINE>
<TEXT>
<POST>
<POSTER> user923005 &lt;dcor...@connx.com&gt; </POSTER>
<POSTDATE> 2007-10-03T16:05:00 </POSTDATE>
It would be really nice if C could adopt a really nice algorithms
library like C++'s STL + BOOST.

The recent &quot;reverse the words in this sentence&quot; problem posted made me
think about it.
It's like 5 lines to do it in C++ because of all the nifty algorithms
that come with the language (I think BOOST is going to get bolted on
to the C++ language like STL did).

It's a lot more work in C than C++.  Why doesn't C have stacks,
dequeues, and other common, simple tool sets already in its standard
library?

Opinions?  Is keeping the language tiny worth the cost of C
programmers having to constantly reinvent the wheel?
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T16:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.
">

How would you implement that in C?
Is there any solution simplier than transforming C into C++?
(GC and operator overloading proposed by jacob navia won't provide generic
algorithms).

<QUOTE PREVIOUSPOST="
&gt; Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

Keeping the language small makes C different from C++, and that's why, C
can still be better than C++ for some projects.
On the other hand, transforming C into C++ would be pointless, as it would
make the C and C++ language duplicates.

<QUOTE PREVIOUSPOST="
&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?
">

Propose an implementable solution. Ideally, with several successful
real-world implementations.
Then, we may consider your offer.

--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
André Gillibert wrote:
&gt; user923005 wrote:

&gt;&gt; It would be really nice if C could adopt a really nice algorithms
&gt;&gt; library like C++'s STL + BOOST.

&gt; How would you implement that in C?
&gt; Is there any solution simplier than transforming C into C++?
&gt; (GC and operator overloading proposed by jacob navia won't provide
&gt; generic algorithms).
">

There are several solutions to your &quot;problem&quot; of genericity.

The first one is the usage of the generic pointer in C: void *

I have written a dynamic table package using that approach. You tell
the software how big your objects are, and then you just use them.
Operator overloading allows you to assign and read the data.

True, the functions return a void pointer that must be casted into
something but that is a minor inconvenience.

<QUOTE PREVIOUSPOST="
&gt;&gt; Is keeping the language tiny worth the cost of C
&gt;&gt; programmers having to constantly reinvent the wheel?

&gt; Keeping the language small makes C different from C++, and that's why, C
&gt; can still be better than C++ for some projects.
">

This is an error. Keeping the language in this state makes the language
impossible to use for any serious software development
unless your project is big enough to warrant rewriting the
C library and adding stacks, lists, etc etc at each project!

<QUOTE PREVIOUSPOST="
&gt; On the other hand, transforming C into C++ would be pointless, as it
&gt; would make the C and C++ language duplicates.
">

Yes. What I am proposing is nothing of the sort.

I am just proposing using operator overloading, a very common
feature found in almost all languages including FORTRAN, Visual Basic,
C# C++, and what have you!

<QUOTE PREVIOUSPOST="
&gt;&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt;&gt; dequeues, and other common, simple tool sets already in its standard
&gt;&gt; library?

&gt; Propose an implementable solution. Ideally, with several successful
&gt; real-world implementations.
">

I have done just that.
Only flames ensued.

<QUOTE PREVIOUSPOST="
&gt; Then, we may consider your offer.
">

You can consider mine. It is working, it has an implementation,
why not looking at it?

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Clever Monkey &lt;spamt...@clevermonkey.org.INVALID&gt; </POSTER>
<POSTDATE> 2007-10-03T16:33:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.

&gt; The recent &quot;reverse the words in this sentence&quot; problem posted made me
&gt; think about it.
&gt; It's like 5 lines to do it in C++ because of all the nifty algorithms
&gt; that come with the language (I think BOOST is going to get bolted on
&gt; to the C++ language like STL did).

&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?
">

Why does this have to be part of the language?  There are plenty of
third-party APIs that give you this.

There are plenty of reasons to keep a language small, and let the
implementors provide solutions for their customers.
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.

&gt; The recent &quot;reverse the words in this sentence&quot; problem posted made me
&gt; think about it.
&gt; It's like 5 lines to do it in C++ because of all the nifty algorithms
&gt; that come with the language (I think BOOST is going to get bolted on
&gt; to the C++ language like STL did).

&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?

&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

We had a discussion about this a few weeks ago.
I proposed several minor modifications to the language to be able to
access containers, stacks queues, lists and other objects by using
an uniform interface. Please see the thread &quot;Operator overloading in C&quot;
in comp.std.c, started by myself on September 5th.

You can download an implementation of those ideas at
http://www.cs.virginia.edu/~lcc-win32

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2007-10-03T16:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;user923005&quot; &lt;dcor ... @connx.com&gt; wrote in message
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.
">

It is generally slightly easier to implement a structure from scratch than
to use someone else's interface. In the case of the liked list, queue and
stack it is unclear whether this says something good or something bad about
C.

For more complicated structures it seems clear that you shouldn't have to do
them yourself. Plenty of code is publically available, some of it written by
myself. However it always seems to define bool, or take control of your
main, or demand the filling in of complex structures to get the system
operational, or doing at least something unspeakable. The code portion of my
website is not especially popular, with the exception only of the Basic
interpreter.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Clever Monkey wrote:
&gt; user923005 wrote:
&gt;&gt; It would be really nice if C could adopt a really nice algorithms
&gt;&gt; library like C++'s STL + BOOST.

&gt;&gt; The recent &quot;reverse the words in this sentence&quot; problem posted made me
&gt;&gt; think about it.
&gt;&gt; It's like 5 lines to do it in C++ because of all the nifty algorithms
&gt;&gt; that come with the language (I think BOOST is going to get bolted on
&gt;&gt; to the C++ language like STL did).

&gt;&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt;&gt; dequeues, and other common, simple tool sets already in its standard
&gt;&gt; library?

&gt; Why does this have to be part of the language?  There are plenty of
&gt; third-party APIs that give you this.
">

Each one different than the other. There isn't a STANDARD way of doing a
list, so you have to construct a list each time you want to use one!

But we have discussed this several times, and nothing ever changes.

gets() is still there and will stay with us at least till 2019.

<QUOTE PREVIOUSPOST="
&gt; There are plenty of reasons to keep a language small, and let the
&gt; implementors provide solutions for their customers.
">

Most of the time this means that each developer is forced to write
a list handling stuff at each application.
--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Malcolm McLean wrote:
&gt; &quot;user923005&quot; &lt;dcor ... @connx.com&gt; wrote in message
&gt;&gt; It would be really nice if C could adopt a really nice algorithms
&gt;&gt; library like C++'s STL + BOOST.

&gt; It is generally slightly easier to implement a structure from scratch
&gt; than to use someone else's interface. In the case of the liked list,
&gt; queue and stack it is unclear whether this says something good or
&gt; something bad about C.
">

It just says that you must reinvent the wheel at each
application.

Great Malcolm.

<QUOTE PREVIOUSPOST="
&gt; For more complicated structures it seems clear that you shouldn't have
&gt; to do them yourself. Plenty of code is publically available, some of it
&gt; written by myself. However it always seems to define bool, or take
&gt; control of your main, or demand the filling in of complex structures to
&gt; get the system operational, or doing at least something unspeakable. The
&gt; code portion of my website is not especially popular, with the exception
&gt; only of the Basic interpreter.
">

Wouldn't it be a good idea to propose an STL clone?

It *can* be done in C!!!

That would be an interesting undertaking no?

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Eric Sosman &lt;Eric.Sos...@sun.com&gt; </POSTER>
<POSTDATE> 2007-10-03T16:45:00 </POSTDATE>
jacob navia wrote On 10/03/07 16:31,:

<QUOTE PREVIOUSPOST="
&gt; André Gillibert wrote:

&gt;&gt;Keeping the language small makes C different from C++, and that's why, C
&gt;&gt;can still be better than C++ for some projects.

&gt; This is an error. Keeping the language in this state makes the language
&gt; impossible to use for any serious software development
&gt; unless your project is big enough to warrant rewriting the
&gt; C library and adding stacks, lists, etc etc at each project!
">

Since C is impossible to use for serious software
development, one wonders why so many programmers spent
so many years writing so much non-serious (comic?)
software.  Ritchie, Thompson, heck, even Torvalds have
just been clowning around, right?

--
Eric.Sos ... @sun.com
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Eric Sosman wrote:
&gt; jacob navia wrote On 10/03/07 16:31,:
&gt;&gt; André Gillibert wrote:

&gt;&gt;&gt; Keeping the language small makes C different from C++, and that's why, C
&gt;&gt;&gt; can still be better than C++ for some projects.

&gt;&gt; This is an error. Keeping the language in this state makes the language
&gt;&gt; impossible to use for any serious software development
&gt;&gt; unless your project is big enough to warrant rewriting the
&gt;&gt; C library and adding stacks, lists, etc etc at each project!

&gt;     Since C is impossible to use for serious software
&gt; development, one wonders why so many programmers spent
&gt; so many years writing so much non-serious (comic?)
&gt; software.  Ritchie, Thompson, heck, even Torvalds have
&gt; just been clowning around, right?
">

Can't you read?
I cite this again then:

&gt;&gt; unless your project is big enough to warrant rewriting the
&gt;&gt; C library and adding stacks, lists, etc etc at each project!

In my debugger project there was obviously a list module

Then in the IDE too.

Then, in the compiler there is another one.

Then it seemed stupid to me at spent time making the debugger
use the IDE list package.

Yes, that happens. Not to you of course.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T16:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; There are several solutions to your &quot;problem&quot; of genericity.
&gt;The first one is the usage of the generic pointer in C: void *
">

At the cost of performances, but that's the cost of abstraction, anyway.
If that's all user923005 wants, he can use GLib or other C librairies.

<QUOTE PREVIOUSPOST="
&gt; You can consider mine. It is working, it has an implementation,
&gt; why not looking at it?
">

I looked at it.

--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T16:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
André Gillibert wrote:
&gt; jacob navia wrote:

&gt;&gt; There are several solutions to your &quot;problem&quot; of genericity.
&gt;&gt; The first one is the usage of the generic pointer in C: void *

&gt; At the cost of performances, but that's the cost of abstraction, anyway.
&gt; If that's all user923005 wants, he can use GLib or other C librairies.
">

I tried to use the Glib, but then I was confronted with a HUGE package
that I would have to port everywhere and I could not control
at all.

It would be much better for everybody that we had a standard
interface like in C++ and then use a standard library!
--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T17:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; I tried to use the Glib, but then I was confronted with a HUGE package
&gt; that I would have to port everywhere and I could not control
&gt; at all.

&gt; It would be much better for everybody that we had a standard
&gt; interface like in C++ and then use a standard library!
">

In that case, you must expect that this HUGE package be bundled with every
C implementation... I hardly can see why C implementors would produce
better code than GNU's guys.

Actually, with C++'s STL, I've seen that most implementations have an
incredibely low QOI. Consequently, I've always to use an external
implementation (STLPort) which has far less bugs, and produces much better
code.

I don't see why the STL problem wouldn't be reproduced for C.

Unfortunately, C doesn't support namespaces, so it's not easy to replace
the standard library with a different implementation.

With the C++ STL experience I got, I think it's important to get the
standard library small, mainly containing components that cannot easily
and efficiently be implemented in pure standard C.

Otherwise, you're sure to get all the bloat with every C implementation.
Cross-compiler linking will result in linking issues or duplication of the
code bloat.

--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> &quot;Douglas A. Gwyn&quot; &lt;DAG...@null.net&gt; </POSTER>
<POSTDATE> 2007-10-03T16:55:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?
">

C++ didn't have those either, initially.  They got tacked on
along the way as agreement was reached on them.

There are far fewer active workers on the C standard than have
been involved with C++, and no major incentive to spend any
significant fraction of the available resources working on
such libraries.  Note that the C standards group *has* worked
on several extensions, generally described in Technical
Reports, and adopted complex numbers (with library support)
into the C standard due to demand from the numerical
programming community.

<QUOTE PREVIOUSPOST="
&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

You don't have to reinvent this wheel if you use an already-
developed library that provides what you need.  It just won't
be provided automatically with the C compiler, so you have to
arrange to obtain it separately.  I have my own library with
support for things like you mentioned, and other experienced
programmers and programming shops most likly do also.

If you find a good example that you would like standardized,
propose it during the next round of revision of the C
standard.  It needs substantial user experience or it is
likely to be considered too risky to force it upon everybody.
</POST>
<POST>
<POSTER> santosh &lt;santosh....@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T17:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.
">

Without some changes to the language, how are we going to implement generic
algorithms and data structures? Yes void * is always there, but that seems
a messy and ugly solution.

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

Constantly? A library like GLib can be ported to most architectures, and
where it's not practical to port to, a Standardised library is going to
face equally tough problems.
</POST>
<POST>
<POSTER> santosh &lt;santosh....@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T17:21:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
">

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; Wouldn't it be a good idea to propose an STL clone?

&gt; It *can* be done in C!!!
">

Pure ISO C?
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T17:23:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.

&gt; The recent &quot;reverse the words in this sentence&quot; problem posted made me
&gt; think about it.
&gt; It's like 5 lines to do it in C++ because of all the nifty algorithms
&gt; that come with the language (I think BOOST is going to get bolted on
&gt; to the C++ language like STL did).

&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?

&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

Alex Stepanov's STL became part of the C++ standard library because it
was there, it filled a need and became extremely poplar.  There were
competing libraries, but through the process of natural selection, the
STL became the most popular.  So it became a de facto standard before it
was standardised.  The same thing is happening with parts of boost.

Which raises the question why hasn't anyone written such a popular
library for C?  C has been around a decade or more longer than C++,
plenty of time for a &quot;killer library&quot; to appear, but it hasn't.

My conclusion has to be that the demand isn't there.

By the way, does the C standard committee have an active library group?

--
Ian Collins.
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T17:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
André Gillibert wrote:
&gt; jacob navia wrote:

&gt;&gt; I tried to use the Glib, but then I was confronted with a HUGE package
&gt;&gt; that I would have to port everywhere and I could not control
&gt;&gt; at all.

&gt;&gt; It would be much better for everybody that we had a standard
&gt;&gt; interface like in C++ and then use a standard library!

&gt; In that case, you must expect that this HUGE package be bundled with
&gt; every C implementation... I hardly can see why C implementors would
&gt; produce better code than GNU's guys.
">

Because C's implementation should be SUBSTANTIALLY smaller,
giving just bare bones usage and not all the blat that comes
with the STL

Today at work I was with another coworker debugging a problem,
and when he loaded a C++ module he said:

Gosh this module uses the STL, and I can't stand it jacob. Nobody
knows exactly what the hell is doing!

I think we have a HUGE market there :-)

<QUOTE PREVIOUSPOST="
&gt; Actually, with C++'s STL, I've seen that most implementations have an
&gt; incredibely low QOI. Consequently, I've always to use an external
&gt; implementation (STLPort) which has far less bugs, and produces much
&gt; better code.

&gt; I don't see why the STL problem wouldn't be reproduced for C.
">

Because we would NOT redo the STL of course!

We need just a small set of operations and some generic functions.

<QUOTE PREVIOUSPOST="
&gt; Unfortunately, C doesn't support namespaces, so it's not easy to replace
&gt; the standard library with a different implementation.
">

There is no NEED for namespaces! We could just LINK with a different
implementation! The standard defines a C library, and you can
use different versions of the library and different implementations
just by relinking your code!

<QUOTE PREVIOUSPOST="
&gt; With the C++ STL experience I got, I think it's important to get the
&gt; standard library small, mainly containing components that cannot easily
&gt; and efficiently be implemented in pure standard C.
">

Yes. SMALL! Like C. And the point of is that SMALL is better in
software. Like smaller integrated circuits that are MORE efficient
than bulky ones, SMALL software components are more mangeable and
easy to understand and USE!!!!!!!

<QUOTE PREVIOUSPOST="
&gt; Otherwise, you're sure to get all the bloat with every C implementation.
&gt; Cross-compiler linking will result in linking issues or duplication of
&gt; the code bloat.
">

Why? It would be just another LIBRARY

<QUOTE PREVIOUSPOST="
&gt; --If you've a question that doesn't belong to Usenet, contact me at
&gt; &lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
">

A+
:-)

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T17:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; André Gillibert wrote:
&gt;&gt; every C implementation... I hardly can see why C implementors would
&gt;&gt; produce better code than GNU's guys.

&gt; Because C's implementation should be SUBSTANTIALLY smaller,
&gt; giving just bare bones usage and not all the blat that comes
&gt; with the STL
">

I wasn't comparing to STL but to GLib.

<QUOTE PREVIOUSPOST="
&gt; Because we would NOT redo the STL of course!
">

But we would redo a good part of GLib which you find huge.

<QUOTE PREVIOUSPOST="
&gt;&gt; Unfortunately, C doesn't support namespaces, so it's not easy to
&gt;&gt; replace the standard library with a different implementation.

&gt; There is no NEED for namespaces! We could just LINK with a different
&gt; implementation! The standard defines a C library, and you can
&gt; use different versions of the library and different implementations
&gt; just by relinking your code!
">

No, it doesn't work. I tried, but I never succeeded.
C implementations usually generate function importations to their
librairies.

e.g. when allocating a big array on stack on Win32, they may call a
function (whose name starts with two underscores or one underscore and a
upper-case letter) that touches the stack at every multiple of 4096 bytes.
Changing the standard library breaks that.
Startup code is also likely to call implementation-specific functions or
rely on implementation-specific details of standard library functions.

There are other issues: Implementations are allowed to recognize standard
library functions specially and to provide special optimizations for them
such as inlining. If stack_push is inlined, relying on a specific memory
layout for the stack object, and that stack_open links to another library,
then, bad bad things will occur.

<QUOTE PREVIOUSPOST="
&gt;&gt; With the C++ STL experience I got, I think it's important to get the
&gt;&gt; standard library small, mainly containing components that cannot easily
&gt;&gt; and efficiently be implemented in pure standard C.

&gt; Yes. SMALL! Like C. And the point of is that SMALL is better in
&gt; software. Like smaller integrated circuits that are MORE efficient
&gt; than bulky ones, SMALL software components are more mangeable and
&gt; easy to understand and USE!!!!!!!
">

Please, don't use more than one exclamation mark at once.
From Terry Pratchett's Masquerade:
| And all those exclamation marks, you notice? Five? A sure sign
| of someone who wears his underpants on his head.

<QUOTE PREVIOUSPOST="
&gt;&gt; Otherwise, you're sure to get all the bloat with every C implementation.
&gt;&gt; Cross-compiler linking will result in linking issues or duplication of
&gt;&gt; the code bloat.

&gt; Why? It would be just another LIBRARY
">

At least on Win32, most implementations don't share their standard
library, believe me.
Which means that, when linking an application or DLL compiled with
implementation A to a DLL compiled with implementation B, the final code
uses the libraries from both implementations, which, in average,
multiplies the library code bloat by a factor two. If the library is
small, it's acceptable. If it's large, it becomes less acceptable.

On other platforms, there's often a better cooperation.
--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T17:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
santosh wrote:
&gt; jacob navia wrote:

&gt; &lt;snip&gt;

&gt;&gt; Wouldn't it be a good idea to propose an STL clone?

&gt;&gt; It *can* be done in C!!!

&gt; Pure ISO C?
">

Yes.

--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> &quot;André Gillibert&quot; &lt;tabkanDELETETHIS...@yahodeletethato.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T17:58:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
santosh wrote:
&gt; user923005 wrote:

&gt;&gt; It would be really nice if C could adopt a really nice algorithms
&gt;&gt; library like C++'s STL + BOOST.

&gt; Without some changes to the language, how are we going to implement
&gt; generic algorithms and data structures? Yes void * is always there,
&gt; but that seems a messy and ugly solution.
">

It's the best solution C has to offer currently.
You may also read jacob navia's proposal about operator overloading and GC.

--
If you've a question that doesn't belong to Usenet, contact me at
&lt;tabkanDELETETHIS ... @yahoDELETETHATo.fr&gt;
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2007-10-03T17:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;santosh&quot; &lt;santosh. ... @gmail.com&gt; wrote in message
">

news:fe1141$jgq$2@aioe.org ...

<QUOTE PREVIOUSPOST="
&gt; jacob navia wrote:

&gt; &lt;snip&gt;

&gt;&gt; Wouldn't it be a good idea to propose an STL clone?

&gt;&gt; It *can* be done in C!!!

&gt; Pure ISO C?
">

You can devise a resizeable array that will store objects of any size.
The snag is that you need to call memcpy() or loop to perform basic
operations, when most of the time the objects in the array will be pointers,
ints, or something else held in a single register.

So in practise you hand code the array each time.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Douglas A. Gwyn wrote:
&gt; user923005 wrote:
&gt;&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt;&gt; dequeues, and other common, simple tool sets already in its standard
&gt;&gt; library?

&gt; C++ didn't have those either, initially.  They got tacked on
&gt; along the way as agreement was reached on them.

&gt; There are far fewer active workers on the C standard than have
&gt; been involved with C++, and no major incentive to spend any
&gt; significant fraction of the available resources working on
&gt; such libraries.  Note that the C standards group *has* worked
&gt; on several extensions, generally described in Technical
&gt; Reports, and adopted complex numbers (with library support)
&gt; into the C standard due to demand from the numerical
&gt; programming community.

&gt;&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt;&gt; programmers having to constantly reinvent the wheel?

&gt; You don't have to reinvent this wheel if you use an already-
&gt; developed library that provides what you need.  It just won't
&gt; be provided automatically with the C compiler, so you have to
&gt; arrange to obtain it separately.  I have my own library with
&gt; support for things like you mentioned, and other experienced
&gt; programmers and programming shops most likly do also.
">

The problem is that there isn't any that is standard.

Everybody has a slightly different one!

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> James Dennett &lt;jdenn...@acm.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
André Gillibert wrote:
&gt; jacob navia wrote:

&gt;&gt; There are several solutions to your &quot;problem&quot; of genericity.
&gt;&gt; The first one is the usage of the generic pointer in C: void *

&gt; At the cost of performances, but that's the cost of abstraction, anyway.
">

And yet the field of generic programming has been built for
years on a foundation of abstraction *not* costing performance,
which is to a large extent realized with C++'s STL and real
current compilers.

There is compile-time cost, but there's no need for runtime
cost for abstraction.

-- James
</POST>
<POST>
<POSTER> pete &lt;pfil...@mindspring.com&gt; </POSTER>
<POSTDATE> 2007-10-03T18:22:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
user923005 wrote:

&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.

&gt; The recent &quot;reverse the words in this sentence&quot; problem posted made me
&gt; think about it.
&gt; It's like 5 lines to do it in C++ because of all the nifty algorithms
&gt; that come with the language (I think BOOST is going to get bolted on
&gt; to the C++ language like STL did).

&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt; dequeues, and other common, simple tool sets already in its standard
&gt; library?

&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

Yes.

Why shouldn't C be more like C++?
Because there is C++.

--
pete
</POST>
<POST>
<POSTER> Eric Sosman &lt;Eric.Sos...@sun.com&gt; </POSTER>
<POSTDATE> 2007-10-03T18:30:00 </POSTDATE>
jacob navia wrote On 10/03/07 16:50,:

<QUOTE PREVIOUSPOST="
&gt; Eric Sosman wrote:

&gt;&gt;jacob navia wrote On 10/03/07 16:31,:

&gt;&gt;&gt;André Gillibert wrote:

&gt;&gt;&gt;&gt;Keeping the language small makes C different from C++, and that's why, C
&gt;&gt;&gt;&gt;can still be better than C++ for some projects.

&gt;&gt;&gt;This is an error. Keeping the language in this state makes the language
&gt;&gt;&gt;impossible to use for any serious software development
&gt;&gt;&gt;unless your project is big enough to warrant rewriting the
&gt;&gt;&gt;C library and adding stacks, lists, etc etc at each project!

&gt;&gt;    Since C is impossible to use for serious software
&gt;&gt;development, one wonders why so many programmers spent
&gt;&gt;so many years writing so much non-serious (comic?)
&gt;&gt;software.  Ritchie, Thompson, heck, even Torvalds have
&gt;&gt;just been clowning around, right?

&gt; Can't you read?
&gt; I cite this again then:

&gt;  &gt;&gt; unless your project is big enough to warrant rewriting the
&gt;  &gt;&gt; C library and adding stacks, lists, etc etc at each project!
">

So, you're saying that for every serious project they
did, Ritchie, Thompson, Torvalds et al. threw away and
rewrote the C library?

<QUOTE PREVIOUSPOST="
&gt; In my debugger project [...]
">

Is this the same debugger about which you said &quot;Without
[garbage collection], I would never have finished?&quot;

Let's see: You've already described C's lack of
operator overloading as evidence of neglect on the part of
the committee, you've characterized __declspec(naked) as
an important language feature you use &quot;very often,&quot; you've
railed at the absence of fixed-point arithmetic, ...  Is
there any feature, doodad, or dingbat you think *isn't*
essential to C's survival?

--
Eric.Sos ... @sun.com
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
André Gillibert wrote:
&gt; jacob navia wrote:

&gt;&gt; André Gillibert wrote:
&gt;&gt;&gt; every C implementation... I hardly can see why C implementors would
&gt;&gt;&gt; produce better code than GNU's guys.

&gt;&gt; Because C's implementation should be SUBSTANTIALLY smaller,
&gt;&gt; giving just bare bones usage and not all the blat that comes
&gt;&gt; with the STL

&gt; I wasn't comparing to STL but to GLib.

&gt;&gt; Because we would NOT redo the STL of course!

&gt; But we would redo a good part of GLib which you find huge.
">

No. The list module I wrote makes fir 2380 bytes of code
and 204 bytes of data. Maybe adding some overhead it *could* grow to
4-5K.

GNU software is bloated, but maybe the list module of the
glib can be trimmed to 4-5K.

<QUOTE PREVIOUSPOST="
&gt;&gt;&gt; Unfortunately, C doesn't support namespaces, so it's not easy to
&gt;&gt;&gt; replace the standard library with a different implementation.

&gt;&gt; There is no NEED for namespaces! We could just LINK with a different
&gt;&gt; implementation! The standard defines a C library, and you can
&gt;&gt; use different versions of the library and different implementations
&gt;&gt; just by relinking your code!

&gt; No, it doesn't work. I tried, but I never succeeded.
&gt; C implementations usually generate function importations to their
&gt; librairies.
">

Well, lcc-win32 *can* use the libc from the system, the libc from the
Microsoft compiler and probably the libc of GNU...

<QUOTE PREVIOUSPOST="
&gt; e.g. when allocating a big array on stack on Win32, they may call a
&gt; function (whose name starts with two underscores or one underscore and a
&gt; upper-case letter) that touches the stack at every multiple of 4096 bytes.
&gt; Changing the standard library breaks that.
">

No. If they are shared objects they just have a copy of the C runtime
with them anyway.

<QUOTE PREVIOUSPOST="
&gt; Startup code is also likely to call implementation-specific functions or
&gt; rely on implementation-specific details of standard library functions.
">

This is transparent in shared objects.

<QUOTE PREVIOUSPOST="
&gt; There are other issues: Implementations are allowed to recognize
&gt; standard library functions specially and to provide special
&gt; optimizations for them such as inlining. If stack_push is inlined,
&gt; relying on a specific memory layout for the stack object, and that
&gt; stack_open links to another library, then, bad bad things will occur.
">

I said:

Link with another library

I did not said:

Use two libraries for lists at the same time!

Note:
I used only ONE exclamation mark.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Eric Sosman wrote:
&gt; jacob navia wrote On 10/03/07 16:50,:
&gt;&gt; Eric Sosman wrote:

&gt;&gt;&gt; jacob navia wrote On 10/03/07 16:31,:

&gt;&gt;&gt;&gt; André Gillibert wrote:

&gt;&gt;&gt;&gt;&gt; Keeping the language small makes C different from C++, and that's why, C
&gt;&gt;&gt;&gt;&gt; can still be better than C++ for some projects.
&gt;&gt;&gt;&gt; This is an error. Keeping the language in this state makes the language
&gt;&gt;&gt;&gt; impossible to use for any serious software development
&gt;&gt;&gt;&gt; unless your project is big enough to warrant rewriting the
&gt;&gt;&gt;&gt; C library and adding stacks, lists, etc etc at each project!
&gt;&gt;&gt;    Since C is impossible to use for serious software
&gt;&gt;&gt; development, one wonders why so many programmers spent
&gt;&gt;&gt; so many years writing so much non-serious (comic?)
&gt;&gt;&gt; software.  Ritchie, Thompson, heck, even Torvalds have
&gt;&gt;&gt; just been clowning around, right?

&gt;&gt; Can't you read?
&gt;&gt; I cite this again then:

&gt;&gt;  &gt;&gt; unless your project is big enough to warrant rewriting the
&gt;&gt;  &gt;&gt; C library and adding stacks, lists, etc etc at each project!

&gt;     So, you're saying that for every serious project they
&gt; did, Ritchie, Thompson, Torvalds et al. threw away and
&gt; rewrote the C library?

&gt;&gt; In my debugger project [...]

&gt;     Is this the same debugger about which you said &quot;Without
&gt; [garbage collection], I would never have finished?&quot;

&gt;     Let's see: You've already described C's lack of
&gt; operator overloading as evidence of neglect on the part of
&gt; the committee,
">

You are misrepresenting everything since you do not want to argue
anymore, just polemic. I do have different opinions about things
here with many people. But I respect the work of the committee and
I have said that several times. I do not agree wit some decisions
and I have expressed my opinion. But I do not accuse anyone of
&quot;neglect&quot; (whatever that means in this context)

<QUOTE PREVIOUSPOST="
&gt; you've characterized __declspec(naked) as
&gt; an important language feature
">

Wrong again. I said here that using this low level interface
would be a bad idea, since after a discussion with people
here I saw my error. Contrary to some, I do respect the
arguments of other people and if they look convincing I
change my opinion and openly acknowledge that fact as I did
in this group.

<QUOTE PREVIOUSPOST="
&gt; you've
&gt; railed at the absence of fixed-point arithmetic, ...
">

No. I said that the TR that proposed modifications to the standard
would be better done if we give a general solution to the problem
of adding new numeric types.

<QUOTE PREVIOUSPOST="
&gt; Is
&gt; there any feature, doodad, or dingbat you think *isn't*
&gt; essential to C's survival?
">

You just want to polemic but you are doomed. To start a polemic
you need two. And you are only one.

Yours sincerely

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
James Dennett wrote:
&gt; André Gillibert wrote:
&gt;&gt; jacob navia wrote:

&gt;&gt;&gt; There are several solutions to your &quot;problem&quot; of genericity.
&gt;&gt;&gt; The first one is the usage of the generic pointer in C: void *
&gt;&gt; At the cost of performances, but that's the cost of abstraction, anyway.

&gt; And yet the field of generic programming has been built for
&gt; years on a foundation of abstraction *not* costing performance,
&gt; which is to a large extent realized with C++'s STL and real
&gt; current compilers.

&gt; There is compile-time cost, but there's no need for runtime
&gt; cost for abstraction.

&gt; -- James
">

C++ has good ideas. Generic programming is implemented there with
all the bells and whistles you can imagine. This is not the goal
here. The goal would be just a small interface description to
a small library that can represent a MINIMAL interface to lists
stacks, LIFOs hash tables and other commonly used data structures

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T18:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
pete wrote:

&gt; Why shouldn't C be more like C++?
&gt; Because there is C++.
">

Nobody is proposing that C should be &quot;more like C++&quot;.
The complexity of C++ is at best avoided.

But lists, stacks and hash tables aren't any
C++ invention as far as I remember. Why can't
the C language offer a common interface to use those
commonly used data structures?

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Flash Gordon &lt;s...@flash-gordon.me.uk&gt; </POSTER>
<POSTDATE> 2007-10-03T18:15:00 </POSTDATE>
jacob navia wrote, On 03/10/07 21:50:

<QUOTE PREVIOUSPOST="
&gt; Eric Sosman wrote:
&gt;&gt; jacob navia wrote On 10/03/07 16:31,:
&gt;&gt;&gt; André Gillibert wrote:

&gt;&gt;&gt;&gt; Keeping the language small makes C different from C++, and that's
&gt;&gt;&gt;&gt; why, C can still be better than C++ for some projects.

&gt;&gt;&gt; This is an error. Keeping the language in this state makes the language
&gt;&gt;&gt; impossible to use for any serious software development
&gt;&gt;&gt; unless your project is big enough to warrant rewriting the
&gt;&gt;&gt; C library and adding stacks, lists, etc etc at each project!

&gt;&gt;     Since C is impossible to use for serious software
&gt;&gt; development, one wonders why so many programmers spent
&gt;&gt; so many years writing so much non-serious (comic?)
&gt;&gt; software.  Ritchie, Thompson, heck, even Torvalds have
&gt;&gt; just been clowning around, right?

&gt; Can't you read?
&gt; I cite this again then:

&gt;  &gt;&gt; unless your project is big enough to warrant rewriting the
&gt;  &gt;&gt; C library and adding stacks, lists, etc etc at each project!
">

I'm using a linked list package that someone else wrote for something
completely different in order to proved a number of unrelated linked
lists in a library used by several other programs. Stragely enough I did
not have to rewrite the linked list module because it was designed to
provide a generic linked list.

<QUOTE PREVIOUSPOST="
&gt; In my debugger project there was obviously a list module

&gt; Then in the IDE too.

&gt; Then, in the compiler there is another one.

&gt; Then it seemed stupid to me at spent time making the debugger
&gt; use the IDE list package.
">

Then you should have spent a little longer the first or second time to
write one that was generic enough to be reused, or used some third party
library designed to be generic.

<QUOTE PREVIOUSPOST="
&gt; Yes, that happens. Not to you of course.
">

Well, it happens to me when using a completely different language. I
found that the linked list I wrote in Fortran &amp;&amp; on the VAX did not
compile as C and had unacceptable limitations (well, I would have done
if I had access to the code) but I certainly don't have to rewrite
simple generic code as often as you seem to have to.
--
Flash Gordon
</POST>
<POST>
<POSTER> Flash Gordon &lt;s...@flash-gordon.me.uk&gt; </POSTER>
<POSTDATE> 2007-10-03T18:18:00 </POSTDATE>
user923005 wrote, On 03/10/07 21:05:

<QUOTE PREVIOUSPOST="
&gt; It would be really nice if C could adopt a really nice algorithms
&gt; library like C++'s STL + BOOST.
">

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt; programmers having to constantly reinvent the wheel?
">

With modern linkers I would have no objection to it. After all, the
linker can just not link in the code if it is not used! Of course, there
might still be linkers around that are not that intelligent.
--
Flash Gordon
</POST>
<POST>
<POSTER> Keith Thompson &lt;ks...@mib.org&gt; </POSTER>
<POSTDATE> 2007-10-03T19:02:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt; Douglas A. Gwyn wrote:
&gt;&gt; user923005 wrote:
[...]
&gt;&gt;&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt;&gt;&gt; programmers having to constantly reinvent the wheel?
&gt;&gt; You don't have to reinvent this wheel if you use an already-
&gt;&gt; developed library that provides what you need.  It just won't
&gt;&gt; be provided automatically with the C compiler, so you have to
&gt;&gt; arrange to obtain it separately.  I have my own library with
&gt;&gt; support for things like you mentioned, and other experienced
&gt;&gt; programmers and programming shops most likly do also.

&gt; The problem is that there isn't any that is standard.

&gt; Everybody has a slightly different one!
">

Right, and you have to decide on a single solution *before* you can
add it to the standard.

I think glib attempts to be a general-purpose toolkit that might be
suitable for standardidization.  (I don't know enough about it to have
an opinion on whether it should be standardized.)  I suspect the
committee wouldn't agree to add a large library to the standard unless
there's at least some consensus on one particular interface.

And I strongly suspect that a library that depends on language
extensions provided by a single compiler wouldn't stand a chance.
You'd *first* have to persuade the committee to adopt the language
extensions.  (If the library is sufficiently useful, that might be an
argument in favor of adopting the language extensions.)

--
Keith Thompson (The_Other_Keith) ks ... @mib.org  &lt; http://www.ghoti.net/~kst &gt;
San Diego Supercomputer Center             &lt;*&gt;  &lt; http://users.sdsc.edu/~kst &gt;
&quot;We must do something.  This is something.  Therefore, we must do this.&quot;
-- Antony Jay and Jonathan Lynn, &quot;Yes Minister&quot;
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T19:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Keith Thompson wrote:
&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt;&gt; Douglas A. Gwyn wrote:
&gt;&gt;&gt; user923005 wrote:
&gt; [...]
&gt;&gt;&gt;&gt; Opinions?  Is keeping the language tiny worth the cost of C
&gt;&gt;&gt;&gt; programmers having to constantly reinvent the wheel?
&gt;&gt;&gt; You don't have to reinvent this wheel if you use an already-
&gt;&gt;&gt; developed library that provides what you need.  It just won't
&gt;&gt;&gt; be provided automatically with the C compiler, so you have to
&gt;&gt;&gt; arrange to obtain it separately.  I have my own library with
&gt;&gt;&gt; support for things like you mentioned, and other experienced
&gt;&gt;&gt; programmers and programming shops most likly do also.

&gt;&gt; The problem is that there isn't any that is standard.

&gt;&gt; Everybody has a slightly different one!

&gt; Right, and you have to decide on a single solution *before* you can
&gt; add it to the standard.

&gt; I think glib attempts to be a general-purpose toolkit that might be
&gt; suitable for standardidization.  (I don't know enough about it to have
&gt; an opinion on whether it should be standardized.)  I suspect the
&gt; committee wouldn't agree to add a large library to the standard unless
&gt; there's at least some consensus on one particular interface.

&gt; And I strongly suspect that a library that depends on language
&gt; extensions provided by a single compiler wouldn't stand a chance.
&gt; You'd *first* have to persuade the committee to adopt the language
&gt; extensions.  (If the library is sufficiently useful, that might be an
&gt; argument in favor of adopting the language extensions.)
">

Generic functions like
list = list_add(list,int);
list = list_add(list,double);
list = list_add(list,&amp;CustomerStruct);

would make the library very easy to use. Above all, they
could be extended by the user at any time with

list = list_add(list,&amp;MyNewDataStruct);

P.S. I will look at the glib again.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Keith Thompson &lt;ks...@mib.org&gt; </POSTER>
<POSTDATE> 2007-10-03T19:14:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt; André Gillibert wrote:
&gt;&gt; user923005 wrote:
[...]
&gt; There are several solutions to your &quot;problem&quot; of genericity.

&gt; The first one is the usage of the generic pointer in C: void *

&gt; I have written a dynamic table package using that approach. You tell
&gt; the software how big your objects are, and then you just use them.
&gt; Operator overloading allows you to assign and read the data.

&gt; True, the functions return a void pointer that must be casted into
&gt; something but that is a minor inconvenience.
">

You need to convert void* results to some specific pointer type, but
why would you need to cast them?

[...]

<QUOTE PREVIOUSPOST="
&gt;&gt;&gt; It's a lot more work in C than C++.  Why doesn't C have stacks,
&gt;&gt;&gt; dequeues, and other common, simple tool sets already in its standard
&gt;&gt;&gt; library?

&gt;&gt; Propose an implementable solution. Ideally, with several successful
&gt;&gt; real-world implementations.

&gt; I have done just that.
&gt; Only flames ensued.
">

You proposed operator overloading in an article posted to comp.std.c
on 2007-09-05, subject &quot;Operator overloading in C&quot;.  A lengthy
discussion ensued (Google Groups shows 143 articles in that thread).
In a cursory look through the thread, I see no flames, though I do see
a great deal of constructive criticism.  (Telling you &quot;I disagree, and
here's why&quot; is not a flame.)

However, I don't recall you ever proposing a library that provides
stacks and other common data structures.  Perhaps I missed it.

But you must be aware that if a proposed library depends on language
features that are not (yet) part of the standard, that's going to be a
considerable obstacle.

<QUOTE PREVIOUSPOST="
&gt;&gt; Then, we may consider your offer.

&gt; You can consider mine. It is working, it has an implementation,
&gt; why not looking at it?
">

Where is it?

(BTW, didn't you say recently that you were going to provide a freely
downloadable Linux version of your compiler?  Have you done so?)

--
Keith Thompson (The_Other_Keith) ks ... @mib.org  &lt; http://www.ghoti.net/~kst &gt;
San Diego Supercomputer Center             &lt;*&gt;  &lt; http://users.sdsc.edu/~kst &gt;
&quot;We must do something.  This is something.  Therefore, we must do this.&quot;
-- Antony Jay and Jonathan Lynn, &quot;Yes Minister&quot;
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T19:14:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:

&gt; But lists, stacks and hash tables aren't any
&gt; C++ invention as far as I remember. Why can't
&gt; the C language offer a common interface to use those
&gt; commonly used data structures?
">

Then how come after 30 odd years, it doesn't?

--
Ian Collins.
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T19:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Keith Thompson wrote:
&gt;&gt;&gt; Propose an implementable solution. Ideally, with several successful
&gt;&gt;&gt; real-world implementations.
&gt;&gt; I have done just that.
&gt;&gt; Only flames ensued.

&gt; You proposed operator overloading in an article posted to comp.std.c
&gt; on 2007-09-05, subject &quot;Operator overloading in C&quot;.  A lengthy
&gt; discussion ensued (Google Groups shows 143 articles in that thread).
&gt; In a cursory look through the thread, I see no flames, though I do see
&gt; a great deal of constructive criticism.  (Telling you &quot;I disagree, and
&gt; here's why&quot; is not a flame.)
">

Look Keith, you are aware of the enthusiastic reception of my ideas
by the c.lang.c &quot;regulars&quot; isn't it?

No, in comp.std.c the situation was much better but I do not
see how that is going to go on. Maybe everyone is just waiting that
I go away :-)

<QUOTE PREVIOUSPOST="
&gt; However, I don't recall you ever proposing a library that provides
&gt; stacks and other common data structures.  Perhaps I missed it.

&gt; Where is it?
">

http://www.q-software-solutions.de/~jacob/proposal.pdf

The same document that proposes the extensions proposes a library
using some of the new features.

Specially look at the string library. The others
use vtables and I think this leads to bad syntax unless there is yet
another extension. I think a better approach would be to use the
generic functions feature and use:

list = list_add(NULL,45);

list = list_add(list,644.887);

list = list_add(list,&quot;Customer Pierre Dupont and Annie Gonzalez&quot;);

To access it we would use

#define list_get(list,index, type) *(type *)(list-&gt;Data[index]);

or similar.

<QUOTE PREVIOUSPOST="
&gt; (BTW, didn't you say recently that you were going to provide a freely
&gt; downloadable Linux version of your compiler?  Have you done so?)
">

Yes, I did it and you can download it from
http://www.q-software-solutions.de/products/lcc-linux32/index.shtml

Please be patient. I have worked a lot in it but it still has a lot of
rough edges. All extensions should be working except
__try/__except.

I think I will be using wine's implementation of that as a guide.

But use the windows version, it is more tested. In august, the windows
version went over the *half million* downloads mark!

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Chris McDonald &lt;ch...@csse.uwa.edu.au&gt; </POSTER>
<POSTDATE> 2007-10-03T20:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt;Generic functions like
&gt;list = list_add(list,int);
&gt;list = list_add(list,double);
&gt;list = list_add(list,&amp;CustomerStruct);
&gt;would make the library very easy to use. Above all, they
&gt;could be extended by the user at any time with
">

Could you please clarify these?

Did you mean to add at the head, or at the tail, or somewhere in the
middle, that the list remain sorted by some user-specified sorting
function, and should duplicates be permitted or removed?

Oh, never mind, I'll just write the 10 line function that I need and
understand.

--
Chris.
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:05:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ian Collins wrote:
&gt; jacob navia wrote:
&gt;&gt; But lists, stacks and hash tables aren't any
&gt;&gt; C++ invention as far as I remember. Why can't
&gt;&gt; the C language offer a common interface to use those
&gt;&gt; commonly used data structures?

&gt; Then how come after 30 odd years, it doesn't?
">

Because C++ started to grow as &quot;the better C&quot; and
C was thrown into the bin &quot;old and obsolete&quot;.

Dozens of C++ books were written that as a matter of habit wrote
in their &quot;Introduction to C++&quot; how BAD the C language was, and
how WONDERFUL the new language was, compared to that OLD C, etc.

The C community reacted with a tendency to look into the past,
and it &quot;enshrined&quot; their language resisting any change
of it at all. C99 was the result: a standard that makes
small improvements (VLAs, complex numbers, and others)
but leaves the mess of the very old C library design intact.

The C++ guys just laughed at it, and gcc and Microsoft decided
to just drop C. Gcc hasn't still 8 years later finished the
C99 implementation, they do not participate into any standard
body (even if they could). Microsoft has participated in some
proposals (the safer C Technical Report) but in fact has
dropped C as a development language too.

C is then seen as an old and obsolete language by most
programmers. Its main use should be in small circuit
boards where there is no space for a language like
C++. When those circuit boards disappear, C will disappear
with them. It will remain (like COBOL) in a frozen state
for the biggest part of this century as the software
written in C is slowly rewritten in other, more
modern languages.

So the story goes.

But I think that C, *precisely* because of its small size, it
is *better* adapted for the software of the future. Yes, I have
proposed some changes to the syntax, fairly minor. They are
essentially:

o operator overloading
o generic functions

This would allow to write a small standard library that would
allow people to use higher level data structures with easy
within a common framework.

What is crucial is that the library has a small memory footprint.
Not in RAM of course, but in HUMAN memory footprint. This means that
the library is easy to remember and use, that it has a consistent
naming, and that it is kept as simple as possible.

Software has a tendency to bloat forever. But in software (as in
hardware) smaller means more efficient and less wasteful. Many
languages have started that try to be simpler than C++. But
there is NO need to go very far. C has retained its simplicity
and is well adapted to the future precisely because it is
small.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Keith Thompson &lt;ks...@mib.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt; pete wrote:
&gt;&gt; Why shouldn't C be more like C++? Because there is C++.

&gt; Nobody is proposing that C should be &quot;more like C++&quot;.
">

[...]

Sure you are.

You're not proposing that C should be just like C++, but you're
certainly proposing that it should be closer to C++ than it is now.
(I'm not saying that's necessarily a bad thing.)

--
Keith Thompson (The_Other_Keith) ks ... @mib.org  &lt; http://www.ghoti.net/~kst &gt;
San Diego Supercomputer Center             &lt;*&gt;  &lt; http://users.sdsc.edu/~kst &gt;
&quot;We must do something.  This is something.  Therefore, we must do this.&quot;
-- Antony Jay and Jonathan Lynn, &quot;Yes Minister&quot;
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Chris McDonald wrote:
&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:

&gt;&gt; Generic functions like
&gt;&gt; list = list_add(list,int);
&gt;&gt; list = list_add(list,double);
&gt;&gt; list = list_add(list,&amp;CustomerStruct);

&gt;&gt; would make the library very easy to use. Above all, they
&gt;&gt; could be extended by the user at any time with

&gt; Could you please clarify these?

&gt; Did you mean to add at the head, or at the tail,
">

At the tail

or somewhere in the

<QUOTE PREVIOUSPOST="
&gt; middle,
">

that would be

list_insert

that the list remain sorted by some user-specified sorting

<QUOTE PREVIOUSPOST="
&gt; function,
">

that would be

list_add_sorted

and should duplicates be permitted or removed?

A set of flags can be specified at list creation as
to how to insert things (with or without duplicates,
set/unset a sorting function that defaults to memcmp
and some options) but basically you need just little
of all that.

<QUOTE PREVIOUSPOST="
&gt; Oh, never mind, I'll just write the 10 line function that I need and
&gt; understand.
">

10 lines for the specs you yourself specified above?

I am giving just examples of generic functions that could be
used to

list_add
vector_add
hash_add

giving a generic, easy to remember interface. That was my point.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Chris McDonald &lt;ch...@csse.uwa.edu.au&gt; </POSTER>
<POSTDATE> 2007-10-03T20:16:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt;Chris McDonald wrote:
&gt;&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:

&gt;&gt;&gt; Generic functions like
&gt;&gt;&gt; list = list_add(list,int);
&gt;&gt;&gt; list = list_add(list,double);
&gt;&gt;&gt; list = list_add(list,&amp;CustomerStruct);

&gt;&gt;&gt; would make the library very easy to use. Above all, they
&gt;&gt;&gt; could be extended by the user at any time with

&gt;&gt; Could you please clarify these?

&gt;&gt; Did you mean to add at the head, or at the tail,
&gt;At the tail
">

Ohhh, so you don't mean 'list', you mean 'queue'?

Gee, this agreement can be tricky can't it?

--
Chris.
</POST>
<POST>
<POSTER> Keith Thompson &lt;ks...@mib.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
">

[...]

<QUOTE PREVIOUSPOST="
&gt; Generic functions like
&gt; list = list_add(list,int);
&gt; list = list_add(list,double);
&gt; list = list_add(list,&amp;CustomerStruct);

&gt; would make the library very easy to use. Above all, they
&gt; could be extended by the user at any time with

&gt; list = list_add(list,&amp;MyNewDataStruct);

&gt; P.S. I will look at the glib again.
">

Ok, but C doesn't have generic functions, and you can't write a
function that takes either an int, a double, or a pointer as its
second argument.

What exactly are you proposing?

--
Keith Thompson (The_Other_Keith) ks ... @mib.org  &lt; http://www.ghoti.net/~kst &gt;
San Diego Supercomputer Center             &lt;*&gt;  &lt; http://users.sdsc.edu/~kst &gt;
&quot;We must do something.  This is something.  Therefore, we must do this.&quot;
-- Antony Jay and Jonathan Lynn, &quot;Yes Minister&quot;
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:18:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Keith Thompson wrote:
&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt;&gt; pete wrote:
&gt;&gt;&gt; Why shouldn't C be more like C++? Because there is C++.
&gt;&gt; Nobody is proposing that C should be &quot;more like C++&quot;.
&gt; [...]

&gt; Sure you are.

&gt; You're not proposing that C should be just like C++, but you're
&gt; certainly proposing that it should be closer to C++ than it is now.
&gt; (I'm not saying that's necessarily a bad thing.)
">

In the surface yes.

Operator overloading exists in many other languages than C++.
Fortran, Visual Basic, C#... many.

Overloaded functions that dispatch according to the type of the
arguments exist in other languages too.

But even if I use the same syntax, the simplicity of the language
is preserved. That's why I was completely opposed to introducing
constructors for instance, remember?

This limited set of changes makes the language more easy to
use (syntax sugar makes coffee easier to drink ) without changing
any of its fundamental concepts.

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> jacob navia &lt;ja...@nospam.org&gt; </POSTER>
<POSTDATE> 2007-10-03T20:22:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Chris McDonald wrote:
&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:

&gt;&gt; Chris McDonald wrote:
&gt;&gt;&gt; jacob navia &lt;ja ... @nospam.org&gt; writes:

&gt;&gt;&gt;&gt; Generic functions like
&gt;&gt;&gt;&gt; list = list_add(list,int);
&gt;&gt;&gt;&gt; list = list_add(list,double);
&gt;&gt;&gt;&gt; list = list_add(list,&amp;CustomerStruct);
&gt;&gt;&gt;&gt; would make the library very easy to use. Above all, they
&gt;&gt;&gt;&gt; could be extended by the user at any time with

&gt;&gt;&gt; Could you please clarify these?

&gt;&gt;&gt; Did you mean to add at the head, or at the tail,

&gt;&gt; At the tail

&gt; Ohhh, so you don't mean 'list', you mean 'queue'?

&gt; Gee, this agreement can be tricky can't it?
">

Lists (as you probably know) can be used to implement
other data structures.

A stack can be implemented with a list. Is it a stack or a list?

If you want to discuss, go ahead. But if you just
want to prove that you know more of the subject and are much clever
than me...

PLEASE bring YOUR proposal

:-)

--
jacob navia
jacob at jacob point remcomp point fr
logiciels/informatique
http://www.cs.virginia.edu/~lcc-win32
</POST>
<POST>
<POSTER> Chris McDonald &lt;ch...@csse.uwa.edu.au&gt; </POSTER>
<POSTDATE> 2007-10-03T20:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt;.... But if you just
&gt;want to prove that you know more of the subject and are much clever
&gt;than me...
">

No, I'll leave that to the many others here.

I had better not troll the troll.

--
Chris.
</POST>
<POST>
<POSTER> Keith Thompson &lt;ks...@mib.org&gt; </POSTER>
<POSTDATE> 2007-10-03T21:05:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia &lt;ja ... @nospam.org&gt; writes:
&gt; Keith Thompson wrote:
&gt;&gt;&gt;&gt; Propose an implementable solution. Ideally, with several successful
&gt;&gt;&gt;&gt; real-world implementations.
&gt;&gt;&gt; I have done just that.
&gt;&gt;&gt; Only flames ensued.
&gt;&gt; You proposed operator overloading in an article posted to comp.std.c
&gt;&gt; on 2007-09-05, subject &quot;Operator overloading in C&quot;.  A lengthy
&gt;&gt; discussion ensued (Google Groups shows 143 articles in that thread).
&gt;&gt; In a cursory look through the thread, I see no flames, though I do see
&gt;&gt; a great deal of constructive criticism.  (Telling you &quot;I disagree, and
&gt;&gt; here's why&quot; is not a flame.)

&gt; Look Keith, you are aware of the enthusiastic reception of my ideas
&gt; by the c.lang.c &quot;regulars&quot; isn't it?

&gt; No, in comp.std.c the situation was much better but I do not
&gt; see how that is going to go on. Maybe everyone is just waiting that
&gt; I go away :-)
">

[...]

You might have better luck if you concentrated on discussing your
ideas rather than complaining about people's reactions to them.

You made your proposal in comp.std.c.  You claimed above that &quot;Only
flames ensued&quot;; that just isn't true.

--
Keith Thompson (The_Other_Keith) ks ... @mib.org  &lt; http://www.ghoti.net/~kst &gt;
San Diego Supercomputer Center             &lt;*&gt;  &lt; http://users.sdsc.edu/~kst &gt;
&quot;We must do something.  This is something.  Therefore, we must do this.&quot;
-- Antony Jay and Jonathan Lynn, &quot;Yes Minister&quot;
</POST>
<POST>
<POSTER> Eric Sosman &lt;esos...@ieee-dot-org.invalid&gt; </POSTER>
<POSTDATE> 2007-10-03T22:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; Eric Sosman wrote:
&gt;&gt; [...]
&gt;&gt;     Let's see: You've already described C's lack of
&gt;&gt; operator overloading as evidence of neglect on the part of
&gt;&gt; the committee,

&gt; You are misrepresenting everything since you do not want to argue
&gt; anymore, just polemic. I do have different opinions about things
&gt; here with many people. But I respect the work of the committee and
&gt; I have said that several times. I do not agree wit some decisions
&gt; and I have expressed my opinion. But I do not accuse anyone of
&gt; &quot;neglect&quot; (whatever that means in this context)
">

&quot;I do not accuse&quot; is present tense, and it's true: after
several people castigated you and after a few attempts to deny
that you'd done such a thing, you amended your proposal to
remove the offending language.  But the moving finger writes,
and the memory lingers.

<QUOTE PREVIOUSPOST="
&gt;&gt; you've characterized __declspec(naked) as
&gt;&gt; an important language feature

&gt; Wrong again.
">

So, Google not only has a bad Usenet interface, but they
(or someone) are actively making forged posts under your name?
Go to google.groups.com, navigate to comp.lang.c, search for
__declspec, sort by date, and there you have it:

&gt;&gt;&gt; [...] It is interesting that this
&gt;&gt;&gt; document mentions almost all the __declspec constructs but
&gt;&gt;&gt; doesn't mention one I considered important and use very often:
&gt;&gt;&gt;
&gt;&gt;&gt; __declspec(naked)

The supposed date of this post is September 21, within living
memory.  Is it a defamatory forgery?  Will you take legal action?
Google Groups also displays a September 6 post in which someone
claiming to be you describes removing the &quot;neglected&quot; language;
is that, too, a forgery?  Are the black helicopters hovering?

A young cousin of mine once forgot, as children will, some
simple instruction he'd been given.  His exasperated parent
berated him for his terrible memory.  &quot;But,&quot; said the lad, &quot;I
have a very good forgettory!&quot;  A convenient ability, I guess.

--
Eric Sosman
esos ... @ieee-dot-org.invalid
</POST>
<POST>
<POSTER> Eric Sosman &lt;esos...@ieee-dot-org.invalid&gt; </POSTER>
<POSTDATE> 2007-10-03T22:39:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; pete wrote:

&gt;&gt; Why shouldn't C be more like C++? Because there is C++.

&gt; Nobody is proposing that C should be &quot;more like C++&quot;.
&gt; The complexity of C++ is at best avoided.
">

... says the proponent of operator overloading, generic
functions, and garbage collection.

&quot;The true test of a first-rate mind is the ability to
hold two contradictory ideas at the same time.&quot; -- F.S.F.

--
Eric Sosman
esos ... @ieee-dot-org.invalid
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T23:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jacob navia wrote:
&gt; Ian Collins wrote:
&gt;&gt; jacob navia wrote:
&gt;&gt;&gt; But lists, stacks and hash tables aren't any
&gt;&gt;&gt; C++ invention as far as I remember. Why can't
&gt;&gt;&gt; the C language offer a common interface to use those
&gt;&gt;&gt; commonly used data structures?

&gt;&gt; Then how come after 30 odd years, it doesn't?

&gt; Because C++ started to grow as &quot;the better C&quot; and
&gt; C was thrown into the bin &quot;old and obsolete&quot;.

&gt; Dozens of C++ books were written that as a matter of habit wrote
&gt; in their &quot;Introduction to C++&quot; how BAD the C language was, and
&gt; how WONDERFUL the new language was, compared to that OLD C, etc.

&gt; The C community reacted with a tendency to look into the past,
&gt; and it &quot;enshrined&quot; their language resisting any change
&gt; of it at all. C99 was the result: a standard that makes
&gt; small improvements (VLAs, complex numbers, and others)
&gt; but leaves the mess of the very old C library design intact.
">

The lack of library update is C99 probably reflect the lack of de facto
or even popular extensions.

<QUOTE PREVIOUSPOST="
&gt; Software has a tendency to bloat forever. But in software (as in
&gt; hardware) smaller means more efficient and less wasteful.
">

The size of the language isn't necessarily reflected in the size of the
resulting executable.

--
Ian Collins.
</POST>
</TEXT>
</BODY>
</DOC>
