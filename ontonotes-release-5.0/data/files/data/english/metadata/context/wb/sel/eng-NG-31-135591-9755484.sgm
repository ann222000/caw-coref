<DOC>
<DOCID> eng-NG-31-135591-9755484 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-09-23T22:50:00 </DATETIME>
<BODY>
<HEADLINE>
This is why Ruby 1.8.6 can never be made to run anywhere near as fast as Python 2.5.1
</HEADLINE>
<TEXT>
<POST>
<POSTER> Ruby Maniac &lt;raych...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-09-23T22:50:00 </POSTDATE>
I welcome any corrections anyone might be able to make since I am new
to Ruby with less than 3 months experience under my belt.

Ruby 1.8.6 is an interpreted langauge that does not have a byte-code
driven VM at this time.

Python 2.5.1 is an interpreted language that does have a byte-code
driven VM.

I have been able to make Ruby code run 5% faster or more simply by
removing nothing but comments - the more comments I remove the faster
the code runs up to no more than 6% or 7%.

Ruby syntax seems to favor the notion that fewer characters is better
than more characters.  Lexically interpreted langauges would want this
to be the case since it takes more effort to lex more characters.

Python runtimes are not affected by the number of characters one uses
such as extra whitespace or comments - removing comments does not make
Python code run faster simply because the comments have been removed.

Python has a very powerful JIT (Just In Time compiler) known as Psyco
with which certain Python expressions such as LC (List Comprehensions)
and others can be made to run 20x to 100x faster at runtime.

Recently as a test I wrote a rather simple Python program that
processed all characters of a 20 MB file by setting the MSB to 1. The
original Python code I began with executed in 65 seconds before I
began to optimize the code.  After the code was fully optimized it ran
in just under 3 secs. After Psyco was used the runtime for the same
problem was less than 1 second.

The Ruby code I wrote before any optimizations were applied ran in
about 65 seconds or no faster than Python with no optimizations.  The
most optimized Ruby code I could find for this problem was able to
execute in just under 22 seconds using techniques that were not
necessary when optimizing the Python code.

Given the best Ruby is capable of doing versus the best Python is
capable of doing Ruby ends up being more than 20x slower than Python
and I think I know why.

It is just not possible to make Ruby 1.8.6 execute any faster than the
Ruby interpreter is capable of executing the code due to the lack of a
byte-code driven VM.  Maybe someday YARV will make Ruby code run 2x
faster than Ruby 1.8.6 but that day has not arrived yet and may never
arrived.

Even if YARV proves to be 2x faster than Ruby 1.8.6 the resulting Ruby
code will still be 10x slower than the fastest Python code.

The only way YARV will get faster than Python is whenever someone
codes a JIT compiler for YARV that provides the same performance boost
to Ruby that Psyco provides to Python.  As far as I can tell nobody is
working on any such JIT for YARV and since YARV has been under
development for at least the last 14 to 18 months one can only surmise
a JIT for YARV would take a significant amount of time to produce and
release to the Ruby community.

The bottom line is that Python can be made to run as fast as machine
code but Ruby cannot.

I know some people want to try to use Ruby for every single problem
they are faced with but doing so would be less than wise since there
are no tools that work for all problems.

Some problems lend themselves nicely to Ruby such as Open Source
products where giving away the source code is not a business
problem.

Python is useful for problems that require fast runtimes such as 3D
modelling or video game programming.

Ruby would not be fast enough for the kinds of problems where people
are using Python.

I have not been able to find any references to Ruby being used for 3D
realtime video game programming but I have been able to find many
references to Python being used for 3D realtime video game
programming.

I don't expect those who read this to applaud my efforts to discuss
this in this forum however I feel we need to discuss this so that some
may choose to take actions to make Ruby run faster at runtime just as
work was done to make Python run faster at runtime.

Believe it or not I actually like Ruby 1.8.6 but I would hesitate to
try to use Ruby for situations where runtime performance was an issue
or whenever I did not want to release the source code.

When I write code I want to know I am using tools that give me the
best performance for the effort that I can possibly get as opposed to
tools that guarantee no matter how hard I work performance will always
be lacking.

The same comments could be made about Rails.  Rails emits SQL
statements that have a lot of &quot;*&quot; characters.  Those of us who have
been coding SQL long enough know the use of &quot;*&quot; characters makes SQL
statements run slower than when fully qualified column names are used
rather than the &quot;*&quot;.  I coded a simple benchmark that demonstrated
this very clearly; whenever &quot;*&quot; was used rather than a list of column
names the resulting SQL statements ran 10% to 880% slower than when
the &quot;*&quot; was replaced with a list of column names even when the list of
column names was quite long.

Oddly enough I quite easily found more powerful Database Frameworks
for Python that did not emit SQL code that used &quot;*&quot; characters and I
was even able to find some interfaces for those SQL Frameworks that
would allow seasonsed Rails developers use Rails statements when
describing their database relationships.

I know of some Ruby developers who rejected the idea that the use of
&quot;*&quot; in SQL statements would be slower than long lists of column
names.  From the perspective of a Ruby on Rails developer who has not
coded anything but Rails or Ruby it might seem logical that fewer
characters is better than more characters and so the use of &quot;*&quot; in SQL
statements must be optimial because this is how Ruby works, right ?!?
Wrong !

Even when some RoR developers are faced with benchmarks that
demonstrate the use of &quot;*&quot; in SQL statements can be 10% to 880% slower
than not using &quot;*&quot; characters they still chose to reject the
benchmarks and deny the benefits of not using Rails because Rails is
not able to automatically replace &quot;*&quot; with lists of column names,
apparently.

When people choose to make their choices of languages a religious
issue they can become rather short-sighted in how they choose to
resolve programming problems.

I prefer to be agnostic about programming languages.  I choose those
that perform the best and I ignore the rest.

Ruby is a cute language that may someday become useful but this won't
happen unless the Ruby community becomes interested in making Ruby
perform better at runtime.  In the meantime, I will use Ruby only when
I must as for the rest I will most-likely use Python unless the
problem suggests another language may be more useful.
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-23T23:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ruby Maniac wrote:
&gt; Even if YARV proves to be 2x faster than Ruby 1.8.6 the resulting Ruby
&gt; code will still be 10x slower than the fastest Python code.
">

Care to bet on that? I just benchmarked &quot;YARV&quot; at something like 5X Ruby
1.8.6, with some bursts as high as 72X!
</POST>
<POST>
<POSTER> &quot;Wilson Bilkovich&quot; &lt;wils...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-23T23:10:00 </POSTDATE>
On 9/23/07, Ruby Maniac &lt;raych ... @hotmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I welcome any corrections anyone might be able to make since I am new
&gt; to Ruby with less than 3 months experience under my belt.
">

I'm not going to address any of your Rails comments, because they have
nothing to do with Ruby. Rails is just a library.

Python is not faster than Ruby due to language design, but because
skilled people got together and made it faster. Nothing is stopping
people from doing the same for Ruby.

Some corrections:
1. YARV is 'out', in the form of Ruby 1.9. A stable release is coming
in a matter of months.

2. JIT is nice, but it is not a panacea. C and C++ are plenty fast,
and use AOT compilation, not JIT. Java has shown that a combination of
AOT and JIT can  yield impressive performance, but Psyco is merely one
approach out of many.

3. YARV has some (unfinished) competition with significantly varying approaches:
* JRuby: The trunk version offers compilation as well as
interpretation. At some point it will almost certainly support fancy
JIT tricks, given its architecture. http://jruby.codehaus.org/
* Rubinius: Currently supports 'only' AOT compilation to bytecode.
When it is done, we will be doing much more sophisticated things, a la
Pepsi/Coke/J3. http://rubini.us/
* IronRuby: I don't know enough about their architecture to say, but
they will probably bring some impressive performance to the table as
well.

Please don't judge Ruby the language by looking at the current 1.8
implementation. They are not the same thing, and the limitations of
1.8 are not necessarily invariant constraints.

On the other hand, I'm probably wasting my time with this reply.
Calling Ruby a &quot;cute&quot; language means you are almost certainly a troll.
Please forgive me if I am wrong about this.
</POST>
<POST>
<POSTER> &quot;Bill Kelly&quot; &lt;bi...@cts.com&gt; </POSTER>
<POSTDATE> 2007-09-23T23:37:00 </POSTDATE>
From: &quot;Ruby Maniac&quot; &lt;raych ... @hotmail.com&gt;

<QUOTE PREVIOUSPOST="
&gt; I prefer to be agnostic about programming languages.  I choose those
&gt; that perform the best and I ignore the rest.
">

That's agnosticism?  Sounds like a sermon from the Church
of Premature Optimization.  &lt;grin&gt;

Kidding aside, that's great that you know what you want from
a programming language.

Many of us know what we want, too.

I accept that Ruby is slow to execute (although getting faster).
It's more important to me that Ruby is fun and productive to
program in, and that Ruby is merely _fast enough_ for the task
at hand.

I've dabbled in a number of languages, but I've written actual
production code in assembler, Forth, C, C++, Objective-C, Java,
Perl, Python, Ruby, and (kill me now) VB6.

If one took your &quot;choose those that perform the best and ignore
the rest&quot; razor literally, one would assume you would choose to
write only hand-tuned assembly.

Have you written much hand-tuned assembler lately?  No?  Neither
have I.

Fifteen to twenty years ago, it was still common for many video
games to be coded entirely in assembler.  Myself, I preferred
to write as much as possible in C, and drop down to assembler
only when necessary.

Today, it's really the same equation.  I write as much in Ruby
as possible, but drop down to C when needed.

Obviously, the faster Ruby gets, the better.  But again, many
of us have been programming in Ruby for years, not because we
don't know half a dozen faster languages, but because we like
programming in Ruby, and find it fast enough for most of our
needs.  And if some method needs to go way faster, there's
always C.

Regards,

Bill
</POST>
<POST>
<POSTER> Phrogz &lt;phr...@mac.com&gt; </POSTER>
<POSTDATE> 2007-09-24T00:13:00 </POSTDATE>
On Sep 23, 8:50 pm, Ruby Maniac &lt;raych ... @hotmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Ruby is a cute language that may someday become useful but this won't
&gt; happen unless the Ruby community becomes interested in making Ruby
&gt; perform better at runtime.
">

To be clear, it may someday become useful *to you*; it's already
useful to me.

<QUOTE PREVIOUSPOST="
&gt; In the meantime, I will use Ruby only when
&gt; I must as for the rest I will most-likely use Python unless the
&gt; problem suggests another language may be more useful.
">

I'd be interested to know under what circumstance(s) you expect to be,
or already are, forced to use Ruby. (Developing RoR sites in a team
environment?)
</POST>
<POST>
<POSTER> John Joyce &lt;dangerwillrobinsondan...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T01:05:00 </POSTDATE>
Why do people troll?
What pleasure could it bring?
</POST>
<POST>
<POSTER> &quot;Michael T. Richter&quot; &lt;ttmrich...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T01:12:00 </POSTDATE>
Can I ask why *ANYBODY* took a message by someone calling themselves
&quot;Ruby Maniac&quot; and using expressions like &quot;cute language&quot; as anything but
a troll?  Anybody?  Anybody?  Bueller?

Don't dignify these kinds of things with responses, peeps.

--
Michael T. Richter &lt;ttmrich ... @gmail.com&gt; (GoogleTalk:
ttmrich ... @gmail.com)
Never, ever, ever let systems-level engineers do human interaction
design unless they have displayed a proven secondary talent in that
area. Their opinion of what represents good human-computer interaction
tends to be a bit off-track. (Bruce Tognazzini)

signature.asc
1K Download
</POST>
<POST>
<POSTER> Mohit Sindhwani &lt;mo_m...@onghu.com&gt; </POSTER>
<POSTDATE> 2007-09-24T01:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Joyce wrote:
&gt; Why do people troll?
&gt; What pleasure could it bring?
">

Fear, uncertainty and doubt - that's what drives people!

Cheers,
Mohit.
9/24/2007 | 1:25 PM.
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-24T01:26:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Michael T. Richter wrote:
&gt; Can I ask why *ANYBODY* took a message by someone calling themselves
&gt; &quot;Ruby Maniac&quot; and using expressions like &quot;cute language&quot; as anything but
&gt; a troll?  Anybody?  Anybody?  Bueller?

&gt; Don't dignify these kinds of things with responses, peeps.
">

Well ... yes ... I suppose if I hadn't just run the benchmarks and
posted the results, I wouldn't have responded. But I am so thrilled to
see that 5X number for &quot;YARV&quot;. Is there anyone here who thinks they can
get a 5X boost for Python 2.5? Perl 5.8.8? PHP 5?
</POST>
<POST>
<POSTER> &quot;Michael T. Richter&quot; &lt;ttmrich...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T01:44:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Mon, 2007-24-09 at 14:05 +0900, John Joyce wrote:
&gt; Why do people troll?
&gt; What pleasure could it bring?
">

Control.  People whose daily lives have little in the way of things they
have control over like the illusion that upsetting other people and
having them react is like controlling their own lives.

--
Michael T. Richter &lt;ttmrich ... @gmail.com&gt; (GoogleTalk:
ttmrich ... @gmail.com)
We should sell bloat credits, the way the government sells pollution
credits. Everybody's assigned a certain amount of bloat, and if they go
over, they have to purchase bloat credits from some other group that's
been more careful. (Bent Hagemark)

signature.asc
1K Download
</POST>
<POST>
<POSTER> &quot;Michael T. Richter&quot; &lt;ttmrich...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T01:49:00 </POSTDATE>
On Mon, 2007-24-09 at 14:26 +0900, M. Edward (Ed) Borasky wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; Can I ask why *ANYBODY* took a message by someone calling themselves
&gt; &gt; &quot;Ruby Maniac&quot; and using expressions like &quot;cute language&quot; as anything but
&gt; &gt; a troll?  Anybody?  Anybody?  Bueller?
&gt; &gt; Don't dignify these kinds of things with responses, peeps.
&gt; Well ... yes ... I suppose if I hadn't just run the benchmarks and
&gt; posted the results, I wouldn't have responded. But I am so thrilled to
&gt; see that 5X number for &quot;YARV&quot;. Is there anyone here who thinks they can
&gt; get a 5X boost for Python 2.5? Perl 5.8.8? PHP 5?
">

You're still playing into their game.  You're reacting to the troll's
input.  If you want to share the good news about YARV performance, start
your own breathless thread.  Don't respond to a troll.  ESPECIALLY don't
quote the troll and do a point-by-point counter.  That's exactly what
they're looking for.

Let me give you a little secret: the troll knows all your countering
arguments.  In another forum, under a different name, the troll is using
those very same arguments to tweak the noses of other people and make
them &quot;dance to his strings&quot;.  The only winning move, as the old movie
goes, is not to play the game.

--
Michael T. Richter &lt;ttmrich ... @gmail.com&gt; (GoogleTalk:
ttmrich ... @gmail.com)
When debugging, novices insert corrective code; experts remove defective
code. (Richard Pattis)

signature.asc
1K Download
</POST>
<POST>
<POSTER> Eric Hodel &lt;drbr...@segment7.net&gt; </POSTER>
<POSTDATE> 2007-09-24T01:59:00 </POSTDATE>
On Sep 23, 2007, at 19:55 , Ruby Maniac wrote:

<QUOTE PREVIOUSPOST="
&gt; I welcome any corrections anyone might be able to make since I am new
&gt; to Ruby with less than 3 months experience under my belt.

&gt; Ruby 1.8.6 is an interpreted langauge that does not have a byte-code
&gt; driven VM at this time.

&gt; Python 2.5.1 is an interpreted language that does have a byte-code
&gt; driven VM.

&gt; I have been able to make Ruby code run 5% faster or more simply by
&gt; removing nothing but comments - the more comments I remove the faster
&gt; the code runs up to no more than 6% or 7%.
">

Then you aren't benchmarking with enough iterations.  Comments are
skipped and thrown away.  They aren't part of the AST.

<QUOTE PREVIOUSPOST="
&gt; [...] Lexically interpreted langauges would want this
&gt; to be the case since it takes more effort to lex more characters.
">

And you only lex a file once in Ruby.  As a proportion of runtime,
turning a source file into an AST is small.

<QUOTE PREVIOUSPOST="
&gt; Python runtimes are not affected by the number of characters one uses
&gt; such as extra whitespace or comments
">

Nor are Ruby's.

<QUOTE PREVIOUSPOST="
&gt; - removing comments does not make Python code run faster simply
&gt; because the comments have been removed.
">

$ echo '5 + 6 # and a comment, which is not in the AST' |
parse_tree_show -f
s(:call, s(:lit, 5), :+, s(:array, s(:lit, 6)))

No, really, they aren't there.

I stopped reading your email here.  I scanned the rest and you didn't
provide any code to back up your assertion that removing comments
improves ruby performance.  I'd be happy to look at it if you can
post it.
</POST>
<POST>
<POSTER> Alex Young &lt;a...@blackkettle.org&gt; </POSTER>
<POSTDATE> 2007-09-24T03:48:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Michael T. Richter wrote:
">

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; Let me give you a little secret: the troll knows all your countering
&gt; arguments.  In another forum, under a different name, the troll is using
&gt; those very same arguments to tweak the noses of other people and make
&gt; them &quot;dance to his strings&quot;.  The only winning move, as the old movie
&gt; goes, is not to play the game.
">

Normally I'd agree with you, but this post does seem to be the product
of some honest investigation:
http://objectmix.com/python/208141-i-could-use-some-help-making-pytho...

--
Alex
</POST>
<POST>
<POSTER> benj...@fysh.org </POSTER>
<POSTDATE> 2007-09-24T05:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; John Joyce wrote:
&gt;&gt; Why do people troll?
&gt;&gt; What pleasure could it bring?

&gt; Fear, uncertainty and doubt - that's what drives people!
">

Don't forget a rutheless dedication to the Pope!
</POST>
<POST>
<POSTER> William James &lt;w_a_x_...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-09-24T07:26:00 </POSTDATE>
On Sep 23, 9:50 pm, Ruby Maniac &lt;raych ... @hotmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Ruby is a cute language that may someday become useful
">

Someday when you are a more experienced programmer, you
may realize that doing bitwise operations on each byte
of a 2-megabyte file is not an appropriate task for a
&quot;scripting language&quot;.  That calls for a lower-level language.

Ruby is excellent for processing text a word, a line, or a
paragraph at a time.  I do almost all of my programming at
home in Ruby.  It doesn't matter to me whether the program
runs in 0.05 sec. or 0.2 sec.  I can't use Ruby quite as much
as I would like at work, since I have to control the mainframe
terminal emulator with a dialect of Basic that's similar to FreeBasic
and QuickBasic.
</POST>
<POST>
<POSTER> Paul Brannan &lt;pbran...@atdesk.com&gt; </POSTER>
<POSTDATE> 2007-09-24T08:36:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Mon, Sep 24, 2007 at 02:49:22PM +0900, Michael T. Richter wrote:
&gt;    You're still playing into their game.  You're reacting to the troll's
&gt;    input.  If you want to share the good news about YARV performance,
&gt;    start your own breathless thread.  Don't respond to a troll.
&gt;    ESPECIALLY don't quote the troll and do a point-by-point counter.
&gt;    That's exactly what they're looking for.
&gt;    Let me give you a little secret: the troll knows all your countering
&gt;    arguments.  In another forum, under a different name, the troll is
&gt;    using those very same arguments to tweak the noses of other people and
&gt;    make them &quot;dance to his strings&quot;.  The only winning move, as the old
&gt;    movie goes, is not to play the game.
">

You sure do seem to know a lot about trolls. :)

Seriously, though, any move that falls outside the troll's script is a
valid move.  Not playing at all works, but rarely, since not everyone
follows that advice.

I've found that trolling the troll also works, that is, making plausible
but ridicuous arguments in order to frustrate the troll.  This is a
difficult maneuver in a public forum like this one.

Responding in kindness rather than argumentatively works as well, if the
troll's intentions were to start an argument.

People with crediblity should almost never respond to a troll, because
their response gives the troll credibility, so if you are going to try
to beat the troll at his own game, get an alias, or limit your responses
to those which reduce the troll's credibility while keeping your own
intact.

Calling the troll a troll is dangerous, since it's essentially an ad
hominem attack that can reduce your own credibility over time.

The goal in any response to a thread started by the troll should be to
prevent thread explosion.  If the thread has already reached critical
mass, responding to the thread further postpones its death.

Trolls can also show up in real life situations.  These trolls are best
handled by turning the forum into a debate so, keeping in mind that the
goal of a debate is to convince the audience rather than the other
person.

Paul
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-24T09:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
William James wrote:
&gt; On Sep 23, 9:50 pm, Ruby Maniac &lt;raych ... @hotmail.com&gt; wrote:

&gt;&gt; Ruby is a cute language that may someday become useful

&gt; Someday when you are a more experienced programmer, you
&gt; may realize that doing bitwise operations on each byte
&gt; of a 2-megabyte file is not an appropriate task for a
&gt; &quot;scripting language&quot;.  That calls for a lower-level language.
">

Well ... if the bitwise operations are built into the &quot;scripting
language&quot;, why *shouldn't* they be used? It's not like you have to make
them up by converting the bytes to floating point values, converting
them to an array of floating point ones and zeroes and doing ANDs and
ORs on them with floating point equality tests in IF statements!
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T10:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Mon, Sep 24, 2007 at 06:34:57PM +0900, benj ... @fysh.org wrote:
&gt; &gt; John Joyce wrote:
&gt; &gt;&gt; Why do people troll?
&gt; &gt;&gt; What pleasure could it bring?

&gt; &gt; Fear, uncertainty and doubt - that's what drives people!

&gt; Don't forget a rutheless dedication to the Pope!
">

There's nothing like a Pope in the eye with a sharp stick to make a troll
roll out of bed in the morning and say &quot;I have to go rile up one of the
friendliest programmer communities on the Internet!&quot;

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
Isaac Asimov: &quot;Part of the inhumanity of the computer is that, once it is
completely programmed and working smoothly, it is completely honest.&quot;
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-24T10:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Chad Perrin wrote:
&gt; On Mon, Sep 24, 2007 at 06:34:57PM +0900, benj ... @fysh.org wrote:
&gt;&gt;&gt; John Joyce wrote:
&gt;&gt;&gt;&gt; Why do people troll?
&gt;&gt;&gt;&gt; What pleasure could it bring?
&gt;&gt;&gt; Fear, uncertainty and doubt - that's what drives people!
&gt;&gt; Don't forget a rutheless dedication to the Pope!

&gt; There's nothing like a Pope in the eye with a sharp stick to make a troll
&gt; roll out of bed in the morning and say &quot;I have to go rile up one of the
&gt; friendliest programmer communities on the Internet!&quot;
">

And when did Ruth leave the community? Please don't tell me Grace left too!
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T10:38:00 </POSTDATE>
Some others have addressed many of your points admirably.  For the most
part, I didn't really see much point in responding to what you had to
say.  On the other hand, a couple of items just bothered me so much I
can't really help myself.

<QUOTE PREVIOUSPOST="
On Mon, Sep 24, 2007 at 11:55:05AM +0900, Ruby Maniac wrote:

&gt; Given the best Ruby is capable of doing versus the best Python is
&gt; capable of doing Ruby ends up being more than 20x slower than Python
&gt; and I think I know why.

&gt; It is just not possible to make Ruby 1.8.6 execute any faster than the
&gt; Ruby interpreter is capable of executing the code due to the lack of a
&gt; byte-code driven VM.  Maybe someday YARV will make Ruby code run 2x
&gt; faster than Ruby 1.8.6 but that day has not arrived yet and may never
&gt; arrived.

&gt; Even if YARV proves to be 2x faster than Ruby 1.8.6 the resulting Ruby
&gt; code will still be 10x slower than the fastest Python code.
">

I guess you haven't been watching the recent thread that revealed how
much of a performance boost you can get moving from 1.8.6 to 1.9 (among
other means of reducing execution time).

<QUOTE PREVIOUSPOST="
&gt; The bottom line is that Python can be made to run as fast as machine
&gt; code but Ruby cannot.
">

Sure it can.  A language does not, in and of itself, dictate the form of
the implementation.  There could conceivably one day be an optimizing
binary compiler implementated for Ruby while Python might not progress
much beyond where it is now (or vice-versa).  You'd suddenly find that
Python does *not* actually execute as fast as &quot;machine code&quot; (meaning
binary executables, as opposed to VM bytecode).  The fact that Ruby uses
an interpreter right now doesn't mean that things won't change in the
future.

On the other hand, for many types of development projects, programmer
time is a lot more valuable than CPU time.  In such circumstances, Ruby
is one of the best choices around for development language.

<QUOTE PREVIOUSPOST="
&gt; Python is useful for problems that require fast runtimes such as 3D
&gt; modelling or video game programming.

&gt; Ruby would not be fast enough for the kinds of problems where people
&gt; are using Python.
">

Not so much -- not much more so than Ruby, at any rate.  People write
&quot;serious&quot; games in C++ for the most part, these days.  Python doesn't
even begin to compare in that realm.  In cases where speed matters enough
that Ruby isn't even an option, people are generally avoiding Python,
too.  Only in cases where people like to *think* speed matters, but it
doesn't really, do people choose something like Python over something
like Ruby on performance grounds.

<QUOTE PREVIOUSPOST="
&gt; When I write code I want to know I am using tools that give me the
&gt; best performance for the effort that I can possibly get as opposed to
&gt; tools that guarantee no matter how hard I work performance will always
&gt; be lacking.
">

You might want to move from Python to Perl, then.

Maybe you should then move from Perl to C++.

Of course, then perhaps you should consider moving from C++ to Objective
Caml.

At that point, you might consider moving on to C.

Once you get to C, you might consider moving on up to assembly language.

While you're playing around in assembly language, you could even choose
your architecture (and thus your specific flavor of assembly language)
based on the CPU instruction set.

Let me know when you get to the point that you're writing the equivalent
of shell scripts in assembly on the architecture with the most efficient
CPU instruction set.  At that point, I'll believe what you say about
putting all your eggs in the performance basket.

<QUOTE PREVIOUSPOST="
&gt; When people choose to make their choices of languages a religious
&gt; issue they can become rather short-sighted in how they choose to
&gt; resolve programming problems.
">

Yes, you can certainly do that when you religiously attach yourself to
single-issue arguments for one language over another.

<QUOTE PREVIOUSPOST="
&gt; I prefer to be agnostic about programming languages.  I choose those
&gt; that perform the best and I ignore the rest.
">

These are contradictory statements.

I'm sure pretty much everyone here can see the faults in your arguments
for what they are.  As such, you're not really doing a lot of damage to
the reputation of Ruby -- and any attemps to chalk all this up to an
attempt to get Ruby core developers to change their focus to performance
are self-evident nonsense, considering I'm sure they know far better than
you (and me) the key issues they face.  On the other hand, you're
positioning yourself as a representative of Python on a Ruby list.

I'm not a fan of Python.  I don't personally like it.  On the other hand,
I can step back and (somewhat) objectively recognize Python's advantages
as a language.  It really is a great language in purely technical terms,
as are Ruby, Perl, Objective Caml, and a host of other languages,
regardless of whether it's a great language *for me*.  If you're doing
any damage to any language community, however, it's to the Python
community, by giving people one more data point in their statistical
comparisons of the attitudes of Pythonistas.  That's not very fair to the
Python community.

You'd be doing us a favor if you stopped contributing to the Noise:Signal
ratio, but you'd be doing Python's community a bigger favor by ceasing to
pretend to advocate for Python.

I really only comment on this in hopes that it may forestall any
knee-jerk reactions to you that may lead to others judging Python more
harshly because of this one self-appointed representative.  In other
words, I may be addressing you, but you're not my audience.

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
Kent Beck: &quot;I always knew that one day Smalltalk would replace Java.  I
just didn't know it would be called Ruby.&quot;
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T10:40:00 </POSTDATE>
On Mon, Sep 24, 2007 at 11:27:19PM +0900, M. Edward (Ed) Borasky wrote:

<QUOTE PREVIOUSPOST="
&gt; Chad Perrin wrote:
&gt; &gt; On Mon, Sep 24, 2007 at 06:34:57PM +0900, benj ... @fysh.org wrote:
&gt; &gt;&gt;&gt; John Joyce wrote:
&gt; &gt;&gt;&gt;&gt; Why do people troll?
&gt; &gt;&gt;&gt;&gt; What pleasure could it bring?
&gt; &gt;&gt;&gt; Fear, uncertainty and doubt - that's what drives people!
&gt; &gt;&gt; Don't forget a rutheless dedication to the Pope!

&gt; &gt; There's nothing like a Pope in the eye with a sharp stick to make a troll
&gt; &gt; roll out of bed in the morning and say &quot;I have to go rile up one of the
&gt; &gt; friendliest programmer communities on the Internet!&quot;

&gt; And when did Ruth leave the community? Please don't tell me Grace left too!
">

I've been Ruthless my whole life.  I've only been Graceless since she
dumped me in 2003.

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
Patrick J. LoPresti: &quot;Emacs has been replaced by a shell script which 1)
Generates a syslog message at level LOG_EMERG; 2) reduces the user's disk
quota by 100K; and 3) RUNS ED!!!!!!&quot;
</POST>
<POST>
<POSTER> William James &lt;w_a_x_...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-09-24T11:14:00 </POSTDATE>
On Sep 24, 8:01 am, &quot;M. Edward (Ed) Borasky&quot; &lt;zn ... @cesmail.net&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; William James wrote:
&gt; &gt; On Sep 23, 9:50 pm, Ruby Maniac &lt;raych ... @hotmail.com&gt; wrote:

&gt; &gt;&gt; Ruby is a cute language that may someday become useful

&gt; &gt; Someday when you are a more experienced programmer, you
&gt; &gt; may realize that doing bitwise operations on each byte
&gt; &gt; of a 2-megabyte file is not an appropriate task for a
&gt; &gt; &quot;scripting language&quot;.  That calls for a lower-level language.

&gt; Well ... if the bitwise operations are built into the &quot;scripting
&gt; language&quot;, why *shouldn't* they be used? It's not like you have to make
&gt; them up by converting the bytes to floating point values, converting
&gt; them to an array of floating point ones and zeroes and doing ANDs and
&gt; ORs on them with floating point equality tests in IF statements!
">

It's a question of scale.  I'd certainly use it on a small file.
But as we've all seen, using it on a 20-megabyte file will make one
wish he'd used a faster language.
</POST>
<POST>
<POSTER> Jay Levitt &lt;jay+n...@jay.fm&gt; </POSTER>
<POSTDATE> 2007-09-24T11:19:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Mon, 24 Sep 2007 21:36:09 +0900, Paul Brannan wrote:
&gt; Seriously, though, any move that falls outside the troll's script is a
&gt; valid move.
">

Purple!
--
Jay Levitt                |
Boston, MA                | My character doesn't like it when they
Faster: jay at jay dot fm | cry or shout or hit.
http://www.jay.fm | - Kristoffer
</POST>
<POST>
<POSTER> &quot;Robert Dober&quot; &lt;robert.do...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T12:01:00 </POSTDATE>
On 9/24/07, Paul Brannan &lt;pbran ... @atdesk.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Mon, Sep 24, 2007 at 02:49:22PM +0900, Michael T. Richter wrote:
&gt; &gt;    You're still playing into their game.  You're reacting to the troll's
&gt; &gt;    input.  If you want to share the good news about YARV performance,
&gt; &gt;    start your own breathless thread.  Don't respond to a troll.
&gt; &gt;    ESPECIALLY don't quote the troll and do a point-by-point counter.
&gt; &gt;    That's exactly what they're looking for.
&gt; &gt;    Let me give you a little secret: the troll knows all your countering
&gt; &gt;    arguments.  In another forum, under a different name, the troll is
&gt; &gt;    using those very same arguments to tweak the noses of other people and
&gt; &gt;    make them &quot;dance to his strings&quot;.  The only winning move, as the old
&gt; &gt;    movie goes, is not to play the game.

&gt; You sure do seem to know a lot about trolls. :)

&gt; Seriously, though, any move that falls outside the troll's script is a
&gt; valid move.  Not playing at all works, but rarely, since not everyone
&gt; follows that advice.

&gt; I've found that trolling the troll also works, that is, making plausible
&gt; but ridicuous arguments in order to frustrate the troll.  This is a
&gt; difficult maneuver in a public forum like this one.

&gt; Responding in kindness rather than argumentatively works as well, if the
&gt; troll's intentions were to start an argument.

&gt; People with crediblity should almost never respond to a troll, because
&gt; their response gives the troll credibility, so if you are going to try
&gt; to beat the troll at his own game, get an alias, or limit your responses
&gt; to those which reduce the troll's credibility while keeping your own
&gt; intact.

&gt; Calling the troll a troll is dangerous, since it's essentially an ad
&gt; hominem attack that can reduce your own credibility over time.

&gt; The goal in any response to a thread started by the troll should be to
&gt; prevent thread explosion.  If the thread has already reached critical
&gt; mass, responding to the thread further postpones its death.

&gt; Trolls can also show up in real life situations.  These trolls are best
&gt; handled by turning the forum into a debate so, keeping in mind that the
&gt; goal of a debate is to convince the audience rather than the other
&gt; person.

&gt; Paul
">

What do you have against trolls, did you not here about the newest
revelations about Koom valley ?
Sorry I could not resist; for those who do not read all Terry
Pratchett books ;)...

I am not sure if there is any better strategy than ignoring them,
there are sometimes of course very serious and valid posts because
some people do not think it is a troll in the first place and starting
a discussion about what to do about trolls in the troll's thread might
be counter productive.
I tend to ignore them, and sometimes I throw in a &quot;Don't feed the
troll&quot; when I feel it is appropriate (carries information for the
replier).

After all if the troll gets some food the thread becomes uninteresting...
Sometimes I try to warn people not to lose their time, but it is
*their* time anyway.

Cheers
Robert

<QUOTE PREVIOUSPOST="

">

--
I'm an atheist and that's it. I believe there's nothing we can know
except that we should be kind to each other and do what we can for
other people.
-- Katharine Hepburn
</POST>
<POST>
<POSTER> Shai Rosenfeld &lt;shaigui...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T12:08:00 </POSTDATE>
i find this thread interesting enough without all the 'troll' remarks.
(ie comments like chad perrin ; relevant professional remarks)

tia :)

--
Posted via http://www.ruby-forum.com/ .
</POST>
<POST>
<POSTER> William James &lt;w_a_x_...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-09-24T12:11:00 </POSTDATE>
On Sep 24, 12:12 am, &quot;Michael T. Richter&quot; &lt;ttmrich ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; Can I ask why *ANYBODY* took a message by someone calling themselves
&gt; &quot;Ruby Maniac&quot; and using expressions like &quot;cute language&quot; as anything but
&gt; a troll?  Anybody?  Anybody?  Bueller?

&gt; Don't dignify these kinds of things with responses, peeps.
">

I think the o.p. isn't exactly a troll.  I think he is simply young,
naive,
inexperienced, and presumptuous.  There seems to be some honesty in
his
posts.
</POST>
<POST>
<POSTER> &quot;Robert Dober&quot; &lt;robert.do...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-24T12:33:00 </POSTDATE>
On 9/24/07, Shai Rosenfeld &lt;shaigui ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; i find this thread interesting enough without all the 'troll' remarks.
&gt; (ie comments like chad perrin ; relevant professional remarks)
">

Shai I believe this is indeed why we worry about getting trolls down,
they might shadow some interesting poi. Without that they could be
ignored as a minor nuisance.

Now that other thread might not even qualify as a troll thread ( I
believe it does but it is quite borderline ).

<QUOTE PREVIOUSPOST="
&gt; tia :)
">

zio ;)

Cheers
Robert
--
I'm an atheist and that's it. I believe there's nothing we can know
except that we should be kind to each other and do what we can for
other people.
-- Katharine Hepburn
</POST>
<POST>
<POSTER> &quot;Bill Kelly&quot; &lt;bi...@cts.com&gt; </POSTER>
<POSTDATE> 2007-09-24T13:06:00 </POSTDATE>
From: &quot;William James&quot; &lt;w_a_x_ ... @yahoo.com&gt;

<QUOTE PREVIOUSPOST="
&gt; On Sep 24, 12:12 am, &quot;Michael T. Richter&quot; &lt;ttmrich ... @gmail.com&gt;
&gt; wrote:
&gt;&gt; Can I ask why *ANYBODY* took a message by someone calling themselves
&gt;&gt; &quot;Ruby Maniac&quot; and using expressions like &quot;cute language&quot; as anything but
&gt;&gt; a troll?  Anybody?  Anybody?  Bueller?

&gt;&gt; Don't dignify these kinds of things with responses, peeps.

&gt; I think the o.p. isn't exactly a troll.  I think he is simply young,
&gt; naive, inexperienced, and presumptuous.  There seems to be some honesty
&gt; in his posts.
">

Yes, I got the same impression - until he made this claim:

<QUOTE PREVIOUSPOST="
&gt; If I wanted blazing performance I would write Aseembly Language (been
&gt; there and done that back in the day when 8 bits was all there was) but
&gt; one must commit a lot of time to hand-crafting Assembly code and most
&gt; of the time I just don't have that much time to spend writing code.
">

Incidentally, a Google search reveals that someone having his email
address has caused something of a ruckus in another online community:

http://www.coldfusionjedi.com/index.cfm/2006/1/17/Grabbing-the-Bull-b...

http://www.firemoss.com/blog/index.cfm?mode=entry&amp;entry;=D87EDD28-E081...

Regards,

Bill
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T17:39:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Sep 25, 2007 at 03:50:07AM +0900, Robert Dober wrote:
&gt; On 9/24/07, Chad Perrin &lt;per ... @apotheon.com&gt; wrote:

&gt; &gt; I've been Ruthless my whole life.  I've only been Graceless since she
&gt; &gt; dumped me in 2003.
&gt; C'on Chad please correct this false second sentence ;).
">

No, really.  I dated someone named Grace.  She dumped me in 2003.  What's
so false about that?

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
John Kenneth Galbraith: &quot;If all else fails, immortality can always be
assured through spectacular error.&quot;
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T17:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Sep 25, 2007 at 01:08:43AM +0900, Shai Rosenfeld wrote:
&gt; i find this thread interesting enough without all the 'troll' remarks.
&gt; (ie comments like chad perrin ; relevant professional remarks)
">

I'm afraid I'm not entirely clear on your meaning in your parenthetical
comments.  Please rephrase for me, if you don't mind.

If I'm just missing the obvious intent, I blame my headache.

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
Dr. Ron Paul: &quot;Liberty has meaning only if we still believe in it when
terrible things happen and a false government security blanket beckons.&quot;
</POST>
<POST>
<POSTER> &quot;Bill Kelly&quot; &lt;bi...@cts.com&gt; </POSTER>
<POSTDATE> 2007-09-24T17:55:00 </POSTDATE>
From: &quot;Chad Perrin&quot; &lt;per ... @apotheon.com&gt;

<QUOTE PREVIOUSPOST="
&gt; On Tue, Sep 25, 2007 at 01:08:43AM +0900, Shai Rosenfeld wrote:
&gt;&gt; i find this thread interesting enough without all the 'troll' remarks.
&gt;&gt; (ie comments like chad perrin ; relevant professional remarks)

&gt; I'm afraid I'm not entirely clear on your meaning in your parenthetical
&gt; comments.  Please rephrase for me, if you don't mind.
">

My impression was that Shai had found value in posts such as yours
( http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/270601 )
and that Shai was pointing out that the meta discussion about
responding to trolls was essentially adding noise to the thread.

Regards,

Bill
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-24T18:14:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Sep 25, 2007 at 06:55:13AM +0900, Bill Kelly wrote:

&gt; From: &quot;Chad Perrin&quot; &lt;per ... @apotheon.com&gt;
&gt; &gt;On Tue, Sep 25, 2007 at 01:08:43AM +0900, Shai Rosenfeld wrote:
&gt; &gt;&gt;i find this thread interesting enough without all the 'troll' remarks.
&gt; &gt;&gt;(ie comments like chad perrin ; relevant professional remarks)

&gt; &gt;I'm afraid I'm not entirely clear on your meaning in your parenthetical
&gt; &gt;comments.  Please rephrase for me, if you don't mind.

&gt; My impression was that Shai had found value in posts such as yours
&gt; ( http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/270601 )
&gt; and that Shai was pointing out that the meta discussion about
&gt; responding to trolls was essentially adding noise to the thread.
">

Thank you.  Looking at it again, your interpretation seems an obvious one
in retrospect.

It's definitely the headache.

. . and thanks as well to Shai.

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
Paul Graham: &quot;Real ugliness is not harsh-looking syntax, but having to
build programs out of the wrong concepts.&quot;
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-24T22:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bill Kelly wrote:
&gt;&gt; I think the o.p. isn't exactly a troll.  I think he is simply young,
&gt;&gt; naive, inexperienced, and presumptuous.  There seems to be some honesty
&gt;&gt; in his posts.

&gt; Yes, I got the same impression - until he made this claim:

&gt;&gt; If I wanted blazing performance I would write Aseembly Language (been
&gt;&gt; there and done that back in the day when 8 bits was all there was) but
&gt;&gt; one must commit a lot of time to hand-crafting Assembly code and most
&gt;&gt; of the time I just don't have that much time to spend writing code.
">

Speaking as someone who spent a good portion of his career writing
assembly language, I can assure you that every assembly language
programmer ends up creating &quot;domain-specific languages&quot;, libraries,
object frameworks, design patterns, etc. They may not have *called* them
that back in the &quot;good old days&quot;, but that's in fact what they were.

Assembly language programming has a bad reputation, unjustified in my
opinion. And please, don't say, &quot;C is an assembler language&quot;. It isn't
-- it's a high-level Algol derivative with pointers, indirect addressing
and bit-diddling, but it *isn't* an assembly language.

And I can remember a time well *before* &quot;8 bits was all there was&quot;. The
smallest thing you could call a digital computer had 12-bit words, It
took some serious genius to make 4-bit and 8-bit computers. :)
</POST>
<POST>
<POSTER> 7stud -- &lt;dol...@excite.com&gt; </POSTER>
<POSTDATE> 2007-09-24T23:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bill Kelly wrote:

&gt; I've dabbled in a number of languages, but I've written actual
&gt; production code in assembler, Forth, C, C++, Objective-C, Java,
&gt; Perl, Python, Ruby, and (kill me now) VB6.
">

Hi,

Thanks for the well written post.  Can you give a little more insight
into how you came to be using ruby as your programming language of
choice instead of any of the other languages you mentioned.  I know why
you might choose ruby over C/C++ or Java, but what lead you to choose
ruby over python, which as far as I can tell is ruby's closest neighbor.

Thanks.
--
Posted via http://www.ruby-forum.com/ .
</POST>
<POST>
<POSTER> &quot;Michael T. Richter&quot; &lt;ttmrich...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T01:03:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, 2007-25-09 at 12:53 +0900, 7stud -- wrote:
&gt; Thanks for the well written post.  Can you give a little more insight
&gt; into how you came to be using ruby as your programming language of
&gt; choice instead of any of the other languages you mentioned.  I know why
&gt; you might choose ruby over C/C++ or Java, but what lead you to choose
&gt; ruby over python, which as far as I can tell is ruby's closest neighbor.
">

I'm not Bill, but I can give you a data point related to the one you're
looking for.  I'm a former Python user and (local) evangelist.  Way back
when Ruby was still 0.9.something, I was using Python in my work and at
home all the time.  I was doing the former, in fact, despite a company
directive saying that we should only be using C++, VB (since I was
writing a VB toolkit at the time) and tcl, of all things.  (Java was
being added at the end of my tenure in that position.)  I did this
because I found Python easy to program in and especially well-suited to
the kinds of code generation I had to do to fill out all the crappy
boilerplate that dominates C/C++/Java code.  It was also well-suited to
driving tests.

I dropped Python because of its community.

When I started with Python -- back about v1.2 or 1.3 -- the Python
community was mostly friendly and helpful.  It was a joy to be in.  It
changed and it changed dramatically over time.  Now I see a coterie of
people who basically sneer at anybody who isn't in their circle and who
are utterly intolerant of viewpoints not their own.  And, as you can
often see in Ruby circles, they have an alarming tendency to go to other
communities to do their sneering.  The friendly, warm, vibrant community
surrounding a decent language -- and I still do think Python is a good
language; I'm probably unusual among Rubistas for this -- vanished over
the years and was replaced by people I really didn't want anything to do
with.

As a language I think Ruby is slightly (and only slightly) better than
Python.  It has many strengths over Python -- especially with its
metaprogramming capabilities -- but it also has several weaknesses
(beginning with performance and library availability).  I would not be
upset if I had to program in Python professionally, but I would also not
be upset if I had to program in Ruby professionally either.

What makes Ruby a winner over Python for me is its community.  It is
(mostly) friendly and (mostly) welcoming of new people and thoughts.
And while the constantly-moving target of the language can be a bit
frustrating, it's also a bit exhilarating to be there as the language
develops and matures.  To be there while the community crystallizes and
matures.  So for me the big thing that made me switch to Ruby was the
respective set of communities.

--
Michael T. Richter &lt;ttmrich ... @gmail.com&gt; (GoogleTalk:
ttmrich ... @gmail.com)
Experts in advanced countries underestimate by a factor of two to four
the ability of people in underdeveloped countries to do anything
technical. (Charles P Issawi)

signature.asc
1K Download
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-25T01:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
7stud -- wrote:
&gt; Bill Kelly wrote:
&gt;&gt; I've dabbled in a number of languages, but I've written actual
&gt;&gt; production code in assembler, Forth, C, C++, Objective-C, Java,
&gt;&gt; Perl, Python, Ruby, and (kill me now) VB6.

&gt; Hi,

&gt; Thanks for the well written post.  Can you give a little more insight
&gt; into how you came to be using ruby as your programming language of
&gt; choice instead of any of the other languages you mentioned.  I know why
&gt; you might choose ruby over C/C++ or Java, but what lead you to choose
&gt; ruby over python, which as far as I can tell is ruby's closest neighbor.

&gt; Thanks.
">

And why did you stop using Forth? Is there *really* a way to break the
addiction? ;)
</POST>
<POST>
<POSTER> 7stud -- &lt;dol...@excite.com&gt; </POSTER>
<POSTDATE> 2007-09-25T01:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Michael T. Richter wrote:
&gt; I dropped Python because of its community.

&gt; When I started with Python -- back about v1.2 or 1.3 -- the Python
&gt; community was mostly friendly and helpful.  It was a joy to be in.  It
&gt; changed and it changed dramatically over time.  Now I see a coterie of
&gt; people who basically sneer at anybody who isn't in their circle and who
&gt; are utterly intolerant of viewpoints not their own.  And, as you can
&gt; often see in Ruby circles, they have an alarming tendency to go to other
&gt; communities to do their sneering.  The friendly, warm, vibrant community
&gt; surrounding a decent language -- and I still do think Python is a good
&gt; language; I'm probably unusual among Rubistas for this -- vanished over
&gt; the years and was replaced by people I really didn't want anything to do
&gt; with.
">

Yes, I see that too.  Despicable behavior.  Thanks for the insights.
--
Posted via http://www.ruby-forum.com/ .
</POST>
<POST>
<POSTER> &quot;Michael T. Richter&quot; &lt;ttmrich...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T02:06:00 </POSTDATE>
On Tue, 2007-25-09 at 14:24 +0900, M. Edward (Ed) Borasky wrote:

<QUOTE PREVIOUSPOST="
&gt; And why did you stop using Forth? Is there *really* a way to break the
&gt; addiction? ;)
">

I know why *I* stopped using Forth.  Forth was great when I was reading
my own code.  It... was less great (trying to stay polite here) when I
had to read other people's code.  ;)

--
Michael T. Richter &lt;ttmrich ... @gmail.com&gt; (GoogleTalk:
ttmrich ... @gmail.com)
Experts in advanced countries underestimate by a factor of two to four
the ability of people in underdeveloped countries to do anything
technical. (Charles P Issawi)

smiley-4.png
1K Download
signature.asc
1K Download
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-09-25T03:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Sep 25, 2007 at 02:03:19PM +0900, Michael T. Richter wrote:

&gt; surrounding a decent language -- and I still do think Python is a good
&gt; language; I'm probably unusual among Rubistas for this -- vanished over
">

I don't know about that.  I've seen a lot of indications, during my
on-again/off-again subscription to ruby-talk over the last few years,
that many of the members of this community have a fair bit of respect for
Python the language.  I personally find Python eye-stabbingly hard on my
aesthetic sense and programming preferences, but even I think Python is a
good language.  It's just not a good language for *me*, and I suspect
that's what many Rubyists here think as well (though maybe a little less
vehemently than me).

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
John Kenneth Galbraith: &quot;If all else fails, immortality can always be
assured through spectacular error.&quot;
</POST>
<POST>
<POSTER> &quot;Alexey Verkhovsky&quot; &lt;alexey.verkhov...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T03:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; I'm probably unusual among Rubistas for [not hating Python]
">

No you aren't. Not at all.

--
Alexey Verkhovsky
CruiseControl.rb [ http://cruisecontrolrb.thoughtworks.com ]
RubyWorks [ http://rubyworks.thoughtworks.com ]
</POST>
<POST>
<POSTER> Charles Oliver Nutter &lt;charles.nut...@sun.com&gt; </POSTER>
<POSTDATE> 2007-09-25T04:26:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Wilson Bilkovich wrote:
&gt; Some corrections:
&gt; 1. YARV is 'out', in the form of Ruby 1.9. A stable release is coming
&gt; in a matter of months.
">

A stable development release. As I understand it, 1.9.1 will still be
considered &quot;unstable&quot; as far as release cycles go...

- Charlie
</POST>
<POST>
<POSTER> &quot;Bill Kelly&quot; &lt;bi...@cts.com&gt; </POSTER>
<POSTDATE> 2007-09-25T04:52:00 </POSTDATE>
From: &quot;M. Edward (Ed) Borasky&quot; &lt;zn ... @cesmail.net&gt;

<QUOTE PREVIOUSPOST="
&gt; 7stud -- wrote:
&gt;&gt; Bill Kelly wrote:
&gt;&gt;&gt; I've dabbled in a number of languages, but I've written actual
&gt;&gt;&gt; production code in assembler, Forth, C, C++, Objective-C, Java,
&gt;&gt;&gt; Perl, Python, Ruby, and (kill me now) VB6.

&gt;&gt; Thanks for the well written post.  Can you give a little more insight
&gt;&gt; into how you came to be using ruby as your programming language of
&gt;&gt; choice instead of any of the other languages you mentioned.  I know why
&gt;&gt; you might choose ruby over C/C++ or Java, but what lead you to choose
&gt;&gt; ruby over python, which as far as I can tell is ruby's closest neighbor.
">

Wow, I wish there were some sort of universal wisdom involved, but
I'm pretty sure it was a combination of pragmatism and a personal
bias toward a particular sort of elegance and aesthetics in language
design that appeals to my own sensibilities.  (In other words, matz kicks
ass at language design!)

Of course, some languages were easier to loathe than others. &lt;grin&gt;
This article pretty well summarizes the sort of horror I felt when
dealing with VB6: http://www.ddj.com/windows/184403996

As for Python, i tended to find the experience more frustrating and
less fun than writing comparable code in Ruby.  Learning Ruby, for me,
involved a lot of &quot;oh, wow, cool I can do that!&quot;  Whereas learning Python
I noticed a lot more, &quot;oh... I'm not allowed to do that.&quot;

I last used Python about six years ago, and I understand some things
have evolved or improved since then (don't they have something more
akin to Ruby blocks now?  And list comprehensions?)

But anyway, a few examples of things that rubbed me the wrong way
about Python.  (Note, these may be things that Python people
absolutely love about the language!)

I found the distinction between expressions and statements, and the
restrictions on where one or the other could occur in the syntax, to be
very rigid and unhelpful.

For example, the syntax is:

if expression:
statement
elif expression:
statement
else:
statement

And assignments are not allowed in expressions.

Thus, code that I wanted to write in Python like this, is illegal:

while match = tagOrTextRegexp.search(html, pos):
pos = match.end()
gd = match.groupdict()
if (val = gd.get('startTag')):
attrs = parseAttrs(gd['allAttrs'])
self.handleStartTag(val.lower(), attrs)
elif (val = gd.get('endTag')):
self.handleEndTag(val.lower())
elif (val = gd.get('text')):
self.handleNonTagText(val)
elif (val = gd.get('comment')):
pass  # ARTHUR (to KNIGHTS)  Walk away.  Just ignore them.
else:
assert 0, &quot;unexpected match in regexp - supposed to be impossible&quot;

..ended up being written like this:

while True:
match = tagOrTextRegexp.search(html, pos)
if match is None:
break
pos = match.end()
gd = match.groupdict()
# no assignment-in-conditional sux, Guido
val = gd.get('startTag')
if val is not None:
attrs = parseAttrs(gd['allAttrs'])
self.handleStartTag(val.lower(), attrs)
else:
val = gd.get('endTag')
if val is not None:
self.handleEndTag(val.lower())
else:
val = gd.get('text')
if val is not None:
self.handleNonTagText(val)
else:
val = gd.get('comment')
if val is not None:
pass  # ARTHUR (to KNIGHTS)  Walk away.  Just ignore them.
else:
assert 0, &quot;unexpected match in regexp - supposed to be impossible&quot;

I found this sort of thing very annoying, as can be seen from the note
I left in the code for Guido (von Rossum, Creator of Python.)  &lt;grin&gt;

Another example would be class methods.  (As opposed to instance methods.)

I remember how hacky and inelegant it seemed to me that every instance
method in Python needed to explicitly list the 'self' parameter:

class Foo:
def bar(self):
print &quot;bar!&quot;

f = Foo()
f.bar

But when I was learning Python, I had an insight and thought, well, at least
I know how to define class methods!  Just leave off the self parameter!

class Foo:
def a_class_method(x,y)
return x+y

Then I should be able to call it directly on the class, with no instance passed
in:

Foo.a_class_method(1,2)

Nope.  Just doesn't work.  No way to define class methods.  (Dunno if this
has changed in the past six years or not.)

Anyway, I don't recall many other examples anymore, but I vividly remember
feeling frustrated in this manner often enough while learning Python that I
would actually exclaim, &quot;Guido!!!!&quot; out loud at my desk when it would
happen.  (But I should point out that I was still having fun.  After all, I enjoyed
programming in Python _a lot_ more than Java.)

Finally, I suppose this is a bit silly, but my very first few minutes with
Python gave me a tangible feeling of trepidation when the following
happened:

I fired up Python (whatever the version was back then), and I got an
interactive interpreter.  I was like, yay! cool!

Python 2.4.1 (#1, May 27 2005, 18:02:40)
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

Then I tried to quit:

&gt;&gt;&gt; exit
'Use Ctrl-D (i.e. EOF) to exit.'
&gt;&gt;&gt; quit
'Use Ctrl-D (i.e. EOF) to exit.'
&gt;&gt;&gt;

And I thought... Oh no.  Somebody actually knew exactly what I
wanted the computer to do - and actually went through the trouble
to program a message to tell me I was doing it wrong.

But again, while these are aspects of Python that rubbed me the
wrong way, I realize that others may and do feel completely
differently.  If Ruby didn't exist, I'd have probably have used
Python for quite a while (maybe moving on to OCaml or Erlang
by now, I dunno.)

<QUOTE PREVIOUSPOST="
&gt; And why did you stop using Forth? Is there *really* a way to break the
&gt; addiction? ;)
">

Hehe.

I would totally still use Forth for embedded systems programming.
How else could one get an entire dynamic interactive extensible image-
based language with its own compiler and interpreter and editor and
assembler into a few KBytes of memory.  :)

What occurred to me over the years, though, was what really made
Forth so remarkable was its achievement of providing such a dynamic
environment out of such utter sheer simplicity of code and memory
architecture.

There's a lot of beauty in an entire interactive compiler / interpreter
system with a main loop that looks like:

: QUIT ( -- ) BEGIN RESET QUERY INTERPRET AGAIN ;

And of course RESET, QUERY, and INTERPRET are quite simple
themselves.  And it's like, Wow! All this dynamicity from such a
beautifully simple architecture!

But as computers got bigger and bigger memories and faster
CPU's, hard drives, file systems, operating systems... I started
to want features that would add complexity to the Forth system,
such as heap-based memory allocation, hashed headers to compile
faster (now that my system included thousands and thousands
of words for interfacing with the operating system), etc...

And eventually Forth wasn't so simple anymore.

And I think Forth's simplicity is part of its appeal... so I started to
hit a wall.

I'll admit I've sometimes wondered what a Forth system would be
like, though, if one took Ruby's VALUE type and made everything
on the data stack something akin to a ruby VALUE.  So that
elements on the data stack would become actual objects with
an associated type... and ... well anyway...  I guess it would be
sort of a cross between Ruby and Forth.  &lt;grin&gt;

But anyway... now I have to get back to some C++ code.  (But
tomorrow back to getting paid to code Ruby! Yay!)

Regards,

Bill
</POST>
<POST>
<POSTER> &quot;Robert Dober&quot; &lt;robert.do...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T05:16:00 </POSTDATE>
On 9/24/07, Chad Perrin &lt;per ... @apotheon.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Tue, Sep 25, 2007 at 03:50:07AM +0900, Robert Dober wrote:
&gt; &gt; On 9/24/07, Chad Perrin &lt;per ... @apotheon.com&gt; wrote:

&gt; &gt; &gt; I've been Ruthless my whole life.  I've only been Graceless since she
&gt; &gt; &gt; dumped me in 2003.
&gt; &gt; C'on Chad please correct this false second sentence ;).

&gt; No, really.  I dated someone named Grace.  She dumped me in 2003.  What's
&gt; so false about that?
">

You were also graceless before you met her, right? Sorry for playing
such stupid games &lt;blush&gt;.
Robert
--
I'm an atheist and that's it. I believe there's nothing we can know
except that we should be kind to each other and do what we can for
other people.
-- Katharine Hepburn
</POST>
<POST>
<POSTER> William James &lt;w_a_x_...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-09-25T05:39:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bill Kelly wrote:
">

[...]

<QUOTE PREVIOUSPOST="
&gt; As for Python, i tended to find the experience more frustrating and
&gt; less fun than writing comparable code in Ruby.  Learning Ruby, for me,
&gt; involved a lot of &quot;oh, wow, cool I can do that!&quot;  Whereas learning Python
&gt; I noticed a lot more, &quot;oh... I'm not allowed to do that.&quot;

[...]
&gt; But anyway, a few examples of things that rubbed me the wrong way
&gt; about Python.  (Note, these may be things that Python people
&gt; absolutely love about the language!)

&gt; I found the distinction between expressions and statements, and the
&gt; restrictions on where one or the other could occur in the syntax, to be
&gt; very rigid and unhelpful.

&gt; For example, the syntax is:

&gt;   if expression:
&gt;     statement
&gt;   elif expression:
&gt;     statement
&gt;   else:
&gt;     statement

&gt; And assignments are not allowed in expressions.

&gt; Thus, code that I wanted to write in Python like this, is illegal:

[...]

&gt; I found this sort of thing very annoying, as can be seen from the note
&gt; I left in the code for Guido (von Rossum, Creator of Python.)  &lt;grin&gt;

[...]

&gt; Finally, I suppose this is a bit silly, but my very first few minutes with
&gt; Python gave me a tangible feeling of trepidation when the following
&gt; happened:

&gt; I fired up Python (whatever the version was back then), and I got an
&gt; interactive interpreter.  I was like, yay! cool!

&gt;   Python 2.4.1 (#1, May 27 2005, 18:02:40)
&gt;   Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

&gt; Then I tried to quit:

&gt;   &gt;&gt;&gt; exit
&gt;   'Use Ctrl-D (i.e. EOF) to exit.'
&gt;   &gt;&gt;&gt; quit
&gt;   'Use Ctrl-D (i.e. EOF) to exit.'

&gt; And I thought... Oh no.  Somebody actually knew exactly what I
&gt; wanted the computer to do - and actually went through the trouble
&gt; to program a message to tell me I was doing it wrong.
">

With apologies to Stephen Crane.

Code as I Code

&quot;Code as I code,&quot; said Guido,
&quot;Or you are abominably wicked;
&quot;You are a toad.&quot;

And after I had thought of it,
I said: &quot;I will, then, be a toad.&quot;
</POST>
<POST>
<POSTER> Shai Rosenfeld &lt;shaigui...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T05:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bill Kelly wrote:
&gt; From: &quot;Chad Perrin&quot; &lt;per ... @apotheon.com&gt;
&gt; My impression was that Shai had found value in posts such as yours
&gt; ( http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/270601 )
&gt; and that Shai was pointing out that the meta discussion about
&gt; responding to trolls was essentially adding noise to the thread.
">

^
|
|
|

(( very true ))
--
Posted via http://www.ruby-forum.com/ .
</POST>
<POST>
<POSTER> &quot;Michal Suchanek&quot; &lt;hramr...@centrum.cz&gt; </POSTER>
<POSTDATE> 2007-09-25T06:30:00 </POSTDATE>
On 25/09/2007, William James &lt;w_a_x_ ... @yahoo.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; With apologies to Stephen Crane.

&gt;   Code as I Code

&gt;   &quot;Code as I code,&quot; said Guido,
&gt;   &quot;Or you are abominably wicked;
&gt;   &quot;You are a toad.&quot;

&gt;   And after I had thought of it,
&gt;   I said: &quot;I will, then, be a toad.&quot;
">

Quack! Quack! :D
(or whatever English toads say .. did you notice that animals that
cross a border often start doing quite different sounds? :D )

Thanks

Michal
</POST>
<POST>
<POSTER> Ron Fox &lt;f...@nscl.msu.edu&gt; </POSTER>
<POSTDATE> 2007-09-25T08:13:00 </POSTDATE>
I'm new to this newsgroup, having come here from many years with
another scripting language (Tcl/Tk; in fact in about 2hrs I'll be on  my
way to  New Orleans for Tcl 2007).  I'm going to spout a slightly
different belief than most of the respondents.

There are cases where speed is almost completely irrelevant.
What is important is completion of a functioning application that
satisfies the customer (internal or external).  For many many
applications this can be done, on modern computers without any
attention to the speed of the application.  If my program takes
100ms to execute and yours takes 1usec, I contend that most users
will not notice, or care about the difference.

I also contend that while there &gt;are&lt; cases where performance is
important (much of my work is doing soft real-time data taking systems
for a national nuclear physics research lab... performance for the
data taking parts of those systems is critical), for a great deal of
software it is not.  For responsiveness to a GUI element, you can pretty
well work in the 100-500ms range of performance...for all but
graphically intensive games where you have to get down to about 16ms.
Whatever language works in that performance range for your application
is suitable.

So what I would say is rather closed minded is the statement:

&gt; I prefer to be agnostic about programming languages.  I choose those
&gt; that perform the best and I ignore the rest.

If that's true, start learning assembly.  That's going to give you the
absolute best performance...for a specific machine.  And that points to
the real issues.  For me, choosing a programming language is
a set of engineering compromises. The compromises are usually a result
of the dynamic tension between the need to hit specific performance
goals, the portability of software written in the language, the
expressive power of the language in the problem domain in which I'm
working, and the availability of mature, low defect libraries in the
problem domain in which I'm working.  What drove me to Ruby, for
example, is a new project to do laboratory administrative data
processing that requires us to show a specification of the underlying
business process and demonstrate that the code faithfully executes it,
and the existence of John Metraux's OpenWfeRu and the densha example of
how to host it on rails, as a tool to solve this problem....and about
2-3 weeks evaluating this tool for suitability as a partial solution to
this problem.

I _am_ programming language agnostic.  As such I write and have written
in Assembler, Forth, Fortran, C, C++, Tcl/Tk, Ruby, Perl, Python,
Pascal.. I've even developed application specific languages and then
used them.  None of these languages is a silver bullet.  Each has
advantages and disadvantages, and the wise programmer will weigh them
carefully when selecting which ones to use to solve any given problem.

Ron Fox
National Superconducting Cyclotron Lab
Michigan State University
East Lansing, MI 48824-1321

<QUOTE PREVIOUSPOST="
Ruby Maniac wrote:
&gt; I welcome any corrections anyone might be able to make since I am new
&gt; to Ruby with less than 3 months experience under my belt.

&gt; Ruby 1.8.6 is an interpreted langauge that does not have a byte-code
&gt; driven VM at this time.

&gt; Python 2.5.1 is an interpreted language that does have a byte-code
&gt; driven VM.

&gt; I have been able to make Ruby code run 5% faster or more simply by
&gt; removing nothing but comments - the more comments I remove the faster
&gt; the code runs up to no more than 6% or 7%.

&gt; Ruby syntax seems to favor the notion that fewer characters is better
&gt; than more characters.  Lexically interpreted langauges would want this
&gt; to be the case since it takes more effort to lex more characters.

&gt; Python runtimes are not affected by the number of characters one uses
&gt; such as extra whitespace or comments - removing comments does not make
&gt; Python code run faster simply because the comments have been removed.

&gt; Python has a very powerful JIT (Just In Time compiler) known as Psyco
&gt; with which certain Python expressions such as LC (List Comprehensions)
&gt; and others can be made to run 20x to 100x faster at runtime.

&gt; Recently as a test I wrote a rather simple Python program that
&gt; processed all characters of a 20 MB file by setting the MSB to 1. The
&gt; original Python code I began with executed in 65 seconds before I
&gt; began to optimize the code.  After the code was fully optimized it ran
&gt; in just under 3 secs. After Psyco was used the runtime for the same
&gt; problem was less than 1 second.

&gt; The Ruby code I wrote before any optimizations were applied ran in
&gt; about 65 seconds or no faster than Python with no optimizations.  The
&gt; most optimized Ruby code I could find for this problem was able to
&gt; execute in just under 22 seconds using techniques that were not
&gt; necessary when optimizing the Python code.

&gt; Given the best Ruby is capable of doing versus the best Python is
&gt; capable of doing Ruby ends up being more than 20x slower than Python
&gt; and I think I know why.

&gt; It is just not possible to make Ruby 1.8.6 execute any faster than the
&gt; Ruby interpreter is capable of executing the code due to the lack of a
&gt; byte-code driven VM.  Maybe someday YARV will make Ruby code run 2x
&gt; faster than Ruby 1.8.6 but that day has not arrived yet and may never
&gt; arrived.

&gt; Even if YARV proves to be 2x faster than Ruby 1.8.6 the resulting Ruby
&gt; code will still be 10x slower than the fastest Python code.

&gt; The only way YARV will get faster than Python is whenever someone
&gt; codes a JIT compiler for YARV that provides the same performance boost
&gt; to Ruby that Psyco provides to Python.  As far as I can tell nobody is
&gt; working on any such JIT for YARV and since YARV has been under
&gt; development for at least the last 14 to 18 months one can only surmise
&gt; a JIT for YARV would take a significant amount of time to produce and
&gt; release to the Ruby community.

&gt; The bottom line is that Python can be made to run as fast as machine
&gt; code but Ruby cannot.

&gt; I know some people want to try to use Ruby for every single problem
&gt; they are faced with but doing so would be less than wise since there
&gt; are no tools that work for all problems.

&gt; Some problems lend themselves nicely to Ruby such as Open Source
&gt; products where giving away the source code is not a business
&gt; problem.

&gt; Python is useful for problems that require fast runtimes such as 3D
&gt; modelling or video game programming.

&gt; Ruby would not be fast enough for the kinds of problems where people
&gt; are using Python.

&gt; I have not been able to find any references to Ruby being used for 3D
&gt; realtime video game programming but I have been able to find many
&gt; references to Python being used for 3D realtime video game
&gt; programming.

&gt; I don't expect those who read this to applaud my efforts to discuss
&gt; this in this forum however I feel we need to discuss this so that some
&gt; may choose to take actions to make Ruby run faster at runtime just as
&gt; work was done to make Python run faster at runtime.

&gt; Believe it or not I actually like Ruby 1.8.6 but I would hesitate to
&gt; try to use Ruby for situations where runtime performance was an issue
&gt; or whenever I did not want to release the source code.

&gt; When I write code I want to know I am using tools that give me the
&gt; best performance for the effort that I can possibly get as opposed to
&gt; tools that guarantee no matter how hard I work performance will always
&gt; be lacking.

&gt; The same comments could be made about Rails.  Rails emits SQL
&gt; statements that have a lot of &quot;*&quot; characters.  Those of us who have
&gt; been coding SQL long enough know the use of &quot;*&quot; characters makes SQL
&gt; statements run slower than when fully qualified column names are used
&gt; rather than the &quot;*&quot;.  I coded a simple benchmark that demonstrated
&gt; this very clearly; whenever &quot;*&quot; was used rather than a list of column
&gt; names the resulting SQL statements ran 10% to 880% slower than when
&gt; the &quot;*&quot; was replaced with a list of column names even when the list of
&gt; column names was quite long.

&gt; Oddly enough I quite easily found more powerful Database Frameworks
&gt; for Python that did not emit SQL code that used &quot;*&quot; characters and I
&gt; was even able to find some interfaces for those SQL Frameworks that
&gt; would allow seasonsed Rails developers use Rails statements when
&gt; describing their database relationships.

&gt; I know of some Ruby developers who rejected the idea that the use of
&gt; &quot;*&quot; in SQL statements would be slower than long lists of column
&gt; names.  From the perspective of a Ruby on Rails developer who has not
&gt; coded anything but Rails or Ruby it might seem logical that fewer
&gt; characters is better than more characters and so the use of &quot;*&quot; in SQL
&gt; statements must be optimial because this is how Ruby works, right ?!?
&gt; Wrong !

&gt; Even when some RoR developers are faced with benchmarks that
&gt; demonstrate the use of &quot;*&quot; in SQL statements can be 10% to 880% slower
&gt; than not using &quot;*&quot; characters they still chose to reject the
&gt; benchmarks and deny the benefits of not using Rails because Rails is
&gt; not able to automatically replace &quot;*&quot; with lists of column names,
&gt; apparently.

&gt; When people choose to make their choices of languages a religious
&gt; issue they can become rather short-sighted in how they choose to
&gt; resolve programming problems.

&gt; I prefer to be agnostic about programming languages.  I choose those
&gt; that perform the best and I ignore the rest.

&gt; Ruby is a cute language that may someday become useful but this won't
&gt; happen unless the Ruby community becomes interested in making Ruby
&gt; perform better at runtime.  In the meantime, I will use Ruby only when
&gt; I must as for the rest I will most-likely use Python unless the
&gt; problem suggests another language may be more useful.
">
</POST>
<POST>
<POSTER> &quot;John Mettraux&quot; &lt;jmettr...@openwfe.org&gt; </POSTER>
<POSTDATE> 2007-09-25T08:43:00 </POSTDATE>
On 9/25/07, Ron Fox &lt;f ... @nscl.msu.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; What drove me to Ruby, for
&gt; example, is a new project to do laboratory administrative data
&gt; processing that requires us to show a specification of the underlying
&gt; business process and demonstrate that the code faithfully executes it,
&gt; and the existence of John Metraux's OpenWfeRu and the densha example of
&gt; how to host it on rails, as a tool to solve this problem....and about
&gt; 2-3 weeks evaluating this tool for suitability as a partial solution to
&gt; this problem.
">

Hi Ron,

my name is &quot;Mettraux&quot;.

Thanks again for your contributions to OpenWFEru. And thanks for the ad here.

Best regards,

--
John Mettraux   -///- http://jmettraux.openwfe.org
</POST>
<POST>
<POSTER> Shai Rosenfeld &lt;shaigui...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T08:47:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ron Fox wrote:
&gt; There are cases where speed is almost completely irrelevant.
&gt; What is important is completion of a functioning application that
&gt; satisfies the customer (internal or external).  For many many
&gt; applications this can be done, on modern computers without any
&gt; attention to the speed of the application.  If my program takes
&gt; 100ms to execute and yours takes 1usec, I contend that most users
&gt; will not notice, or care about the difference.

&gt; I _am_ programming language agnostic.  As such I write and have written
&gt; in Assembler, Forth, Fortran, C, C++, Tcl/Tk, Ruby, Perl, Python,
&gt; Pascal.. I've even developed application specific languages and then
&gt; used them.  None of these languages is a silver bullet.  Each has
&gt; advantages and disadvantages, and the wise programmer will weigh them
&gt; carefully when selecting which ones to use to solve any given problem.

&gt; Ron Fox
&gt; National Superconducting Cyclotron Lab
&gt; Michigan State University
&gt; East Lansing, MI 48824-1321
">

there we go.
:)
--
Posted via http://www.ruby-forum.com/ .
</POST>
</TEXT>
</BODY>
</DOC>
