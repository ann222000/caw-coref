<DOC>
<DOCID> eng-NG-31-126394-9137323 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-11-17T20:11:00 </DATETIME>
<BODY>
<HEADLINE>
An accurate, pauseless &amp; deterministic GC for C++
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;Mingnan G.&quot; &lt;leland...@yahoo.com.cn&gt; </POSTER>
<POSTDATE> 2007-11-17T20:11:00 </POSTDATE>
The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
collector for C++ application, is released at

http://hnxgc.harnixworld.com

(MD5: b96a83d0899317e732abb46a5e1f2dd5)

Features include:

Accurate - HnxGC is a fully accurate tracing garbage collector. We
don't use any tricks to guess/distinguish pointers from other data.
All effective references are identified. There is no leak of garbage
objects uncollected and all associated native resources will be
freed.

Pauseless - HnxGC come with a lock-free and block-free concurrent
collector with no need to scan root-set area. We don't need to take a
snapshot to determine application status, thus the normal execution of
application thread will never be interrupted, suspended, blocked or
forced to spin-waiting by our collector, no matter in a multi-
processors or an uni-processor environment.

Deterministic - HnxGC always executes the destructor of an object when
application program drops the last reference to the object. In
addition, application program can declare dependence rules for each
object to control the destructing ordering of cyclic garbage objects.
The system will figure out an ordering that satisfies all user-
declared rules. Thus, application programmers have more controls on
how unreachable objects are reclaimed, more compliance to RAII
(Resource Acquisition Is Initialization) design pattern, such as
closing file handle or network connection in the destructor routine of
objects.

Efficient - Even HnxGC provide deterministic reclamation feature
similiar to the one in regular reference counting algorithm, we remove
the cost of reference maintenance significantly. The cost of most-
frequently-used reference copying, such as passing references as
parameters or return values between function calls, are removed. More
advanced technique, such as GlobalMemoryFence, are used to eliminate
the memory ordering cost for a multi-processors platforms.

Easy-to-Use and Portable - Just linking with our library, you can
enjoy all of above features and the more. You can even use our library
with .NET managed code in visual C++. There is no too much
restriction, you can use template, union, bit-fields, multiple-
inheritance, object composition, and array of objects in HnxGC as
efficiency as in traditional C++. The source code is available, and
the only required for your application is a standard C++ compiler,
such as Visual C++ or GNU C++. No use of any special features of any
specific compiler, nor any platform specific system calls. Can even
run without virtual memory support. Write your garbage-collected C++
application once, and it is easy to port to a wider array of
platforms, no constraint to any specific platform vendors.
</POST>
<POST>
<POSTER> Juha Nieminen &lt;nos...@thanks.invalid&gt; </POSTER>
<POSTDATE> 2007-11-18T10:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Mingnan G. wrote:
&gt; http://hnxgc.harnixworld.com
">

&quot;The author of HnxGC has filed several patents of HnxGC in the United
States and other countries. Whoever without authority makes, uses,
offers to sell, or sells any of these patented invention, within the
United States and/or other countries infringes the patent(s).&quot;

You are claiming patent protection for something which has not been
granted a patent yet?

Besides, you should really acquaint yourself about how patents work
outside the US. You just can't patent something in the US and then claim
that using the algorithm outside the US infringes some patent law. Most
other countries do not have software patents, do not respect software
patents of other countries, and above all, even if it was a valid
patent, they allow the *use* of such patents without express permission
(even if distributing products using the patent is prohibited). Just
claiming that &quot;you can't use this without permission&quot; has no legal
validity. You are claiming more rights than you really have.

Good thing you didn't claim copyright prohibits people from using your
algorithms, as algorithms do not fall into the realm of copyright.
</POST>
<POST>
<POSTER> Joe Seigh &lt;jseigh...@xemaps.com&gt; </POSTER>
<POSTDATE> 2007-11-18T10:55:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Mingnan G. wrote:
&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt; collector for C++ application, is released at

&gt; http://hnxgc.harnixworld.com

&gt; (MD5: b96a83d0899317e732abb46a5e1f2dd5)

&gt; Features include:

&gt; Accurate - HnxGC is a fully accurate tracing garbage collector. We
&gt; don't use any tricks to guess/distinguish pointers from other data.
&gt; All effective references are identified. There is no leak of garbage
&gt; objects uncollected and all associated native resources will be
&gt; freed.

&gt; Pauseless - HnxGC come with a lock-free and block-free concurrent
&gt; collector with no need to scan root-set area. We don't need to take a
&gt; snapshot to determine application status, thus the normal execution of
&gt; application thread will never be interrupted, suspended, blocked or
&gt; forced to spin-waiting by our collector, no matter in a multi-
&gt; processors or an uni-processor environment.

&gt; Deterministic - HnxGC always executes the destructor of an object when
&gt; application program drops the last reference to the object. In
&gt; addition, application program can declare dependence rules for each
&gt; object to control the destructing ordering of cyclic garbage objects.
&gt; The system will figure out an ordering that satisfies all user-
&gt; declared rules. Thus, application programmers have more controls on
&gt; how unreachable objects are reclaimed, more compliance to RAII
&gt; (Resource Acquisition Is Initialization) design pattern, such as
&gt; closing file handle or network connection in the destructor routine of
&gt; objects.

&gt; Efficient - Even HnxGC provide deterministic reclamation feature
&gt; similiar to the one in regular reference counting algorithm, we remove
&gt; the cost of reference maintenance significantly. The cost of most-
&gt; frequently-used reference copying, such as passing references as
&gt; parameters or return values between function calls, are removed. More
&gt; advanced technique, such as GlobalMemoryFence, are used to eliminate
&gt; the memory ordering cost for a multi-processors platforms.

&gt; Easy-to-Use and Portable - Just linking with our library, you can
&gt; enjoy all of above features and the more. You can even use our library
&gt; with .NET managed code in visual C++. There is no too much
&gt; restriction, you can use template, union, bit-fields, multiple-
&gt; inheritance, object composition, and array of objects in HnxGC as
&gt; efficiency as in traditional C++. The source code is available, and
&gt; the only required for your application is a standard C++ compiler,
&gt; such as Visual C++ or GNU C++. No use of any special features of any
&gt; specific compiler, nor any platform specific system calls. Can even
&gt; run without virtual memory support. Write your garbage-collected C++
&gt; application once, and it is easy to port to a wider array of
&gt; platforms, no constraint to any specific platform vendors.
">

CC'ing c.p.t

I don't know what the GlobalMemoryFence is yet since that part is not
filled in yet.  Generally with shared pointers you need acquire/release
semantics which can't be elided.

--
Joe Seigh

When you get lemons, you make lemonade.
When you get hardware, you make software.
</POST>
<POST>
<POSTER> Joe Seigh &lt;jseigh...@xemaps.com&gt; </POSTER>
<POSTDATE> 2007-11-18T11:03:00 </POSTDATE>
(sorry for the repost but it probably would help if I actually included c.p.t)

<QUOTE PREVIOUSPOST="
Mingnan G. wrote:
&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt; collector for C++ application, is released at

&gt; http://hnxgc.harnixworld.com

&gt; (MD5: b96a83d0899317e732abb46a5e1f2dd5)

&gt; Features include:

&gt; Accurate - HnxGC is a fully accurate tracing garbage collector. We
&gt; don't use any tricks to guess/distinguish pointers from other data.
&gt; All effective references are identified. There is no leak of garbage
&gt; objects uncollected and all associated native resources will be
&gt; freed.

&gt; Pauseless - HnxGC come with a lock-free and block-free concurrent
&gt; collector with no need to scan root-set area. We don't need to take a
&gt; snapshot to determine application status, thus the normal execution of
&gt; application thread will never be interrupted, suspended, blocked or
&gt; forced to spin-waiting by our collector, no matter in a multi-
&gt; processors or an uni-processor environment.

&gt; Deterministic - HnxGC always executes the destructor of an object when
&gt; application program drops the last reference to the object. In
&gt; addition, application program can declare dependence rules for each
&gt; object to control the destructing ordering of cyclic garbage objects.
&gt; The system will figure out an ordering that satisfies all user-
&gt; declared rules. Thus, application programmers have more controls on
&gt; how unreachable objects are reclaimed, more compliance to RAII
&gt; (Resource Acquisition Is Initialization) design pattern, such as
&gt; closing file handle or network connection in the destructor routine of
&gt; objects.

&gt; Efficient - Even HnxGC provide deterministic reclamation feature
&gt; similiar to the one in regular reference counting algorithm, we remove
&gt; the cost of reference maintenance significantly. The cost of most-
&gt; frequently-used reference copying, such as passing references as
&gt; parameters or return values between function calls, are removed. More
&gt; advanced technique, such as GlobalMemoryFence, are used to eliminate
&gt; the memory ordering cost for a multi-processors platforms.

&gt; Easy-to-Use and Portable - Just linking with our library, you can
&gt; enjoy all of above features and the more. You can even use our library
&gt; with .NET managed code in visual C++. There is no too much
&gt; restriction, you can use template, union, bit-fields, multiple-
&gt; inheritance, object composition, and array of objects in HnxGC as
&gt; efficiency as in traditional C++. The source code is available, and
&gt; the only required for your application is a standard C++ compiler,
&gt; such as Visual C++ or GNU C++. No use of any special features of any
&gt; specific compiler, nor any platform specific system calls. Can even
&gt; run without virtual memory support. Write your garbage-collected C++
&gt; application once, and it is easy to port to a wider array of
&gt; platforms, no constraint to any specific platform vendors.
">

CC'ing c.p.t

I don't know what the GlobalMemoryFence is yet since that part is not
filled in yet.  Generally with shared pointers you need acquire/release
semantics which can't be elided.

--
Joe Seigh

When you get lemons, you make lemonade.
When you get hardware, you make software.
</POST>
<POST>
<POSTER> &quot;osmium&quot; &lt;r124c4u...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-18T11:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Juha Nieminen&quot; wrote:
&gt; Mingnan G. wrote:
&gt;&gt; http://hnxgc.harnixworld.com

&gt; &quot;The author of HnxGC has filed several patents of HnxGC in the United
&gt; States and other countries. Whoever without authority makes, uses,
&gt; offers to sell, or sells any of these patented invention, within the
&gt; United States and/or other countries infringes the patent(s).&quot;

&gt;  You are claiming patent protection for something which has not been
&gt; granted a patent yet?

&gt;  Besides, you should really acquaint yourself about how patents work
&gt; outside the US. You just can't patent something in the US and then claim
&gt; that using the algorithm outside the US infringes some patent law. Most
&gt; other countries do not have software patents, do not respect software
&gt; patents of other countries, and above all, even if it was a valid
&gt; patent, they allow the *use* of such patents without express permission
&gt; (even if distributing products using the patent is prohibited). Just
&gt; claiming that &quot;you can't use this without permission&quot; has no legal
&gt; validity. You are claiming more rights than you really have.

&gt;  Good thing you didn't claim copyright prohibits people from using your
&gt; algorithms, as algorithms do not fall into the realm of copyright.
">

You seem to have some hostility problems with the patent system, nothing
wrong with that.  However:

It is, and has always been, standard in the USA to warn people that a patent
has been applied for.  I think the lack of such a warning was a part of the
LZW fiasco a few years ago.

The OPs mention of &quot;other countries&quot; instead of saying &quot;the planet&quot; contains
a clear implication that he is speaking of *some* other countries.

Using number of countries (most) is a pitiful metric.  It equates, say,
Sierra Leone with Germany. Germany is more likely to produce patents by
their own people and are thus interested in the whole notion of patents..
As I understand it, the Vatican is a country, and so is France - why treat
them the same?
</POST>
<POST>
<POSTER> &quot;Chris Thomasson&quot; &lt;cris...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-18T14:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Joe Seigh&quot; &lt;jseigh ... @xemaps.com&gt; wrote in message
">

news:ZmZ%i.2695$Jy1.83@trndny02 ...

<QUOTE PREVIOUSPOST="
&gt; (sorry for the repost but it probably would help if I actually included
&gt; c.p.t)

&gt; Mingnan G. wrote:
&gt;&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt;&gt; collector for C++ application, is released at

&gt;&gt; http://hnxgc.harnixworld.com
">

[...]

Have you addressed the concerns I had:

http://groups.google.com/group/comp.lang.c++/browse_frm/thread/95007f...

?
</POST>
<POST>
<POSTER> &quot;Chris Thomasson&quot; &lt;cris...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-18T14:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Chris Thomasson&quot; &lt;cris ... @comcast.net&gt; wrote in message
">

news:TcOdnUISFt2BC93anZ2dnUVZ_sKqnZ2d@comcast.com ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Joe Seigh&quot; &lt;jseigh ... @xemaps.com&gt; wrote in message
&gt; news:ZmZ%i.2695$Jy1.83@trndny02 ...
&gt;&gt; (sorry for the repost but it probably would help if I actually included
&gt;&gt; c.p.t)

&gt;&gt; Mingnan G. wrote:
&gt;&gt;&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt;&gt;&gt; collector for C++ application, is released at

&gt;&gt;&gt; http://hnxgc.harnixworld.com

&gt; [...]

&gt; Have you addressed the concerns I had:

&gt; http://groups.google.com/group/comp.lang.c++/browse_frm/thread/95007f...

&gt; ?
">

Are you still using smart-pointers?
</POST>
<POST>
<POSTER> &quot;Chris Thomasson&quot; &lt;cris...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-18T14:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Chris Thomasson&quot; &lt;cris ... @comcast.net&gt; wrote in message
">

news:TcOdnUISFt2BC93anZ2dnUVZ_sKqnZ2d@comcast.com ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Joe Seigh&quot; &lt;jseigh ... @xemaps.com&gt; wrote in message
&gt; news:ZmZ%i.2695$Jy1.83@trndny02 ...
&gt;&gt; (sorry for the repost but it probably would help if I actually included
&gt;&gt; c.p.t)

&gt;&gt; Mingnan G. wrote:
&gt;&gt;&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt;&gt;&gt; collector for C++ application, is released at

&gt;&gt;&gt; http://hnxgc.harnixworld.com

&gt; [...]

&gt; Have you addressed the concerns I had:

&gt; http://groups.google.com/group/comp.lang.c++/browse_frm/thread/95007f...

&gt; ?
">

AFAICT, it seems like your using an atomic reference counting algorithm with
smart pointers. Do you need to use interlocked instructions to modify the
count? How does you reference counting technique get around prior art? I
assume that you did a full-blown patent search/feasibility check...
</POST>
<POST>
<POSTER> Erik Wikström &lt;Erik-wikst...@telia.com&gt; </POSTER>
<POSTDATE> 2007-11-18T15:47:00 </POSTDATE>
On 2007-11-18 17:11, osmium wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;Juha Nieminen&quot; wrote:

&gt;&gt; Mingnan G. wrote:
&gt;&gt;&gt; http://hnxgc.harnixworld.com

&gt;&gt; &quot;The author of HnxGC has filed several patents of HnxGC in the United
&gt;&gt; States and other countries. Whoever without authority makes, uses,
&gt;&gt; offers to sell, or sells any of these patented invention, within the
&gt;&gt; United States and/or other countries infringes the patent(s).&quot;
&gt;&gt;  Besides, you should really acquaint yourself about how patents work
&gt;&gt; outside the US. You just can't patent something in the US and then claim
&gt;&gt; that using the algorithm outside the US infringes some patent law. Most
&gt;&gt; other countries do not have software patents, do not respect software
&gt;&gt; patents of other countries, and above all, even if it was a valid
&gt;&gt; patent, they allow the *use* of such patents without express permission
&gt;&gt; (even if distributing products using the patent is prohibited). Just
&gt;&gt; claiming that &quot;you can't use this without permission&quot; has no legal
&gt;&gt; validity. You are claiming more rights than you really have.
&gt; The OPs mention of &quot;other countries&quot; instead of saying &quot;the planet&quot; contains
&gt; a clear implication that he is speaking of *some* other countries.
">

Actually, if I say &quot;within the United States and/or other countries&quot; I
mean *all* countries, including the US, and I think that my
interpretation is quite common. This however is totally off-topic in
this group so I will say no more on the subject.

--
Erik Wikström
</POST>
<POST>
<POSTER> rpbg...@yahoo.com (Roland Pibinger) </POSTER>
<POSTDATE> 2007-11-18T16:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sat, 17 Nov 2007 17:11:46 -0800 (PST), &quot;Mingnan G.&quot; wrote:
&gt;The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt;collector for C++ application, is released
[...]
&gt;Deterministic - HnxGC always executes the destructor of an object when
&gt;application program drops the last reference to the object.
">

Apart from the commercial background and apart from the apparent
contradiction in 'deterministic garbage collector' this library, IMO,
touches some interesting aspects:
A future C++-like language should have deterministic destruction but
no 'delete' operator. It's mostly a task for the compiler to determine
the right scope for destruction, e.g. by escape analysis (to a lesser
extent some runtime mechanism (reference counting?) needs to be
involved). Moreover, there should be no difference in syntax between
creating objects on the 'stack' and creating them on the 'heap'. This
distinction becomes an unimportant implementation detail for the
programmer.

--
Roland Pibinger
&quot;The best software is simple, elegant, and full of drama&quot; - Grady Booch
</POST>
<POST>
<POSTER> &quot;Chris Thomasson&quot; &lt;cris...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-18T22:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Joe Seigh&quot; &lt;jseigh ... @xemaps.com&gt; wrote in message
">

news:ZmZ%i.2695$Jy1.83@trndny02 ...

<QUOTE PREVIOUSPOST="
&gt; (sorry for the repost but it probably would help if I actually included
&gt; c.p.t)

&gt; Mingnan G. wrote:
&gt;&gt; The HnxGC Libraray - an accurate, pauseless &amp; deterministic garbage
&gt;&gt; collector for C++ application, is released at

&gt;&gt; http://hnxgc.harnixworld.com
">

Why not use a simple lock-free proxy garbage collector (e.g., PDR):

http://groups.google.com/group/comp.programming.threads/browse_frm/th...

http://groups.google.com/group/comp.programming.threads/search?hl=en&amp;...

? Here is a free example:

http://home.comcast.net/~vzoom/demos/pc_sample.c

This uses interlocked operations for extracting the necessary epoch
information, but its way better then rw-mutexs for protected read-size proxy
collected region. How do you beat RCU read-side performance characteristics
in general?

The proxy method has its advantages, such as the ability to plain/raw atomic
loads and stores w/ dependant load memory-barriers to access the shared
data-structures; no interlocking and #StoreLoad barriers required for
read-side critical regions. Please note that the membar mentioned is a NOP
on virtually  every system out there, except the Alpha architecture:

https://coolthreads.dev.java.net/servlets/ProjectForumMessageView?for...

https://coolthreads.dev.java.net/servlets/ProjectForumMessageView?mes...

The proxy collector allows the writers to use many different techniques,
including but definitely not limited to POSIX mutexs and lock-free
algorithms. I would consider STM to be a candidate for the writer side of a
reader pattern; its about the only thing that STM is useful for, IMHO at
least. Solving the deadlocking problem can be done with correct locking
pattern; STM is not needed for that...

How does your stuff get around prior art? Please inform us when your patent
application is published. I would like to read it as I am interested in the
way you algorithms works. I like implementation details. You mentions that
you do not make any systems calls? You get around using libc and POSIX API
correct? You don't need assembly language to do the atomic/membar stuff? I
am interested in your implementation details indeed.
</POST>
<POST>
<POSTER> &quot;Mingnan G.&quot; &lt;leland...@yahoo.com.cn&gt; </POSTER>
<POSTDATE> 2007-11-18T23:13:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Joe Seigh wrote:
&gt; I don't know what the GlobalMemoryFence is yet since that part is not
&gt; filled in yet.  Generally with shared pointers you need acquire/release
&gt; semantics which can't be elided.
">

By downloading the source code, you will find in HNXGC_MT directory
which uses the Global Memory Fence technology to elide acquire/
release
semantics in a multi-processors environment, such as for Windows 64-
bit
IA64 platform. The binary code for Windows 64-bit IA64 is also
available.

--
Mingnan Guo
</POST>
<POST>
<POSTER> &quot;Chris Thomasson&quot; &lt;cris...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-11-19T01:22:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Mingnan G.&quot; &lt;leland ... @yahoo.com.cn&gt; wrote in message
">

news:e6f2cf61-122a-4a57-b4e0-fc8e873a3fb8@s8g2000prg.googlegroups.com ...

<QUOTE PREVIOUSPOST="
&gt;&gt; I don't know what the GlobalMemoryFence is yet since that part is not
&gt;&gt; filled in yet.  Generally with shared pointers you need acquire/release
&gt;&gt; semantics which can't be elided.

&gt; By downloading the source code, you will find in HNXGC_MT directory
&gt; which uses
&gt; the Global Memory Fence technology to elide acquire/release semantics
&gt; in a multi-processors environment, such as for Windows 64-bit IA64
&gt; platform. The binary code
&gt; for Windows 64-bit IA64 is also available.
">

You don't make systems calls (e.g., no POSIX), you don't tie to a platform
(e.g., no assembly language) and your GlobalMemoryFence is 100% portable?

Are you tracking quiescent state epochs? How do you get around RCU, SMR,
vZOOM and other prior art? I don't have time to read thought a lot of
source-code right now. Can you please explain some details without me having
to read source-code? We have discussed a lot of ways to get around explicit
memory barriers here in cpt. Can you give some details on how your is
fundamentally different that my free proxy collector example, or Joes
SMR+SMR? You don't need acquire/release? Really? You have to be tracking
something to ensure stores don't escape the drop-to-zero condition in
reference counting in general? Do tell. Please? Thanks for your time.
</POST>
<POST>
<POSTER> &quot;Arnold Hendriks&quot; &lt;a.hendr...@b-lex.nl&gt; </POSTER>
<POSTDATE> 2007-11-19T13:57:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Chris Thomasson&quot; &lt;cris ... @comcast.net&gt; wrote in message
">

news:d5idnVx6RpmGt9zanZ2dnUVZ_s6mnZ2d@comcast.com ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Mingnan G.&quot; &lt;leland ... @yahoo.com.cn&gt; wrote in message
&gt; news:e6f2cf61-122a-4a57-b4e0-fc8e873a3fb8@s8g2000prg.googlegroups.com ...
&gt;&gt; By downloading the source code, you will find in HNXGC_MT directory
&gt;&gt; which uses
&gt;&gt; the Global Memory Fence technology to elide acquire/release semantics
&gt;&gt; in a multi-processors environment, such as for Windows 64-bit IA64
&gt;&gt; platform. The binary code
&gt;&gt; for Windows 64-bit IA64 is also available.
&gt; Are you tracking quiescent state epochs? How do you get around RCU, SMR,
&gt; vZOOM and other prior art? I don't have time to read thought a lot of
">

Either way, being outside the US, he may not care about prior art :)
</POST>
<POST>
<POSTER> hyc &lt;h...@highlandsun.com&gt; </POSTER>
<POSTDATE> 2007-11-20T04:00:00 </POSTDATE>
On Nov 18, 10:22 pm, &quot;Chris Thomasson&quot; &lt;cris ... @comcast.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;Mingnan G.&quot; &lt;leland ... @yahoo.com.cn&gt; wrote in message
&gt; news:e6f2cf61-122a-4a57-b4e0-fc8e873a3fb8@s8g2000prg.googlegroups.com ...
&gt; &gt;&gt; I don't know what the GlobalMemoryFence is yet since that part is not
&gt; &gt;&gt; filled in yet.  Generally with shared pointers you need acquire/release
&gt; &gt;&gt; semantics which can't be elided.

&gt; &gt; By downloading the source code, you will find in HNXGC_MT directory
&gt; &gt; which uses
&gt; &gt; the Global Memory Fence technology to elide acquire/release semantics
&gt; &gt; in a multi-processors environment, such as for Windows 64-bit IA64
&gt; &gt; platform. The binary code
&gt; &gt; for Windows 64-bit IA64 is also available.

&gt; You don't make systems calls (e.g., no POSIX), you don't tie to a platform
&gt; (e.g., no assembly language) and your GlobalMemoryFence is 100% portable?

&gt; Are you tracking quiescent state epochs? How do you get around RCU, SMR,
&gt; vZOOM and other prior art? I don't have time to read thought a lot of
&gt; source-code right now. Can you please explain some details without me having
&gt; to read source-code? We have discussed a lot of ways to get around explicit
&gt; memory barriers here in cpt. Can you give some details on how your is
&gt; fundamentally different that my free proxy collector example, or Joes
&gt; SMR+SMR? You don't need acquire/release? Really? You have to be tracking
&gt; something to ensure stores don't escape the drop-to-zero condition in
&gt; reference counting in general? Do tell. Please? Thanks for your time.
">

You'd rather read a vague patent application written in legalese than
actual source code? Talk about a masochist. What makes you think there
would ever *be* a patent application? What makes you even think
software patents are in any way a proper use of anyone's time? By the
way, patents generally can't be applied for after publication. If this
code is already available for download, then there won't be any patent
application.
</POST>
<POST>
<POSTER> hyc &lt;h...@highlandsun.com&gt; </POSTER>
<POSTDATE> 2007-11-20T04:21:00 </POSTDATE>
On Nov 20, 1:00 am, hyc &lt;h ... @highlandsun.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; What makes you think there
&gt; would ever *be* a patent application?
">

Never mind. The web site says patent-pending. Sigh...
</POST>
<POST>
<POSTER> &quot;Mingnan G.&quot; &lt;leland...@yahoo.com.cn&gt; </POSTER>
<POSTDATE> 2007-11-20T08:57:00 </POSTDATE>
On Nov 20, 1:00 am, hyc &lt;h ... @highlandsun.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; would ever *be* a patent application? What makes you even think
&gt; software patents are in any way a proper use of anyone's time? By the
">

You worry too much. For a non-commercial educational purpose, you can
apply
for a *FREE* license for this software. See follows:

Permission to use, copy and distribute this software and its
documentation
for a non-commercial educational purpose can be granted free
by electronic registration via hnxgc.harnixworld.com, provided that
this
copyright notice appears in all copies.
</POST>
<POST>
<POSTER> Juha Nieminen &lt;nos...@thanks.invalid&gt; </POSTER>
<POSTDATE> 2007-11-20T11:58:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
hyc wrote:
&gt; By the
&gt; way, patents generally can't be applied for after publication. If this
&gt; code is already available for download, then there won't be any patent
&gt; application.
">

That my be true in Europe but not in the US.
</POST>
<POST>
<POSTER> Matthias Buelow &lt;m...@incubus.de&gt; </POSTER>
<POSTDATE> 2007-11-20T13:12:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Mingnan G. wrote:
&gt; You worry too much. For a non-commercial educational purpose, you can
&gt; apply
&gt; for a *FREE* license for this software. See follows:
">

[blah]

If your development is so breathtakingly innovative and of general
applicability to C++ programming, why don't you make it available to the
whole programming community as free software under a liberal license.

Instead of spamming this newsgroup with your product advertisement and
annoying everyone with &quot;software patent&quot; nonsense.
</POST>
<POST>
<POSTER> &quot;Arnold Hendriks&quot; &lt;a.hendr...@b-lex.nl&gt; </POSTER>
<POSTDATE> 2007-11-20T16:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Juha Nieminen&quot; &lt;nos ... @thanks.invalid&gt; wrote in message
">

news:47431142$0$3519$39db0f71@news.song.fi ...

<QUOTE PREVIOUSPOST="
&gt; hyc wrote:
&gt;&gt; By the
&gt;&gt; way, patents generally can't be applied for after publication. If this
&gt;&gt; code is already available for download, then there won't be any patent
&gt;&gt; application.
&gt;  That my be true in Europe but not in the US.
">

In Europe, software patents cannot be enforced at all. (Although they can be
registered, to keep the EPO busy)
</POST>
</TEXT>
</BODY>
</DOC>
