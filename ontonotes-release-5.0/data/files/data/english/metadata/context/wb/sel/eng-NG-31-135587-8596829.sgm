<DOC>
<DOCID> eng-NG-31-135587-8596829 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-08-18T12:59:00 </DATETIME>
<BODY>
<HEADLINE>
New language idea - you guys have any feedback?
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T12:59:00 </POSTDATE>
Hey guys, I've for about a year now been tossing around an idea for a
new language / scripting engine / network protocol / data storage
specification - all in one. I actually built at my last job a parser
that did all this - using one unified language. It worked so well I
thought I'd sit down and write a definition for the language. I know a
lot of people are coming up with languages 'like' this, but I truly
think what I have here is good enough to let others see:

http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

Please forgive the name... I know its lame :)

Let me know any suggestions - good idea, bad idea, anyone interested
in building a parser to do this ? I've already done one in Java but
was thinking of maybe building one in a lower level language like C++
for the sake of speed - maybe on Linux.
</POST>
<POST>
<POSTER> Chad &lt;cdal...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T13:11:00 </POSTDATE>
On Aug 18, 9:59 am, &quot;guitarstru ... @gmail.com&quot;

<QUOTE PREVIOUSPOST="
&lt;guitarstru ... @gmail.com&gt; wrote:
&gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; new language / scripting engine / network protocol / data storage
&gt; specification - all in one. I actually built at my last job a parser
&gt; that did all this - using one unified language. It worked so well I
&gt; thought I'd sit down and write a definition for the language. I know a
&gt; lot of people are coming up with languages 'like' this, but I truly
&gt; think what I have here is good enough to let others see:

&gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt; Please forgive the name... I know its lame :)

&gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; in building a parser to do this ? I've already done one in Java but
&gt; was thinking of maybe building one in a lower level language like C++
&gt; for the sake of speed - maybe on Linux.
">

C is low. C++ is bloated.

Java is a decent programming language, however the Java VM sort of
sucks dick.

Between the Late 60's up to the late 80's, the *nix world function
pretty well without Linux. I'm sure if Linux ever dies, the *nix will
still function pretty well.

Personally, I think what you wrote is just a waste of time. I got the
impression that it's mostly crap. But whatever. I'm just some lowly
graduate student.
</POST>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T13:22:00 </POSTDATE>
On Aug 18, 11:11 am, Chad &lt;cdal ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Aug 18, 9:59 am, &quot;guitarstru ... @gmail.com&quot;

&gt; &lt;guitarstru ... @gmail.com&gt; wrote:
&gt; &gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; &gt; new language / scripting engine / network protocol / data storage
&gt; &gt; specification - all in one. I actually built at my last job a parser
&gt; &gt; that did all this - using one unified language. It worked so well I
&gt; &gt; thought I'd sit down and write a definition for the language. I know a
&gt; &gt; lot of people are coming up with languages 'like' this, but I truly
&gt; &gt; think what I have here is good enough to let others see:

&gt; &gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt; &gt; Please forgive the name... I know its lame :)

&gt; &gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; &gt; in building a parser to do this ? I've already done one in Java but
&gt; &gt; was thinking of maybe building one in a lower level language like C++
&gt; &gt; for the sake of speed - maybe on Linux.

&gt; C is low. C++ is bloated.

&gt; Java is a decent programming language, however the Java VM sort of
&gt; sucks dick.

&gt; Between the Late 60's up to the late 80's, the *nix world function
&gt; pretty well without Linux. I'm sure if Linux ever dies, the *nix will
&gt; still function pretty well.

&gt; Personally, I think what you wrote is just a waste of time. I got the
&gt; impression that it's mostly crap. But whatever. I'm just some lowly
&gt; graduate student.
">

I appreciate what you have to say. But, given the fact you had nothing
good to say about anything, I feel rather honored you lumped what I
wrote with such 'bad' items as &quot;Linux&quot;, &quot;C++&quot;, &quot;C&quot;, and the Java JVM.
Thank you - in a way, you've inspired me :)
</POST>
<POST>
<POSTER> Logan Shaw &lt;lshaw-use...@austin.rr.com&gt; </POSTER>
<POSTDATE> 2007-08-18T13:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
guitarstru ... @gmail.com wrote:
&gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; new language / scripting engine / network protocol / data storage
&gt; specification - all in one. I actually built at my last job a parser
&gt; that did all this - using one unified language. It worked so well I
&gt; thought I'd sit down and write a definition for the language. I know a
&gt; lot of people are coming up with languages 'like' this, but I truly
&gt; think what I have here is good enough to let others see:

&gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj
">

I didn't read every word, but I read over it a little bit and I wasn't
sure from the document what the main idea behind the language was.  I
think the document (like many) would benefit from more introductory
conceptual stuff that helps a reader who's never heard of it understand
what they're reading about, what it is, what it's for, what it's similar
to and different from, and what the rest of the document is going to
tell them.  Explain what you mean by &quot;generic&quot;, for example.  Does
that mean it can be used for both imperative and functional programming
styles?  Or does it mean it is a syntax that can represent anything,
not just code?

Also, I wasn't sure how this is different than other languages that
shoot for being generic.  Does it do anything XML doesn't?  What about
Lisp?  What about TCL?  In particular, TCL seems to be sorta similar.
If it does the same things that one of these other languages does, then
it needs to do it better.  :-)

<QUOTE PREVIOUSPOST="
&gt; Please forgive the name... I know its lame :)
">

It's not terrible, but &quot;GCL&quot; is already used for GNU Common Lisp, which
is too confusing in my opinion.

<QUOTE PREVIOUSPOST="
&gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; in building a parser to do this ? I've already done one in Java but
&gt; was thinking of maybe building one in a lower level language like C++
&gt; for the sake of speed - maybe on Linux.
">

If it's just a parser you're writing, I would shoot for making it
platform-neutral.

- Logan
</POST>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T13:56:00 </POSTDATE>
Hey Thanks Logan, that's the exact feedback I was looking for.
Appreciate it a lot. I think I was trying to be too abstract in what I
wrote. I'll go back and edit it up a little.
</POST>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T14:46:00 </POSTDATE>
I've updated the document with a summary.
</POST>
<POST>
<POSTER> Chad &lt;cdal...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-18T18:15:00 </POSTDATE>
On Aug 18, 10:22 am, &quot;guitarstru ... @gmail.com&quot;

<QUOTE PREVIOUSPOST="
&lt;guitarstru ... @gmail.com&gt; wrote:
&gt; On Aug 18, 11:11 am, Chad &lt;cdal ... @gmail.com&gt; wrote:

&gt; &gt; On Aug 18, 9:59 am, &quot;guitarstru ... @gmail.com&quot;

&gt; &gt; &lt;guitarstru ... @gmail.com&gt; wrote:
&gt; &gt; &gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; &gt; &gt; new language / scripting engine / network protocol / data storage
&gt; &gt; &gt; specification - all in one. I actually built at my last job a parser
&gt; &gt; &gt; that did all this - using one unified language. It worked so well I
&gt; &gt; &gt; thought I'd sit down and write a definition for the language. I know a
&gt; &gt; &gt; lot of people are coming up with languages 'like' this, but I truly
&gt; &gt; &gt; think what I have here is good enough to let others see:

&gt; &gt; &gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt; &gt; &gt; Please forgive the name... I know its lame :)

&gt; &gt; &gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; &gt; &gt; in building a parser to do this ? I've already done one in Java but
&gt; &gt; &gt; was thinking of maybe building one in a lower level language like C++
&gt; &gt; &gt; for the sake of speed - maybe on Linux.

&gt; &gt; C is low. C++ is bloated.

&gt; &gt; Java is a decent programming language, however the Java VM sort of
&gt; &gt; sucks dick.

&gt; &gt; Between the Late 60's up to the late 80's, the *nix world function
&gt; &gt; pretty well without Linux. I'm sure if Linux ever dies, the *nix will
&gt; &gt; still function pretty well.

&gt; &gt; Personally, I think what you wrote is just a waste of time. I got the
&gt; &gt; impression that it's mostly crap. But whatever. I'm just some lowly
&gt; &gt; graduate student.

&gt; I appreciate what you have to say. But, given the fact you had nothing
&gt; good to say about anything, I feel rather honored you lumped what I
&gt; wrote with such 'bad' items as &quot;Linux&quot;, &quot;C++&quot;, &quot;C&quot;, and the Java JVM.
&gt; Thank you - in a way, you've inspired me :)
">

You can form a complete sentence. That's a start. Now, looking over
your summary, I saw a few things that irked me.

&quot;In doing programming / application development / scripting in Java, C+
+, C, HTML, Javascript, XML, SQL, Coldfusion, PHP, and reading up on
other languages (over the past 10 years), &quot;

You seem to be implying that C++ and C are scripting langauges.

&quot;In my opinion, either a language becomes bloated with too much stuff,
and can consequently &quot;do everything&quot; (take C++ for example) but is
hard to work with or learn,&quot;

C++ can't do everything. If you had spent a week doing Lisp
programming, you would quickly realized that C++ lags behind the
common lisp in a lot of things.

&quot;I could write scripts in a file (similar to bash script files) &quot;

Maybe I'm ignorant, but how does one write a scripts in a file? The
only thing I can think of is:

[cdalten@localhost ~]$ echo &quot;echo 'the author of this language is a
dumbass' &quot; &gt;&gt; scriptme

I lost interest in your client server example.
</POST>
<POST>
<POSTER> Gene &lt;gene.ress...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-19T00:28:00 </POSTDATE>
On Aug 18, 1:53 pm, Logan Shaw &lt;lshaw-use ... @austin.rr.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; guitarstru ... @gmail.com wrote:
&gt; &gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; &gt; new language / scripting engine / network protocol / data storage
&gt; &gt; specification - all in one. I actually built at my last job a parser
&gt; &gt; that did all this - using one unified language. It worked so well I
&gt; &gt; thought I'd sit down and write a definition for the language. I know a
&gt; &gt; lot of people are coming up with languages 'like' this, but I truly
&gt; &gt; think what I have here is good enough to let others see:

&gt; &gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt; I didn't read every word, but I read over it a little bit and I wasn't
&gt; sure from the document what the main idea behind the language was.  I
&gt; think the document (like many) would benefit from more introductory
&gt; conceptual stuff that helps a reader who's never heard of it understand
&gt; what they're reading about, what it is, what it's for, what it's similar
&gt; to and different from, and what the rest of the document is going to
&gt; tell them.  Explain what you mean by &quot;generic&quot;, for example.  Does
&gt; that mean it can be used for both imperative and functional programming
&gt; styles?  Or does it mean it is a syntax that can represent anything,
&gt; not just code?

&gt; Also, I wasn't sure how this is different than other languages that
&gt; shoot for being generic.  Does it do anything XML doesn't?  What about
&gt; Lisp?  What about TCL?  In particular, TCL seems to be sorta similar.
&gt; If it does the same things that one of these other languages does, then
&gt; it needs to do it better.  :-)

&gt; &gt; Please forgive the name... I know its lame :)

&gt; It's not terrible, but &quot;GCL&quot; is already used for GNU Common Lisp, which
&gt; is too confusing in my opinion.

&gt; &gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; &gt; in building a parser to do this ? I've already done one in Java but
&gt; &gt; was thinking of maybe building one in a lower level language like C++
&gt; &gt; for the sake of speed - maybe on Linux.

&gt; If it's just a parser you're writing, I would shoot for making it
&gt; platform-neutral.

&gt;    - Logan
">

You nailed it.  All the goals guitarstrummr describes are the same as
Lisp's.
</POST>
<POST>
<POSTER> &quot;Jim Langston&quot; &lt;tazmas...@rocketmail.com&gt; </POSTER>
<POSTDATE> 2007-08-19T05:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Gene&quot; &lt;gene.ress ... @gmail.com&gt; wrote in message
">

news:1187497723.088160.82320@19g2000hsx.googlegroups.com ...

<QUOTE PREVIOUSPOST="
&gt; On Aug 18, 1:53 pm, Logan Shaw &lt;lshaw-use ... @austin.rr.com&gt; wrote:
&gt;&gt; guitarstru ... @gmail.com wrote:
&gt;&gt; &gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt;&gt; &gt; new language / scripting engine / network protocol / data storage
&gt;&gt; &gt; specification - all in one. I actually built at my last job a parser
&gt;&gt; &gt; that did all this - using one unified language. It worked so well I
&gt;&gt; &gt; thought I'd sit down and write a definition for the language. I know a
&gt;&gt; &gt; lot of people are coming up with languages 'like' this, but I truly
&gt;&gt; &gt; think what I have here is good enough to let others see:

&gt;&gt; &gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt;&gt; I didn't read every word, but I read over it a little bit and I wasn't
&gt;&gt; sure from the document what the main idea behind the language was.  I
&gt;&gt; think the document (like many) would benefit from more introductory
&gt;&gt; conceptual stuff that helps a reader who's never heard of it understand
&gt;&gt; what they're reading about, what it is, what it's for, what it's similar
&gt;&gt; to and different from, and what the rest of the document is going to
&gt;&gt; tell them.  Explain what you mean by &quot;generic&quot;, for example.  Does
&gt;&gt; that mean it can be used for both imperative and functional programming
&gt;&gt; styles?  Or does it mean it is a syntax that can represent anything,
&gt;&gt; not just code?

&gt;&gt; Also, I wasn't sure how this is different than other languages that
&gt;&gt; shoot for being generic.  Does it do anything XML doesn't?  What about
&gt;&gt; Lisp?  What about TCL?  In particular, TCL seems to be sorta similar.
&gt;&gt; If it does the same things that one of these other languages does, then
&gt;&gt; it needs to do it better.  :-)

&gt;&gt; &gt; Please forgive the name... I know its lame :)

&gt;&gt; It's not terrible, but &quot;GCL&quot; is already used for GNU Common Lisp, which
&gt;&gt; is too confusing in my opinion.

&gt;&gt; &gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt;&gt; &gt; in building a parser to do this ? I've already done one in Java but
&gt;&gt; &gt; was thinking of maybe building one in a lower level language like C++
&gt;&gt; &gt; for the sake of speed - maybe on Linux.

&gt;&gt; If it's just a parser you're writing, I would shoot for making it
&gt;&gt; platform-neutral.

&gt;&gt;    - Logan

&gt; You nailed it.  All the goals guitarstrummr describes are the same as
&gt; Lisp's.
">

I played lisp ages ago (back in the 70's).  I couldn't stand the data files
(((((((because)))((they)))((sucked)(bigtime))) which is why I never
continued to use it.
</POST>
<POST>
<POSTER> CBFalconer &lt;cbfalco...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-08-19T10:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jim Langston wrote:
&gt; &quot;Gene&quot; &lt;gene.ress ... @gmail.com&gt; wrote in message

... snip ...

&gt;&gt; You nailed it.  All the goals guitarstrummr describes are the
&gt;&gt; same as Lisp's.

&gt; I played lisp ages ago (back in the 70's).  I couldn't stand the
&gt; data files (((((((because)))((they)))((sucked)(bigtime))) which
&gt; is why I never continued to use it.
">

Some people replace the acronym with the full name:

&quot;Lots of Insipid Silly Parenthesis&quot;   :-}

--
Chuck F (cbfalconer at maineline dot net)
Available for consulting/temporary embedded and systems.
&lt; http://cbfalconer.home.att.net &gt;

--
Posted via a free Usenet account from http://www.teranews.com
</POST>
<POST>
<POSTER> Gene &lt;gene.ress...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-19T16:49:00 </POSTDATE>
On Aug 19, 10:35 am, CBFalconer &lt;cbfalco ... @yahoo.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Jim Langston wrote:
&gt; &gt; &quot;Gene&quot; &lt;gene.ress ... @gmail.com&gt; wrote in message

&gt; ... snip ...

&gt; &gt;&gt; You nailed it.  All the goals guitarstrummr describes are the
&gt; &gt;&gt; same as Lisp's.

&gt; &gt; I played lisp ages ago (back in the 70's).  I couldn't stand the
&gt; &gt; data files (((((((because)))((they)))((sucked)(bigtime))) which
&gt; &gt; is why I never continued to use it.

&gt; Some people replace the acronym with the full name:

&gt;    &quot;Lots of Insipid Silly Parenthesis&quot;   :-}
">

Or &quot;long incomprehensible strings of parentheses.&quot;  If you have a good
editor, the whole parens thing just fades to black.  What's left is
pretty remarkable.
</POST>
<POST>
<POSTER> Walter Banks &lt;wal...@bytecraft.com&gt; </POSTER>
<POSTDATE> 2007-08-19T18:31:00 </POSTDATE>
This is very trac like. Like most functional languages
it can be very powerful. With very little work this language
can be made a true parallel processing language, something
that trac didn't implement.

Look up the internet references for trac or Calvin Mooers

Some of Doug McIlroy's papers have similar processing
techniques.

You need to formalize your grammar.

Walter Banks

<QUOTE PREVIOUSPOST="
&quot;guitarstru ... @gmail.com&quot; wrote:
&gt; Hey guys, I've for about a year now been tossing around an idea for a
&gt; new language / scripting engine / network protocol / data storage
&gt; specification - all in one. I actually built at my last job a parser
&gt; that did all this - using one unified language. It worked so well I
&gt; thought I'd sit down and write a definition for the language. I know a
&gt; lot of people are coming up with languages 'like' this, but I truly
&gt; think what I have here is good enough to let others see:

&gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj

&gt; Please forgive the name... I know its lame :)

&gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; in building a parser to do this ? I've already done one in Java but
&gt; was thinking of maybe building one in a lower level language like C++
&gt; for the sake of speed - maybe on Linux.
">
</POST>
<POST>
<POSTER> Walter Banks &lt;wal...@bytecraft.com&gt; </POSTER>
<POSTDATE> 2007-08-19T18:48:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jim Langston wrote:
&gt; &gt;&gt; It's not terrible, but &quot;GCL&quot; is already used for GNU Common Lisp, which
&gt; &gt;&gt; is too confusing in my opinion.

&gt; &gt; You nailed it.  All the goals guitarstrummr describes are the same as
&gt; &gt; Lisp's.

&gt; I played lisp ages ago (back in the 70's).  I couldn't stand the data files
&gt; (((((((because)))((they)))((sucked)(bigtime))) which is why I never
&gt; continued to use it.
">

There is one significant difference and that is the functional difference
between bracket types. This difference is small but important when
the language is used as a parser/compiler to expand syntactic shorthand
into the details of what was intended.

You point is well taken. Lisp is hard on keyboards but one of the
worlds oldest computer languages still has a place more than 50
years

w..
</POST>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-20T17:34:00 </POSTDATE>
Point well taken on the grammar guys - that's what happens when you
just want to throw an idea out there and haven't formally finished the
definition (or edited it). Unfortunately, I haven't take the time to
sit down and truly work through what I've written to make it more
readable. Sorry.

I appreciate the comments about Lisp. I was curious what other
languages (that I haven't seen) have implemented this idea. I'll look
more into it and perhaps find that I'm just reinventing the wheel :)
I'm sure I am in some ways (what new computer language isn't?), but am
totally curious if what I have here adds any fresh insight into the
world of computer programming.

As regards Chad's comment about my &quot;lumping&quot; C and C++ with scripting
languages, please try to understand that I'm being abstract
intentionally. You'll also notice your same derogatory comment
regarding my &quot;lumping&quot; together C and C++ with scripting languages
completely disregards the intentional way I clarified this by saying
&quot;programming / application development / scripting&quot;. Please, I
appreciate your feedback, but I cannot in my right mind understand why
you are so cynical. I feel you are really intelligent but can't
understand why - if you think you have this all figured out and I'm so
horrible in what I've written - that you even bother responding.

In my mind at this point, what I have written is no more than a
'definition' of what 'could be', not a definitive implementation of
the idea. Whether this would end up being translated into a compiled
language or a scripting language matters little to me. You'll notice I
lumped it together with XML too. It's not that I'm too dumb to the
know the difference, its that I'm trying to define their similarites
and come up with a document format that is a solution for all three
(compiled language, scripting language, and data storage).

Thanks for the comments everyone :)
</POST>
<POST>
<POSTER> &quot;guitarstru...@gmail.com&quot; &lt;guitarstru...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-20T19:13:00 </POSTDATE>
Hey, I have indeed just reinvented Lisp. Thanks for the pointer,
that's all I really need.
</POST>
<POST>
<POSTER> Jon Harrop &lt;j...@ffconsultancy.com&gt; </POSTER>
<POSTDATE> 2007-08-22T16:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
guitarstru ... @gmail.com wrote:
&gt; http://docs.google.com/Doc?id=dgsp8pp3_41fm75bj
">

I am unable to read that (got a PDF or HTML version) but, judging by the
discussion, I think you might find inspiration in the following languages:

F#
Haskell
OCaml
Standard ML
Scheme

They all have different properties and have yet to be unified.

<QUOTE PREVIOUSPOST="
&gt; Let me know any suggestions - good idea, bad idea, anyone interested
&gt; in building a parser to do this ? I've already done one in Java but
&gt; was thinking of maybe building one in a lower level language like C++
&gt; for the sake of speed
">

This is actually a task well suited to any of the above languages. Most
likely, solutions in most of those languages will be many times faster than
a Java or C++ implementation. Both Java and C++ are ill-suited to parsing
and extremely ill-suited to program evaluation.

--
Dr Jon D Harrop, Flying Frog Consultancy
OCaml for Scientists
http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
</POST>
<POST>
<POSTER> Beliavsky &lt;beliav...@aol.com&gt; </POSTER>
<POSTDATE> 2007-08-24T14:37:00 </POSTDATE>
On Aug 18, 1:11 pm, Chad &lt;cdal ... @gmail.com&gt; wrote:

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; C is low. C++ is bloated.

&gt; Java is a decent programming language, however the Java VM sort of
&gt; sucks dick.
">

Your mode of expression certainly does. While you are in graduate
school, why don't you learn how to write decently and intelligently?
</POST>
<POST>
<POSTER> Matthias Buelow &lt;m...@incubus.de&gt; </POSTER>
<POSTDATE> 2007-08-26T15:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Walter Banks &lt;wal ... @bytecraft.com&gt; wrote:
&gt; You point is well taken. Lisp is hard on keyboards but one of the
&gt; worlds oldest computer languages still has a place more than 50
&gt; years
">

The most amazing (or maybe frightening?) thing is, that Lisp is still at
the forefront of programming, and all the current trends (especially the
mangling of Java with XML and scripting tools such as python) seem to
(slowly) converge towards Lisp (not necessarily Common Lisp, though).
</POST>
<POST>
<POSTER> Jon Harrop &lt;j...@ffconsultancy.com&gt; </POSTER>
<POSTDATE> 2007-08-27T09:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Matthias Buelow wrote:
&gt; Walter Banks &lt;wal ... @bytecraft.com&gt; wrote:
&gt;&gt; You point is well taken. Lisp is hard on keyboards but one of the
&gt;&gt; worlds oldest computer languages still has a place more than 50
&gt;&gt; years

&gt; The most amazing (or maybe frightening?) thing is, that Lisp is still at
&gt; the forefront of programming, and all the current trends (especially the
&gt; mangling of Java with XML and scripting tools such as python) seem to
&gt; (slowly) converge towards Lisp (not necessarily Common Lisp, though).
">

Lisp is seriously out of date is most respects (e.g. pattern matching, tail
calls, concurrency, callcc, monads) and major new developments are
diverging from Lisp, like F#.

Granted that some people have pulled in the Lisp direction. It was said that
Java dragged programmers halfway from C to Common Lisp, which explains why
Java is so verbose, slow, difficult to maintain and error prone.

Lisp is the past. F# is the future.

--
Dr Jon D Harrop, Flying Frog Consultancy
OCaml for Scientists
http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
</POST>
<POST>
<POSTER> &quot;mensana...@aol.com&quot; &lt;mensana...@aol.com&gt; </POSTER>
<POSTDATE> 2007-08-27T14:18:00 </POSTDATE>
On Aug 27, 8:24 am, Jon Harrop &lt;j ... @ffconsultancy.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Matthias Buelow wrote:
&gt; &gt; Walter Banks &lt;wal ... @bytecraft.com&gt; wrote:
&gt; &gt;&gt; You point is well taken. Lisp is hard on keyboards but one of the
&gt; &gt;&gt; worlds oldest computer languages still has a place more than 50
&gt; &gt;&gt; years

&gt; &gt; The most amazing (or maybe frightening?) thing is, that Lisp is still at
&gt; &gt; the forefront of programming, and all the current trends (especially the
&gt; &gt; mangling of Java with XML and scripting tools such as python) seem to
&gt; &gt; (slowly) converge towards Lisp (not necessarily Common Lisp, though).

&gt; Lisp is seriously out of date is most respects (e.g. pattern matching, tail
&gt; calls, concurrency, callcc, monads) and major new developments are
&gt; diverging from Lisp, like F#.

&gt; Granted that some people have pulled in the Lisp direction. It was said that
&gt; Java dragged programmers halfway from C to Common Lisp, which explains why
&gt; Java is so verbose, slow, difficult to maintain and error prone.

&gt; Lisp is the past. F# is the future.
">

It is?

How much future is there in a language that doesn't
have an exponentiation operator?

And where the BigInteger type doesn't have a pow() method?

F# is WORTHLESS (has no value). I can't even convert my
Python programs to it. Whom do you envision is going to
put up with such nonsense?

For that matter, why is half the documentaion blank?

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; --
&gt; Dr Jon D Harrop, Flying Frog Consultancy
&gt; OCaml for Scientists http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
">
</POST>
<POST>
<POSTER> CBFalconer &lt;cbfalco...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-08-27T17:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jon Harrop wrote:

... snip ...

&gt; Lisp is seriously out of date is most respects (e.g. pattern
&gt; matching, tail calls, concurrency, callcc, monads) and major new
&gt; developments are diverging from Lisp, like F#.

&gt; Granted that some people have pulled in the Lisp direction. It was
&gt; said that Java dragged programmers halfway from C to Common Lisp,
&gt; which explains why Java is so verbose, slow, difficult to maintain
&gt; and error prone.
">

Believe it or not, you are allowed to use libraries, write
procedures, etc. in the Lisp languages.

--
Chuck F (cbfalconer at maineline dot net)
Available for consulting/temporary embedded and systems.
&lt; http://cbfalconer.home.att.net &gt;

--
Posted via a free Usenet account from http://www.teranews.com
</POST>
<POST>
<POSTER> Jon Harrop &lt;j...@ffconsultancy.com&gt; </POSTER>
<POSTDATE> 2007-08-29T05:22:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
CBFalconer wrote:
&gt; Believe it or not, you are allowed to use libraries, write
&gt; procedures, etc. in the Lisp languages.
">

Greenspun.

--
Dr Jon D Harrop, Flying Frog Consultancy
OCaml for Scientists
http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
</POST>
<POST>
<POSTER> Beliavsky &lt;beliav...@aol.com&gt; </POSTER>
<POSTDATE> 2007-08-29T13:04:00 </POSTDATE>
On Aug 27, 2:18 pm, &quot;mensana ... @aol.com&quot; &lt;mensana ... @aol.com&gt; wrote:

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; How much future is there in a language that doesn't
&gt; have an exponentiation operator?
">

C and C++ will be around for a long time, even though they require the
use of the pow function for exponentiation.
</POST>
<POST>
<POSTER> Richard Heathfield &lt;r...@see.sig.invalid&gt; </POSTER>
<POSTDATE> 2007-08-29T13:13:00 </POSTDATE>
Beliavsky said:

<QUOTE PREVIOUSPOST="
&gt; On Aug 27, 2:18 pm, &quot;mensana ... @aol.com&quot; &lt;mensana ... @aol.com&gt; wrote:

&gt; &lt;snip&gt;

&gt;&gt; How much future is there in a language that doesn't
&gt;&gt; have an exponentiation operator?

&gt; C and C++ will be around for a long time, even though they require the
&gt; use of the pow function for exponentiation.
">

Well, there is an alternative, which is to do the exponentiation by
hand, which is trivial for integer exponents (but admittedly rather
harder for rationals).

--
Richard Heathfield &lt; http://www.cpax.org.uk &gt;
Email: -www. +rjh@
Google users: &lt; http://www.cpax.org.uk/prg/writings/googly.php &gt;
&quot;Usenet is a strange place&quot; - dmr 29 July 1999
</POST>
<POST>
<POSTER> &quot;mensana...@aol.com&quot; &lt;mensana...@aol.com&gt; </POSTER>
<POSTDATE> 2007-08-29T18:00:00 </POSTDATE>
On Aug 29, 12:04 pm, Beliavsky &lt;beliav ... @aol.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Aug 27, 2:18 pm, &quot;mensana ... @aol.com&quot; &lt;mensana ... @aol.com&gt; wrote:

&gt; &lt;snip&gt;

&gt; &gt; How much future is there in a language that doesn't
&gt; &gt; have an exponentiation operator?

&gt; C and C++ will be around for a long time, even though they require the
&gt; use of the pow function for exponentiation.
">

Did you miss where I pointed out that the BigInteger data type
doesn't have a pow method?

There's no excuse for this in a new language (which has no
legacy code to support).
</POST>
<POST>
<POSTER> Jon Harrop &lt;j...@ffconsultancy.com&gt; </POSTER>
<POSTDATE> 2007-08-29T18:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
mensana ... @aol.com wrote:
&gt; How much future is there in a language that doesn't
&gt; have an exponentiation operator?
">

F# does have an exponent operator (**).

<QUOTE PREVIOUSPOST="
&gt; And where the BigInteger type doesn't have a pow() method?
">

F# does have a BigInt.pow method.

<QUOTE PREVIOUSPOST="
&gt; F# is WORTHLESS (has no value). I can't even convert my
&gt; Python programs to it.
">

You already have seamless interoperability thanks to IronPython.

<QUOTE PREVIOUSPOST="
&gt; Whom do you envision is going to put up with such nonsense?
">

If Mono catches on, almost everyone.

--
Dr Jon D Harrop, Flying Frog Consultancy
OCaml for Scientists
http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
</POST>
<POST>
<POSTER> &quot;mensana...@aol.com&quot; &lt;mensana...@aol.com&gt; </POSTER>
<POSTDATE> 2007-08-29T20:00:00 </POSTDATE>
On Aug 29, 5:20 pm, Jon Harrop &lt;j ... @ffconsultancy.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; mensana ... @aol.com wrote:
&gt; &gt; How much future is there in a language that doesn't
&gt; &gt; have an exponentiation operator?

&gt; F# does have an exponent operator (**).
">

Didn't see it. Maybe a documentation ommission. I notice you
didn't say anything about that.

<QUOTE PREVIOUSPOST="
&gt; &gt; And where the BigInteger type doesn't have a pow() method?

&gt; F# does have a BigInt.pow method.
">

Oh? Seems only for floats.

C:\F#\fsharp-1.1.13.8\FSharp-1.1.13.8\bin&gt;fsi

MSR F# Interactive, (c) Microsoft Corporation, All Rights Reserved
F# Version 1.1.13.8, compiling for .NET Framework Version v2.0.50727

NOTE:
NOTE: See 'fsi --help' for flags
NOTE:
NOTE: Commands: #r &lt;string&gt;;;    reference (dynamically load) the
given DLL.
NOTE:           #I &lt;string&gt;;;    add the given search path for
referenced DLLs.
NOTE:           #use &lt;string&gt;;;  accept input from the given file.
NOTE:           #load &lt;string&gt; ...&lt;string&gt;;;
NOTE:                            load the given file(s) as a
compilation unit.
NOTE:           #time;;          toggle timing on/off.
NOTE:           #types;;         toggle display of types on/off.
NOTE:           #quit;;          exit.
NOTE:
NOTE: Visit the F# website at http://research.microsoft.com/fsharp .
NOTE: Bug reports to fsb ... @microsoft.com. Enjoy!

<QUOTE PREVIOUSPOST="
&gt; let a = 3;;
">

val a : int

<QUOTE PREVIOUSPOST="
&gt; let b = 3**3;;
">

let b = 3**3;;
--------^^
stdin(19,8): error: FS0001: This expression has type
int
but is here used with type
float
let b = 3**3;;
-----------^^
stdin(19,11): error: FS0001: This expression has type
int
but is here used with type
float
stopped due to error

<QUOTE PREVIOUSPOST="
&gt; let b = 3**3.0;;
">

let b = 3**3.0;;
--------^^
stdin(20,8): error: FS0001: This expression has type
int
but is here used with type
float
stopped due to error

<QUOTE PREVIOUSPOST="
&gt; let b = 3.0**3.0;;
">

val b : float

But maybe BigInt has it even though ints don't
(but I doubt it - have you got an actual piece of
code I can try?)

<QUOTE PREVIOUSPOST="
&gt; &gt; F# is WORTHLESS (has no value). I can't even convert my
&gt; &gt; Python programs to it.

&gt; You already have seamless interoperability thanks to IronPython.
">

I haven't checked. Is IronPython useable yet? And I need support
for the GMP library, it's worthless without it.

<QUOTE PREVIOUSPOST="
&gt; &gt; Whom do you envision is going to put up with such nonsense?

&gt; If Mono catches on, almost everyone.

&gt; --
&gt; Dr Jon D Harrop, Flying Frog Consultancy
&gt; OCaml for Scientists http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
">
</POST>
<POST>
<POSTER> Jon Harrop &lt;j...@ffconsultancy.com&gt; </POSTER>
<POSTDATE> 2007-08-30T04:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
mensana ... @aol.com wrote:
&gt; But maybe BigInt has it even though ints don't
&gt; (but I doubt it - have you got an actual piece of
&gt; code I can try?)
">

BigInt.pow 17I 345I

<QUOTE PREVIOUSPOST="
&gt;&gt; You already have seamless interoperability thanks to IronPython.

&gt; I haven't checked. Is IronPython useable yet?
">

No idea. I wouldn't touch Python with a bargepole: its far too slow for
serious work. ;-)

--
Dr Jon D Harrop, Flying Frog Consultancy
OCaml for Scientists
http://www.ffconsultancy.com/products/ocaml_for_scientists/?usenet
</POST>
</TEXT>
</BODY>
</DOC>
