<DOC>
<DOCID> eng-NG-31-126402-9143212 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-11-08T18:25:00 </DATETIME>
<BODY>
<HEADLINE>
Why can't you slice an array @a[3..-1]?
</HEADLINE>
<TEXT>
<POST>
<POSTER> Clint Olsen &lt;clint.ol...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-08T18:25:00 </POSTDATE>
I've never figured out why this intuitive syntax does not work.  It should,
because doing $# inside the subscripts is really awkward, and I don't see
any ambguity here.  Either that you have to use @a[3 .. scalar(@a) - 1 ].

Is there an easier way to do this?

Thanks,

-Clint
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-08T18:36:00 </POSTDATE>
On Thu, 08 Nov 2007 17:25:48 -0600, Clint Olsen

<QUOTE PREVIOUSPOST="
&lt;clint.ol ... @gmail.com&gt; wrote:
&gt;I've never figured out why this intuitive syntax does not work.  It should,
&gt;because doing $# inside the subscripts is really awkward, and I don't see
&gt;any ambguity here.  Either that you have to use @a[3 .. scalar(@a) - 1 ].

&gt;Is there an easier way to do this?
">

Basically, no. But you don't need the explicit scalar():

@a[3 .. (@a - 1)]

would do. But since we're talking about an index, $#a would be even
better:

@a[3 .. $#a]

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Clint Olsen &lt;clint.ol...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-08T20:15:00 </POSTDATE>
On 2007-11-08, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Basically, no. But you don't need the explicit scalar():

&gt;   @a[3 .. (@a - 1)]

&gt; would do. But since we're talking about an index, $#a would be even
&gt; better:

&gt;   @a[3 .. $#a]
">

This doesn't work for array references.  How can I perform the same ($#) on
an array reference?

I got this when trying to:

DB&lt;10&gt; x $#{@$_}
Bizarre copy of ARRAY in leave at (eval
76)[/nfs/pdx/disks/pdx_otools/lib/perl5/5.8.5/perl5db.pl:620] line 2.

And $_ is an array reference.

-Clint
</POST>
<POST>
<POSTER> Ilya Zakharevich &lt;nospam-ab...@ilyaz.org&gt; </POSTER>
<POSTDATE> 2007-11-08T20:23:00 </POSTDATE>
[A complimentary Cc of this posting was sent to
Clint Olsen
&lt;clint.ol ... @gmail.com&gt;], who wrote in article &lt;slrnfj76ns.1499.clint.ol ... @belle.0lsen.net&gt;:

<QUOTE PREVIOUSPOST="
&gt; I've never figured out why this intuitive syntax does not work.  It should,
&gt; because doing $# inside the subscripts is really awkward, and I don't see
&gt; any ambguity here.
">

Me too.  3..-1 INAMBIGUOUSLY returns an empty list.

Hope this helps,
Ilya
</POST>
<POST>
<POSTER> Clint Olsen &lt;clint.ol...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-08T20:34:00 </POSTDATE>
On 2007-11-08, Clint Olsen &lt;clint.ol ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I've never figured out why this intuitive syntax does not work.  It should,
&gt; because doing $# inside the subscripts is really awkward, and I don't see
&gt; any ambguity here.  Either that you have to use @a[3 .. scalar(@a) - 1 ].
">

I think I figured out why this doesn't work the way I expected.  Since the
'..' operator creates a list (series) from the left value to the right, it
doesn't make sense to do this from a valid index to -1.

And I also through experimentation figured out why the array reference
doesn't work.  The syntax appears to be:

$#$_

Where $_ is an array reference.  I can't explain why this works however
based on my knowledge of perl and references...

-Clint
</POST>
<POST>
<POSTER> Paul Lalli &lt;mri...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-08T20:46:00 </POSTDATE>
On Nov 8, 8:34 pm, Clint Olsen &lt;clint.ol ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; And I also through experimentation figured out why the array
&gt; reference doesn't work.  The syntax appears to be:

&gt; $#$_

&gt; Where $_ is an array reference.  I can't explain why this works
&gt; however based on my knowledge of perl and references...
">

The rule is that you take the reference, and treat the reference as
the &quot;name&quot; of the array.  Then every other operation is exactly the
same as it is for a normal array.

Normal array:
@foo - &quot;name&quot; of array is foo.
Normal array element:
$foo[0]
Normal array slice:
@foo[0..5];
Normal array last index:
$#foo

Array reference:
$ref - &quot;name&quot; of array is $ref.
Array reference element:
$$ref[0]
Array reference slice:
@$ref[0..5]
Array reference last index:
$#$ref

Paul Lalli
</POST>
<POST>
<POSTER> Tad McClellan &lt;ta...@seesig.invalid&gt; </POSTER>
<POSTDATE> 2007-11-08T22:42:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Clint Olsen &lt;clint.ol ... @gmail.com&gt; wrote:
&gt; The syntax appears to be:

&gt; $#$_

&gt; Where $_ is an array reference.  I can't explain why this works however
&gt; based on my knowledge of perl and references...
">

Simply apply &quot;Use Rule 1&quot; from perlreftut.pod.

I like to do it in 3 steps:

1) $#a              # pretend it is a normal array
2) $#{ }            # replace the name with a block
3) $#{ $_ }         # fillin the block with something that returns
# the appropriate type of reference (array in this case)

If what is in the block is a simple, standalone scalar, then you
are allowed to leave out the curly braces:

$#$_

--
Tad McClellan
email: perl -le &quot;print scalar reverse qq/moc.noitatibaher\100cmdat/&quot;
</POST>
<POST>
<POSTER> Martien Verbruggen &lt;m...@tradingpost.com.au&gt; </POSTER>
<POSTDATE> 2007-11-09T02:11:00 </POSTDATE>
On Thu, 08 Nov 2007 19:15:43 -0600,
Clint Olsen &lt;clint.ol ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On 2007-11-08, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:
&gt;&gt; Basically, no. But you don't need the explicit scalar():

&gt;&gt;   @a[3 .. (@a - 1)]

&gt;&gt; would do. But since we're talking about an index, $#a would be even
&gt;&gt; better:

&gt;&gt;   @a[3 .. $#a]

&gt; This doesn't work for array references.  How can I perform the same ($#) on
&gt; an array reference?
">

my $ra = \@a;
my $last_index = $#$ra;

Martien
--
|
Martien Verbruggen      | I think there is a world market for maybe
| five computers. -- Thomas Watson, chairman of
| IBM, 1943
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T05:22:00 </POSTDATE>
On Thu, 08 Nov 2007 19:15:43 -0600, Clint Olsen

<QUOTE PREVIOUSPOST="
&lt;clint.ol ... @gmail.com&gt; wrote:
&gt;This doesn't work for array references.  How can I perform the same ($#) on
&gt;an array reference?

&gt;I got this when trying to:

&gt;DB&lt;10&gt; x $#{@$_}
&gt;Bizarre copy of ARRAY in leave at (eval
&gt;76)[/nfs/pdx/disks/pdx_otools/lib/perl5/5.8.5/perl5db.pl:620] line 2.

&gt;And $_ is an array reference.
">

It does work. Of course you're not dereferencing the right way, AND it
must be a NAMED reference.

pilsner:~ [11:22:48]$ perl -le '$a=[1..5];print @$a[3..$#$a]'
45

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T05:25:00 </POSTDATE>
On Thu, 08 Nov 2007 19:34:05 -0600, Clint Olsen

<QUOTE PREVIOUSPOST="
&lt;clint.ol ... @gmail.com&gt; wrote:
&gt;$#$_

&gt;Where $_ is an array reference.  I can't explain why this works however
&gt;based on my knowledge of perl and references...
">

It's kind of a corner case. The whole $#array thing is rather ugly
IMHO. Perl 6 will have suitable methods instead.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Paul Lalli &lt;mri...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T06:37:00 </POSTDATE>
On Nov 9, 5:22 am, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; It does work. Of course you're not dereferencing the right way,
&gt; AND it must be a NAMED reference.
">

Says who?

$ perl -le'print $#{[qw/a b c d e/]}'
4

Paul Lalli
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T09:09:00 </POSTDATE>
On Fri, 09 Nov 2007 03:37:50 -0800, Paul Lalli &lt;mri ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt; It does work. Of course you're not dereferencing the right way,
&gt;&gt; AND it must be a NAMED reference.

&gt;Says who?

&gt;$ perl -le'print $#{[qw/a b c d e/]}'
&gt;4
">

I *said* that! /me stands corrected. But... err well, it's kind of
unlikely that one may want say

@{[qw/a b c d e/]}[3..$#{[qw/a b c d e/]}]

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Paul Lalli &lt;mri...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T09:59:00 </POSTDATE>
On Nov 9, 9:09 am, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Fri, 09 Nov 2007 03:37:50 -0800, Paul Lalli &lt;mri ... @gmail.com&gt;
&gt; wrote:

&gt; &gt;&gt; It does work. Of course you're not dereferencing the right way,
&gt; &gt;&gt; AND it must be a NAMED reference.

&gt; &gt;Says who?

&gt; &gt;$ perl -le'print $#{[qw/a b c d e/]}'
&gt; &gt;4

&gt; I *said* that! /me stands corrected. But... err well, it's kind of
&gt; unlikely that one may want say

&gt;   @{[qw/a b c d e/]}[3..$#{[qw/a b c d e/]}]
">

Agreed, but I could conceive of a slightly more likely requirement:

print &quot;Enter two numbers:\n&quot;;
my ($x, $y) = split / /, &lt;&gt;;
my @skip_three = @{[$x .. $y]}[3..$#{[$x .. $y]}];

Ugly as sin, and I would never do it like that (I would just add 3 to
$x).... but it is possible.

Paul Lalli
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-09T10:48:00 </POSTDATE>
On Fri, 9 Nov 2007 01:23:09 +0000 (UTC) Ilya Zakharevich &lt;nospam-ab ... @ilyaz.org&gt; wrote:

IZ&gt; [A complimentary Cc of this posting was sent to
IZ&gt; Clint Olsen
IZ&gt; &lt;clint.ol ... @gmail.com&gt;], who wrote in article &lt;slrnfj76ns.1499.clint.ol ... @belle.0lsen.net&gt;:

<QUOTE PREVIOUSPOST="
&gt;&gt; I've never figured out why this intuitive syntax does not work.  It should,
&gt;&gt; because doing $# inside the subscripts is really awkward, and I don't see
&gt;&gt; any ambguity here.
">

IZ&gt; Me too.  3..-1 INAMBIGUOUSLY returns an empty list.

Well obviously in a general context, but Perl semantics for array
offsets also specifically know about negative numbers, so this is a
conflict between two DWIM modes (and I think the array offset DWIM mode
should win).  I actually did this just the other day (using $#array as
the last offset) and thought &quot;hmm, wouldn't it be nice to use -1&quot; so
Clint's question makes sense.

I don't see why it's not possible, *within the context of an array
slice*, to override the .. and ... operators to replace negative numbers
with the corresponding array offsets.  It might break existing code, but
it really does make sense to users, so at least as a pragma it would be
nice.  Plus, the Perl golf possibilities are really good :)

Ted
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T11:43:00 </POSTDATE>
On Fri, 09 Nov 2007 06:59:38 -0800, Paul Lalli &lt;mri ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt;   @{[qw/a b c d e/]}[3..$#{[qw/a b c d e/]}]

&gt;Agreed, but I could conceive of a slightly more likely requirement:

&gt;print &quot;Enter two numbers:\n&quot;;
&gt;my ($x, $y) = split / /, &lt;&gt;;
&gt;my @skip_three = @{[$x .. $y]}[3..$#{[$x .. $y]}];
">

Yep, slightly more reasonable. I don't like repetition, though and if
I really had to do it &quot;like that&quot; I'd probably do

my @skip_three = map @$_[3..$#$_], [$x .. $y];
# modulo typos

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T11:44:00 </POSTDATE>
On Fri, 09 Nov 2007 09:48:21 -0600, Ted Zlatanov &lt;t ... @lifelogs.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;I don't see why it's not possible, *within the context of an array
&gt;slice*, to override the .. and ... operators to replace negative numbers
&gt;with the corresponding array offsets.  It might break existing code, but
&gt;it really does make sense to users, so at least as a pragma it would be
&gt;nice.  Plus, the Perl golf possibilities are really good :)
">

Personally I would find it terribly ugly. Perhaps some other kind of
shortcut altogether.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> xhos...@gmail.com </POSTER>
<POSTDATE> 2007-11-09T12:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Paul Lalli &lt;mri ... @gmail.com&gt; wrote:
&gt; On Nov 9, 5:22 am, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:
&gt; &gt; It does work. Of course you're not dereferencing the right way,
&gt; &gt; AND it must be a NAMED reference.

&gt; Says who?

&gt; $ perl -le'print $#{[qw/a b c d e/]}'
&gt; 4
">

OK, now put that construct in the slice.

This works, but it is pretty much cheating as you have two array references
rather than one:

perl -le 'print (qw/a b c d e/)[3..$#{[qw/a b c d e/]}]'

Xho

--
-------------------- http://NewsReader.Com/ --------------------
The costs of publication of this article were defrayed in part by the
payment of page charges. This article must therefore be hereby marked
advertisement in accordance with 18 U.S.C. Section 1734 solely to indicate
this fact.
</POST>
<POST>
<POSTER> xhos...@gmail.com </POSTER>
<POSTDATE> 2007-11-09T12:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Clint Olsen &lt;clint.ol ... @gmail.com&gt; wrote:
&gt; I've never figured out why this intuitive syntax does not work.  It
&gt; should, because doing $# inside the subscripts is really awkward, and I
&gt; don't see any ambguity here.
">

It can do either what you (and I) think it should do, or it can do what it
currently *does* do (which is also what it currently does, and presumably
would still do under your proposed change, outside of the slice context).
So that is two things it might reasonably by expected to do.  An ambiguity.

Xho

--
-------------------- http://NewsReader.Com/ --------------------
The costs of publication of this article were defrayed in part by the
payment of page charges. This article must therefore be hereby marked
advertisement in accordance with 18 U.S.C. Section 1734 solely to indicate
this fact.
</POST>
<POST>
<POSTER> Ilya Zakharevich &lt;nospam-ab...@ilyaz.org&gt; </POSTER>
<POSTDATE> 2007-11-09T13:29:00 </POSTDATE>
[A complimentary Cc of this posting was sent to
Ted Zlatanov
&lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m2640bqv22. ... @lifelogs.com&gt;:

<QUOTE PREVIOUSPOST="
&gt; IZ&gt; Me too.  3..-1 INAMBIGUOUSLY returns an empty list.

&gt; Well obviously in a general context, but Perl semantics for array
&gt; offsets also specifically know about negative numbers, so this is a
&gt; conflict between two DWIM modes (and I think the array offset DWIM mode
&gt; should win).
">

As far as I know, there is no DWIM involved.  There are two operators,
both fully-and-simply defined; array offset (which is defined for
-$#-1..$#), and range.  You REALLY want the result of an operator be
dependent on argument of which operator it is?

IMO, Perl evolution should go in DECREASING number of DWIM stuff (at
least, as a pragma), not increasing it.  (Currently, the probability
of an experienced Perl programmer to predict a result of running
*simple* Perl code is close to 0 - unless one severely binds oneself
via coding style discipline.  Too many un-/half-documented special
cases...)

<QUOTE PREVIOUSPOST="
&gt; I actually did this just the other day (using $#array as
&gt; the last offset) and thought &quot;hmm, wouldn't it be nice to use -1&quot; so
&gt; Clint's question makes sense.
">

I do it myself often too.  It does not make it a lesser evil.

Hope this helps,
Ilya
</POST>
<POST>
<POSTER> Clint Olsen &lt;clint.ol...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T13:40:00 </POSTDATE>
On 2007-11-09, Ilya Zakharevich &lt;nospam-ab ... @ilyaz.org&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; As far as I know, there is no DWIM involved.  There are two operators,
&gt; both fully-and-simply defined; array offset (which is defined for
&gt; -$#-1..$#), and range.  You REALLY want the result of an operator be
&gt; dependent on argument of which operator it is?
">

In the spirit of Perl and evaluations based on usage context, I don't see
this as a farfetched thing.  Hey, Perl invented the concept of context, not
me :)

-Clint
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T15:16:00 </POSTDATE>
On Fri, 9 Nov 2007 18:29:39 +0000 (UTC), Ilya Zakharevich

<QUOTE PREVIOUSPOST="
&lt;nospam-ab ... @ilyaz.org&gt; wrote:
&gt;IMO, Perl evolution should go in DECREASING number of DWIM stuff (at
&gt;least, as a pragma), not increasing it.  (Currently, the probability
&gt;of an experienced Perl programmer to predict a result of running
&gt;*simple* Perl code is close to 0 - unless one severely binds oneself
&gt;via coding style discipline.  Too many un-/half-documented special
&gt;cases...)
">

Well there are two conflicting POVs that should be balanced:

(i) a vector space is a relatively simple algebraic structure. A
programming language with (largely) orthogonal features is nice in
that it makes for the principle of least surprise;

(ii) a manifold (e.g.) is admittedly a richer structure than a vector
space. Perl often deviates from orthogonality for the sake of
dwimmeries. Dwimmeries often have to do with psychological perception
and linguistic issues which in turn often deviate from linearity.

As Perl is now is mostly satisfactory, and indeed I would dread upon
ranges behaving as suggested within subscripts.

The big challenge of Perl 6 is to achieve a high degree of dwimmery
while staying at the same time consistent and orthogonal. It aims, in
other words, at bringing dwimmery into the basic &quot;vector space
structure&quot;. Well, sort of.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-09T15:17:00 </POSTDATE>
On Fri, 09 Nov 2007 12:40:16 -0600, Clint Olsen

<QUOTE PREVIOUSPOST="
&lt;clint.ol ... @gmail.com&gt; wrote:
&gt;&gt; As far as I know, there is no DWIM involved.  There are two operators,
&gt;&gt; both fully-and-simply defined; array offset (which is defined for
&gt;&gt; -$#-1..$#), and range.  You REALLY want the result of an operator be
&gt;&gt; dependent on argument of which operator it is?

&gt;In the spirit of Perl and evaluations based on usage context, I don't see
&gt;this as a farfetched thing.  Hey, Perl invented the concept of context, not
&gt;me :)
">

&quot;Subscript context&quot;? No, kinda too much for me... Even worse,
subscripting strongly reminds me of mathematical usage. A range of
3..-1 returning 3..$#array reminds me of a mathematical nightmare.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Clint Olsen &lt;clint.ol...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T18:02:00 </POSTDATE>
On 2007-11-09, Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;Subscript context&quot;? No, kinda too much for me... Even worse,
&gt; subscripting strongly reminds me of mathematical usage. A range of 3..-1
&gt; returning 3..$#array reminds me of a mathematical nightmare.
">

Well, I was thinking more '..' in an array/list context, but yeah.

-Clint
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-09T18:09:00 </POSTDATE>
On Fri, 09 Nov 2007 21:17:54 +0100 Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

MD&gt; &quot;Subscript context&quot;? No, kinda too much for me... Even worse,
MD&gt; subscripting strongly reminds me of mathematical usage. A range of
MD&gt; 3..-1 returning 3..$#array reminds me of a mathematical nightmare.

Well, actually I would argue vehemently that the above should return 3,
2, 1, 0, -1 in regular context.  I think Perl, normally a clever
language, is not clever on this.  Ask any child what 3..-1 should
generate as a sequence, and they won't say &quot;empty list.&quot;

If 3..-1 returned a downward range, it would be trivial to look at the
array slice offsets, check if the last number is negative, and do the
right thing for that case.  But instead, we get the empty list because
.. only counts *up* and that causes the subsequent problems.  But I
realize changing .. is a completely impossible thing, and at least half
the Perl coders will disagree with me, so I'm only suggesting a
subscript context DWIMmery.  That's slightly less anathema I think.

Ted
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-09T18:13:00 </POSTDATE>
On Fri, 9 Nov 2007 18:29:39 +0000 (UTC) Ilya Zakharevich &lt;nospam-ab ... @ilyaz.org&gt; wrote:

IZ&gt; [A complimentary Cc of this posting was sent to
IZ&gt; Ted Zlatanov
IZ&gt; &lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m2640bqv22. ... @lifelogs.com&gt;:
IZ&gt; Me too.  3..-1 INAMBIGUOUSLY returns an empty list.

<QUOTE PREVIOUSPOST="
&gt;&gt; Well obviously in a general context, but Perl semantics for array
&gt;&gt; offsets also specifically know about negative numbers, so this is a
&gt;&gt; conflict between two DWIM modes (and I think the array offset DWIM mode
&gt;&gt; should win).
">

IZ&gt; As far as I know, there is no DWIM involved.  There are two operators,
IZ&gt; both fully-and-simply defined; array offset (which is defined for
IZ&gt; -$#-1..$#), and range.  You REALLY want the result of an operator be
IZ&gt; dependent on argument of which operator it is?

Yes, I think I do.  I could be wrong in wanting it, but it feels right.
It's like a chocolate donut, only much more abstract :)

IZ&gt; IMO, Perl evolution should go in DECREASING number of DWIM stuff (at
IZ&gt; least, as a pragma), not increasing it.  (Currently, the probability
IZ&gt; of an experienced Perl programmer to predict a result of running
IZ&gt; *simple* Perl code is close to 0 - unless one severely binds oneself
IZ&gt; via coding style discipline.  Too many un-/half-documented special
IZ&gt; cases...)

I agree.  And yet, I'm tempted by chocolate.

<QUOTE PREVIOUSPOST="
&gt;&gt; I actually did this just the other day (using $#array as
&gt;&gt; the last offset) and thought &quot;hmm, wouldn't it be nice to use -1&quot; so
&gt;&gt; Clint's question makes sense.
">

IZ&gt; I do it myself often too.  It does not make it a lesser evil.

No, but it does tell you something about how people think.  Intuition
often contradicts logic and consistency.

Ted
</POST>
<POST>
<POSTER> Ilya Zakharevich &lt;nospam-ab...@ilyaz.org&gt; </POSTER>
<POSTDATE> 2007-11-09T21:34:00 </POSTDATE>
[A complimentary Cc of this posting was NOT [per weedlist] sent to
Michele Dondi
&lt;bik.m ... @tiscalinet.it&gt;], who wrote in article &lt;lee9j3lrk66k48omq39f9hainn2ndc8 ... @4ax.com&gt;:

<QUOTE PREVIOUSPOST="
&gt; As Perl is now is mostly satisfactory
">

Could not agree less.  Perl IS nighmarish NOW.

<QUOTE PREVIOUSPOST="
&gt; The big challenge of Perl 6 is to achieve a high degree of dwimmery
&gt; while staying at the same time consistent and orthogonal. It aims, in
&gt; other words, at bringing dwimmery into the basic &quot;vector space
&gt; structure&quot;. Well, sort of.
">

What I saw of Perl6 is much much worse than even Perl5.

Hope this helps,
Ilya
</POST>
<POST>
<POSTER> Ilya Zakharevich &lt;nospam-ab...@ilyaz.org&gt; </POSTER>
<POSTDATE> 2007-11-09T21:42:00 </POSTDATE>
[A complimentary Cc of this posting was sent to
Ted Zlatanov
&lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m2wssrnhbv. ... @lifelogs.com&gt;:

<QUOTE PREVIOUSPOST="
&gt; IZ&gt; As far as I know, there is no DWIM involved.  There are two operators,
&gt; IZ&gt; both fully-and-simply defined; array offset (which is defined for
&gt; IZ&gt; -$#-1..$#), and range.  You REALLY want the result of an operator be
&gt; IZ&gt; dependent on argument of which operator it is?
&gt; Yes, I think I do.  I could be wrong in wanting it, but it feels right.
">

When I raised this issue on p5-p about a decade ago, (IIRC) at
first I was arguing on your side.  Now, after thinking about it for
quite some time, my position is the opposite.

Make your own conclusions from this...

<QUOTE PREVIOUSPOST="
&gt; It's like a chocolate donut, only much more abstract :)
&gt; IZ&gt; IMO, Perl evolution should go in DECREASING number of DWIM stuff (at
&gt; IZ&gt; least, as a pragma), not increasing it.  (Currently, the probability
&gt; IZ&gt; of an experienced Perl programmer to predict a result of running
&gt; IZ&gt; *simple* Perl code is close to 0 - unless one severely binds oneself
&gt; IZ&gt; via coding style discipline.  Too many un-/half-documented special
&gt; IZ&gt; cases...)

&gt; I agree.  And yet, I'm tempted by chocolate.
">

This is what pragmas are about.  IIRC, in the end of 90's, I was
advocating something like

use kiss;

which would prohibit all hard-to-document and all non-orthogonal
constructs (intended for large projects and teamworks).  Nobody was
interested enough, and, IIRC, my pilot implementations were not
accepted.

<QUOTE PREVIOUSPOST="
&gt; IZ&gt; I do it myself often too.  It does not make it a lesser evil.
&gt; No, but it does tell you something about how people think.  Intuition
&gt; often contradicts logic and consistency.
">

This is not the reason to follow intuition.  Intuition has its place;
one-liners have their place.  Not everything should be written in a
style appropriate for 1-liners.

Hope this helps,
Ilya
</POST>
<POST>
<POSTER> Ilya Zakharevich &lt;nospam-ab...@ilyaz.org&gt; </POSTER>
<POSTDATE> 2007-11-09T21:48:00 </POSTDATE>
[A complimentary Cc of this posting was sent to
Ted Zlatanov
&lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m21wazow25. ... @lifelogs.com&gt;:

<QUOTE PREVIOUSPOST="
&gt; On Fri, 09 Nov 2007 21:17:54 +0100 Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:
&gt; Well, actually I would argue vehemently that the above should return 3,
&gt; 2, 1, 0, -1 in regular context.
">

And you would be wrong in this...

<QUOTE PREVIOUSPOST="
&gt; I think Perl, normally a clever language, is not clever on this.
&gt; Ask any child what 3..-1 should generate as a sequence, and they
&gt; won't say &quot;empty list.&quot;
">

IMO, child's opinion should not have very high priority in design of
programming languages.  Remember how late the concept of 0 made it
into the common culture?

Hint: your proposal breaks the fundamental proportion:

5..7    ==&gt; 5 6 7
5..6    ==&gt; 5 6
5..5    ==&gt; 5
5..4    ==&gt; ???

<QUOTE PREVIOUSPOST="
&gt; If 3..-1 returned a downward range, it would be trivial to look at the
&gt; array slice offsets, check if the last number is negative, and do the
&gt; right thing for that case.
">

I see, you want YET ANOTHER &quot;right thing&quot;.  How nice of you...  And
what  @a[5,2] should return, in your opinion?

Hope this helps,
Ilya
</POST>
<POST>
<POSTER> Martijn Lievaart &lt;m...@rtij.nl.invlalid&gt; </POSTER>
<POSTDATE> 2007-11-10T04:19:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sat, 10 Nov 2007 02:48:40 +0000, Ilya Zakharevich wrote:
&gt; [A complimentary Cc of this posting was sent to Ted Zlatanov
&gt; &lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m21wazow25. ... @lifelogs.com&gt;:
&gt;&gt; On Fri, 09 Nov 2007 21:17:54 +0100 Michele Dondi
&gt;&gt; &lt;bik.m ... @tiscalinet.it&gt; wrote:

&gt;&gt; Well, actually I would argue vehemently that the above should return 3,
&gt;&gt; 2, 1, 0, -1 in regular context.

&gt; And you would be wrong in this...

&gt;&gt; I think Perl, normally a clever language, is not clever on this. Ask
&gt;&gt; any child what 3..-1 should generate as a sequence, and they won't say
&gt;&gt; &quot;empty list.&quot;

&gt; IMO, child's opinion should not have very high priority in design of
&gt; programming languages.  Remember how late the concept of 0 made it into
&gt; the common culture?

&gt; Hint: your proposal breaks the fundamental proportion:

&gt;    5..7       ==&gt; 5 6 7
&gt;    5..6       ==&gt; 5 6
&gt;    5..5       ==&gt; 5
&gt;    5..4       ==&gt; ???
">

Yes, but how about

for (3 .. 1) {
...
}

It would be very useful to have that count back, and it would be very
intuitive imo.

M4
</POST>
<POST>
<POSTER> &quot;Dr.Ruud&quot; &lt;rvtol+n...@isolution.nl&gt; </POSTER>
<POSTDATE> 2007-11-10T04:24:00 </POSTDATE>
Ted Zlatanov schreef:

<QUOTE PREVIOUSPOST="
&gt; I don't see why it's not possible, *within the context of an array
&gt; slice*, to override the .. and ... operators to replace negative
&gt; numbers with the corresponding array offsets.
">

Another DWIM-candidate:

being able to write

return \%data{@keys}

in stead of (the copying)

my %tmp;
@tmp{@keys} = @data{@keys};
return \%tmp;
#   ;)

(on p5p, Josh Jore came up with:

return sub { \@_ }-&gt;( @data{@keys} );
)

--
Affijn, Ruud

&quot;Gewoon is een tijger.&quot;
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T05:56:00 </POSTDATE>
On Fri, 09 Nov 2007 17:02:12 -0600, Clint Olsen

<QUOTE PREVIOUSPOST="
&lt;clint.ol ... @gmail.com&gt; wrote:
&gt;&gt; subscripting strongly reminds me of mathematical usage. A range of 3..-1
&gt;&gt; returning 3..$#array reminds me of a mathematical nightmare.

&gt;Well, I was thinking more '..' in an array/list context, but yeah.
">

Well, that would be... quite about anywhere, since C&lt;..&gt; in scalar
context is an entirely different beast. And since you mention *list*
context (there is not *really* anything like &quot;array&quot; context in Perl)
what meaning should e.g.

print 3..-2;

print from your pov?

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T05:59:00 </POSTDATE>
On Fri, 09 Nov 2007 17:09:38 -0600, Ted Zlatanov &lt;t ... @lifelogs.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;Well, actually I would argue vehemently that the above should return 3,
&gt;2, 1, 0, -1 in regular context.  I think Perl, normally a clever
&gt;language, is not clever on this.  Ask any child what 3..-1 should
&gt;generate as a sequence, and they won't say &quot;empty list.&quot;
">

Well, I may be a strange animal but it is very unintuitive to me.
3..-1 very directly reads in my mind like &quot;the sequence of integers n
such that 3&lt;=n&lt;=-1&quot;, which happens to be empty, period.

Perhaps, at least in this little thing I'm not a child anymore!  ;)

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T06:08:00 </POSTDATE>
On Sat, 10 Nov 2007 10:19:19 +0100, Martijn Lievaart

<QUOTE PREVIOUSPOST="
&lt;m ... @rtij.nl.invlalid&gt; wrote:
&gt;Yes, but how about

&gt;  for (3 .. 1) {
&gt;     ...
&gt;  }

&gt;It would be very useful to have that count back, and it would be very
&gt;intuitive imo.
">

No, it wouldn't, reverse() is what one wants. Admittedly, it is
slightly long to write down. Perhaps one issue is that &quot;..&quot; is
symmetric but represents a &quot;directed&quot; thingie. Of course the arrow is
already taken for something else but some kind of arrow would be
better suited for this semantics, better conveying the significance of
&quot;upto&quot; and &quot;downto&quot;. Thus

(imagine some actually suitable symbol in between.)

3 ^ 1;  # empty
1 ^ 3;  # 1,2,3
3 v 1;  # 3,2,1
1 v 3;  # empty

and if one really really wanted, then perhaps

$n x $m;  # $n &lt; $m ? $n ^ $m : $n v $m

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T06:13:00 </POSTDATE>
On Sat, 10 Nov 2007 02:34:15 +0000 (UTC), Ilya Zakharevich

<QUOTE PREVIOUSPOST="
&lt;nospam-ab ... @ilyaz.org&gt; wrote:
&gt;&gt; The big challenge of Perl 6 is to achieve a high degree of dwimmery
&gt;&gt; while staying at the same time consistent and orthogonal. It aims, in
&gt;&gt; other words, at bringing dwimmery into the basic &quot;vector space
&gt;&gt; structure&quot;. Well, sort of.

&gt;What I saw of Perl6 is much much worse than even Perl5.
">

It may be, but in other respects: certainly ad hoc deviations from
orthogonality have been reduced by several orders of magnitude. It is
by all means more consistent and regular. Whether it is better or
worse, more beautiful or uglier, spicy or sweet and so on, are
entirely different matters.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T06:14:00 </POSTDATE>
On Sat, 10 Nov 2007 02:42:35 +0000 (UTC), Ilya Zakharevich

<QUOTE PREVIOUSPOST="
&lt;nospam-ab ... @ilyaz.org&gt; wrote:
&gt;When I raised this issue on p5-p about a decade ago, (IIRC) at
&gt;first I was arguing on your side.  Now, after thinking about it for
&gt;quite some time, my position is the opposite.
">

Smart persons are able to change their mind, in fact.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T06:17:00 </POSTDATE>
On Sat, 10 Nov 2007 10:24:23 +0100, &quot;Dr.Ruud&quot;

<QUOTE PREVIOUSPOST="
&lt;rvtol+n ... @isolution.nl&gt; wrote:
&gt;Another DWIM-candidate:

&gt;being able to write

&gt;    return \%data{@keys}
">

Well, without even mentioning the referencing thing, first one useful
dwimmery would be the ability to slice a hash like that.

my %sliced=%data{@keys};

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Abigail &lt;abig...@abigail.be&gt; </POSTER>
<POSTDATE> 2007-11-10T07:34:00 </POSTDATE>
_
Martijn Lievaart (m ... @rtij.nl.invlalid) wrote on VCLXXXIV September
MCMXCIII in &lt;URL: :&quot;&gt;news:pan.2007.11.10.09.17.10@rtij.nl.invlalid&gt;:
\\  On Sat, 10 Nov 2007 02:48:40 +0000, Ilya Zakharevich wrote:
\\
\\ &gt; [A complimentary Cc of this posting was sent to Ted Zlatanov
\\ &gt; &lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m21wazow25. ... @lifelogs.com&gt;:
\\ &gt;&gt; On Fri, 09 Nov 2007 21:17:54 +0100 Michele Dondi

<QUOTE PREVIOUSPOST="
\\ &gt;&gt; &lt;bik.m ... @tiscalinet.it&gt; wrote:
">

\\ &gt;
\\ &gt;&gt; Well, actually I would argue vehemently that the above should return 3,
\\ &gt;&gt; 2, 1, 0, -1 in regular context.
\\ &gt;
\\ &gt; And you would be wrong in this...
\\ &gt;
\\ &gt;&gt; I think Perl, normally a clever language, is not clever on this. Ask
\\ &gt;&gt; any child what 3..-1 should generate as a sequence, and they won't say
\\ &gt;&gt; &quot;empty list.&quot;
\\ &gt;
\\ &gt; IMO, child's opinion should not have very high priority in design of
\\ &gt; programming languages.  Remember how late the concept of 0 made it into
\\ &gt; the common culture?
\\ &gt;
\\ &gt; Hint: your proposal breaks the fundamental proportion:
\\ &gt;
\\ &gt;    5..7    ==&gt; 5 6 7
\\ &gt;    5..6    ==&gt; 5 6
\\ &gt;    5..5    ==&gt; 5
\\ &gt;    5..4    ==&gt; ???
\\ &gt;
\\
\\  Yes, but how about
\\
\\    for (3 .. 1) {
\\       ...
\\    }
\\
\\  It would be very useful to have that count back, and it would be very
\\  intuitive imo.

Yeah, it would be sometimes be useful to have it count back. Often
though, it's also very useful to have 3 .. 1 return an empty list.

I don't know which one is more useful. But that doesn't matter; it's
too late to change. Even if there's more benefit that 3 .. 1 'counts
backwards' than 3 .. 1 being an empty list, the disadvantage of
changing the meaning (and hence having lots of potential code that
breaks; it's not that .. is an uncommon operation) far outweights
any possible benefit.

Besides, we already have 'reverse' to count backwards. And it's pretty
simple to write a sub that returns an ascending or descending range depending
on the order of the arguments (untested):

sub range ($$) {
return         $_ [0] .. $_ [1] if $_ [0] &lt;= $_ [1];
return reverse $_ [1] .. $_ [0];
}

for (range 3, 1) {
...
}

Note however that having .. count backwards if the second argument
is smaller than the first, does NOT solve the slice issue.

@array = qw [one two three four five six];
@array [3 .. $#array];  # 'four', 'five', 'six'; indented value
# of @array [3 .. -1].
@array [3 .. -1]        # 'four', 'three', 'two', 'one', 'six';
# value if .. counts backwards.

Abigail
--
perl -le 's[$,][join$,,(split$,,($!=85))[(q[0006143730380126152532042307].
q[41342211132019313505])=~m[..]g]]e and y[yIbp][HJkP] and print'
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-10T10:05:00 </POSTDATE>
On Sat, 10 Nov 2007 02:48:40 +0000 (UTC) Ilya Zakharevich &lt;nospam-ab ... @ilyaz.org&gt; wrote:

IZ&gt; [A complimentary Cc of this posting was sent to
IZ&gt; Ted Zlatanov
IZ&gt; &lt;t ... @lifelogs.com&gt;], who wrote in article &lt;m21wazow25. ... @lifelogs.com&gt;:

<QUOTE PREVIOUSPOST="
&gt;&gt; I think Perl, normally a clever language, is not clever on this.
&gt;&gt; Ask any child what 3..-1 should generate as a sequence, and they
&gt;&gt; won't say &quot;empty list.&quot;
">

IZ&gt; IMO, child's opinion should not have very high priority in design of
IZ&gt; programming languages.

OK, ask anyone at all what &quot;3 .. -1&quot; should be, mathematician or not,
that's not a Perl programmer.  The design of Perl 5 chose consistency
(.. always counts up and generates an empty list if it can't) over DWIM
(count from x to y, either up or down) here.

I don't think the DWIM mode is wrong, as evidenced by the percentage of
people that would tell you it's what they expect (informal poll on 5
people by me: 100%).  It would break code, though, so I don't propose
that it be the default.

IZ&gt; Hint: your proposal breaks the fundamental proportion:

IZ&gt;    5..7     ==&gt; 5 6 7
IZ&gt;    5..6     ==&gt; 5 6
IZ&gt;    5..5     ==&gt; 5
IZ&gt;    5..4     ==&gt; ???

You see .. as a forward vector on the integer number line.  I think the
vector could point down as well:

5..4 ==&gt; 5 4
5..1 ==&gt; 5 4 3 2 1
1..-1 ==&gt; 1 0 -1

Again, this is not my overactive imagination, it's what people expect.

<QUOTE PREVIOUSPOST="
&gt;&gt; If 3..-1 returned a downward range, it would be trivial to look at the
&gt;&gt; array slice offsets, check if the last number is negative, and do the
&gt;&gt; right thing for that case.
">

IZ&gt; I see, you want YET ANOTHER &quot;right thing&quot;.  How nice of you...  And
IZ&gt; what  @a[5,2] should return, in your opinion?

That's irrelevant.  My point is:

1) in @array[x..y] make the .. operator count down IFF y is negative
(&quot;subscript context&quot;).  As an alternative, make it count down everywhere
with a pragma, or make it count down in subscript context with a pragma.

2) any negative subscripts refer to the last-minus-y offset (which is
already the case).

So the change is only to .. and entirely optional.  Another operator,
some Unicode character, could be used instead of .. if you think it's a
better choice.

Ted
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-10T10:09:00 </POSTDATE>
On Sat, 10 Nov 2007 12:08:43 +0100 Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

MD&gt; On Sat, 10 Nov 2007 10:19:19 +0100, Martijn Lievaart

<QUOTE PREVIOUSPOST="
MD&gt; &lt;m ... @rtij.nl.invlalid&gt; wrote:
&gt;&gt; for (3 .. 1)
&gt;&gt; It would be very useful to have that count back, and it would be very
&gt;&gt; intuitive imo.
">

MD&gt; No, it wouldn't, reverse() is what one wants.

No, it's what Perl 5 wants and the programmer has to satisfy it.  People
want the intuitive range, up or down.

Ted
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-10T10:16:00 </POSTDATE>
On 10 Nov 2007 12:34:59 GMT Abigail &lt;abig ... @abigail.be&gt; wrote:

A&gt; I don't know which one is more useful. But that doesn't matter; it's
A&gt; too late to change. Even if there's more benefit that 3 .. 1 'counts
A&gt; backwards' than 3 .. 1 being an empty list, the disadvantage of
A&gt; changing the meaning (and hence having lots of potential code that
A&gt; breaks; it's not that .. is an uncommon operation) far outweights
A&gt; any possible benefit.

That's why my proposal was with a pragma and only in subscript context
(although in global context it would work too).

A&gt; Note however that having .. count backwards if the second argument
A&gt; is smaller than the first, does NOT solve the slice issue.

A&gt;     @array = qw [one two three four five six];
A&gt;     @array [3 .. $#array];  # 'four', 'five', 'six'; indented value
A&gt;                             # of @array [3 .. -1].
A&gt;     @array [3 .. -1]        # 'four', 'three', 'two', 'one', 'six';
A&gt;                             # value if .. counts backwards.

Ah, you're right, I wasn't thinking.  So counting down is not the answer
(though it makes intuitive sense).  .. in subscript context would have
to replace -x with the corresponding offset.  The resulting mess is not
DWIM, so consider my arguments crap :)

Ted
</POST>
<POST>
<POSTER> Ted Zlatanov &lt;t...@lifelogs.com&gt; </POSTER>
<POSTDATE> 2007-11-10T10:17:00 </POSTDATE>
On Sat, 10 Nov 2007 12:17:37 +0100 Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

MD&gt; On Sat, 10 Nov 2007 10:24:23 +0100, &quot;Dr.Ruud&quot;

<QUOTE PREVIOUSPOST="
MD&gt; &lt;rvtol+n ... @isolution.nl&gt; wrote:
&gt;&gt; Another DWIM-candidate:

&gt;&gt; being able to write

&gt;&gt; return \%data{@keys}
">

MD&gt; Well, without even mentioning the referencing thing, first one useful
MD&gt; dwimmery would be the ability to slice a hash like that.

MD&gt;   my %sliced=%data{@keys};

A &quot;slice&quot; operator?  Maybe look for a Unicode &quot;knife&quot; symbol? :)

Ted
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T11:15:00 </POSTDATE>
On Sat, 10 Nov 2007 09:09:19 -0600, Ted Zlatanov &lt;t ... @lifelogs.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;On Sat, 10 Nov 2007 12:08:43 +0100 Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:

&gt;MD&gt; On Sat, 10 Nov 2007 10:19:19 +0100, Martijn Lievaart
&gt;MD&gt; &lt;m ... @rtij.nl.invlalid&gt; wrote:

&gt;&gt;&gt; for (3 .. 1)
&gt;&gt;&gt; It would be very useful to have that count back, and it would be very
&gt;&gt;&gt; intuitive imo.

&gt;MD&gt; No, it wouldn't, reverse() is what one wants.

&gt;No, it's what Perl 5 wants and the programmer has to satisfy it.  People
&gt;want the intuitive range, up or down.
">

No people who find the range intuitive that way want it that way. To
me and someone else it is counter-intuitive. I'm not a mathematician
nor do I have extraordinary mathematical skills, but mathematics is
*very* intuitive to me. That other use is confusing and inconsistent.
Perhaps because I have some more experience than you with
combinatorics where e.g. a sum from n to m where n&gt;m is naturally
null. If it were to have &quot;your&quot; meaning, it would make calculations
terribly clumsy. Your &quot;intuitive&quot; idea is more that of a *segment*
than a range, but I don't see it as extremely useful unless there
where three different operators (or one operator with suitable
adverbs, but we don't have adverbs in Perl 5 yet) with the semanticts
of respectively &quot;upto&quot;, &quot;downto&quot;, &quot;between&quot;.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T11:16:00 </POSTDATE>
On Sat, 10 Nov 2007 09:16:28 -0600, Ted Zlatanov &lt;t ... @lifelogs.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;Ah, you're right, I wasn't thinking.  So counting down is not the answer
&gt;(though it makes intuitive sense).  .. in subscript context would have
&gt;to replace -x with the corresponding offset.  The resulting mess is not
&gt;DWIM, so consider my arguments crap :)
">

say &quot;Whoa, at least!&quot;;  # just kidding ;)

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T11:22:00 </POSTDATE>
On Sat, 10 Nov 2007 09:17:37 -0600, Ted Zlatanov &lt;t ... @lifelogs.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt;MD&gt;   my %sliced=%data{@keys};

&gt;A &quot;slice&quot; operator?  Maybe look for a Unicode &quot;knife&quot; symbol? :)
">

We're not ready yet for unicode operators. We have to wait for 6. And
call me old-fashioned, but I think I would often use the ascii
equivalent operators most of the times with it too. OTOH I don't see
that we need a special operator at all since the above syntax seems
fine, except that currently generates an error. Of course some p5p'er
may explain that in fact it's *not* fine, e.g. not compatible with...
well anything else.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> &quot;A. Sinan Unur&quot; &lt;1...@llenroc.ude.invalid&gt; </POSTER>
<POSTDATE> 2007-11-10T12:04:00 </POSTDATE>
Martijn Lievaart &lt;m ... @rtij.nl.invlalid&gt; wrote in
news:pan.2007.11.10.09.17.10@rtij.nl.invlalid:

<QUOTE PREVIOUSPOST="
&gt; On Sat, 10 Nov 2007 02:48:40 +0000, Ilya Zakharevich wrote:
">

...

<QUOTE PREVIOUSPOST="
&gt;&gt; Hint: your proposal breaks the fundamental proportion:

&gt;&gt;    5..7        ==&gt; 5 6 7
&gt;&gt;    5..6        ==&gt; 5 6
&gt;&gt;    5..5        ==&gt; 5
&gt;&gt;    5..4        ==&gt; ???

&gt; Yes, but how about

&gt;   for (3 .. 1) {
&gt;      ...
&gt;   }

&gt; It would be very useful to have that count back, and it would be very
&gt; intuitive imo.
">

Really? That would break a lot of my code: Right now, I know that if
$first &gt; $last, the body of the loop:

for my $i ( $first .. $last ) {

will not run so I use that fact.

Sinan

--
A. Sinan Unur &lt;1 ... @llenroc.ude.invalid&gt;
(remove .invalid and reverse each component for email address)
clpmisc guidelines: &lt;URL: http://www.augustmail.com/~tadmc/clpmisc.shtml &gt;
</POST>
<POST>
<POSTER> &quot;Jürgen Exner&quot; &lt;jurge...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-11-10T12:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Martijn Lievaart wrote:
&gt; Yes, but how about
&gt;  for (3 .. 1) {...}
&gt; It would be very useful to have that count back, and it would be very
&gt; intuitive imo.
">

Absolutely not. I at least don't want to have to check explicitely every
single time
if ($start &lt;= $end) {
for ($start .. $end) {...}
} # else do nothing
That would be so nuts

If you want to count down then just use
for (reverse (1..3)) {...}

jue
</POST>
<POST>
<POSTER> xhos...@gmail.com </POSTER>
<POSTDATE> 2007-11-10T12:39:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:
&gt; On Sat, 10 Nov 2007 10:19:19 +0100, Martijn Lievaart
&gt; &lt;m ... @rtij.nl.invlalid&gt; wrote:

&gt; &gt;Yes, but how about

&gt; &gt;  for (3 .. 1) {
&gt; &gt;     ...
&gt; &gt;  }

&gt; &gt;It would be very useful to have that count back, and it would be very
&gt; &gt;intuitive imo.

&gt; No, it wouldn't, reverse() is what one wants. Admittedly, it is
&gt; slightly long to write down.
">

It also materializes its list (currently).  So
foreach (reverse 1..1e7) {
might not be such a good idea.

Xho

--
-------------------- http://NewsReader.Com/ --------------------
The costs of publication of this article were defrayed in part by the
payment of page charges. This article must therefore be hereby marked
advertisement in accordance with 18 U.S.C. Section 1734 solely to indicate
this fact.
</POST>
<POST>
<POSTER> Michele Dondi &lt;bik.m...@tiscalinet.it&gt; </POSTER>
<POSTDATE> 2007-11-10T13:16:00 </POSTDATE>
On 10 Nov 2007 17:39:31 GMT, xhos ... @gmail.com wrote:

<QUOTE PREVIOUSPOST="
&gt;&gt; No, it wouldn't, reverse() is what one wants. Admittedly, it is
&gt;&gt; slightly long to write down.

&gt;It also materializes its list (currently).  So
&gt;foreach (reverse 1..1e7) {
&gt;might not be such a good idea.
">

That's right. Of course we all want lazy list evaluation by default.

Michele
--
{$_=pack'B8'x25,unpack'A8'x32,$a^=sub{pop^pop}-&gt;(map substr
(($a||=join'',map--$|x$_,(unpack'w',unpack'u','G^&lt;R&lt;Y]*YB='
.'KYU;*EVH[.FHF2W+#&quot;\Z*5TI/ER&lt;Z`S(G.DZZ9OX0Z')=~/./g)x2,$_,
256),7,249);s/[^\w,]/ /g;$ \=/^J/?$/:&quot;\r&quot;;print,redo}#JAPH,
</POST>
<POST>
<POSTER> Martijn Lievaart &lt;m...@rtij.nl.invlalid&gt; </POSTER>
<POSTDATE> 2007-11-10T15:42:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sat, 10 Nov 2007 17:04:02 +0000, A. Sinan Unur wrote:
&gt; Martijn Lievaart &lt;m ... @rtij.nl.invlalid&gt; wrote in
&gt; news:pan.2007.11.10.09.17.10@rtij.nl.invlalid:

&gt;&gt; On Sat, 10 Nov 2007 02:48:40 +0000, Ilya Zakharevich wrote:
&gt; ...

&gt;&gt;&gt; Hint: your proposal breaks the fundamental proportion:

&gt;&gt;&gt;    5..7        ==&gt; 5 6 7
&gt;&gt;&gt;    5..6        ==&gt; 5 6
&gt;&gt;&gt;    5..5        ==&gt; 5
&gt;&gt;&gt;    5..4        ==&gt; ???

&gt;&gt; Yes, but how about

&gt;&gt;   for (3 .. 1) {
&gt;&gt;      ...
&gt;&gt;   }

&gt;&gt; It would be very useful to have that count back, and it would be very
&gt;&gt; intuitive imo.

&gt; Really? That would break a lot of my code: Right now, I know that if
&gt; $first &gt; $last, the body of the loop:

&gt; for my $i ( $first .. $last ) {

&gt; will not run so I use that fact.
">

I'm aware of that and I'm not proposing to change this, or anything other.

I was just commenting on what is intuitive for me and what would have
been useful imo. As changing this idiom breaks a lot of code, we cannot
change this.

Besides, your example is a good counterexample where I would expect the
loop not to run if $last&lt;$first. As someone else wrote, to disambiguate
you would need three different operators, upto, downto and between. Well
downto can be done with reverse and upto, but as already shown, that
breaks lazy evaluation. Although it needn't with a sufficiently smart
reverse.

And there is also the fact that this has nothing to do with the original
problem of using negative integers to denote elements from the end.

All this is just academic, perl is perl and we can't change this. It's
just fun to think about it, sharpens the mind and sometimes something
very useful can come from these discussions.

M4
</POST>
<POST>
<POSTER> Abigail &lt;abig...@abigail.be&gt; </POSTER>
<POSTDATE> 2007-11-10T16:44:00 </POSTDATE>
_
xhos ... @gmail.com (xhos ... @gmail.com) wrote on VCLXXXIV September
MCMXCIII in &lt;URL: :&quot;&gt;news:20071110123933.409$K2@newsreader.com&gt;:
@@  Michele Dondi &lt;bik.m ... @tiscalinet.it&gt; wrote:
@@ &gt; On Sat, 10 Nov 2007 10:19:19 +0100, Martijn Lievaart

<QUOTE PREVIOUSPOST="
@@ &gt; &lt;m ... @rtij.nl.invlalid&gt; wrote:
">

@@ &gt;
@@ &gt; &gt;Yes, but how about
@@ &gt; &gt;
@@ &gt; &gt;  for (3 .. 1) {
@@ &gt; &gt;     ...
@@ &gt; &gt;  }
@@ &gt; &gt;
@@ &gt; &gt;It would be very useful to have that count back, and it would be very
@@ &gt; &gt;intuitive imo.
@@ &gt;
@@ &gt; No, it wouldn't, reverse() is what one wants. Admittedly, it is
@@ &gt; slightly long to write down.
@@
@@  It also materializes its list (currently).  So
@@  foreach (reverse 1..1e7) {
@@  might not be such a good idea.

Nope. Which is why we have C-style loops:

for (my $i = 1e7; $i; $i --) { ... }

Abigail
--
perl -wle 'print &quot;Prime&quot; if (1 x shift) !~ /^1?$|^(11+?)\1+$/'
</POST>
</TEXT>
</BODY>
</DOC>
