<DOC>
<DOCID> eng-NG-31-135602-8600374 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-08-13T00:38:00 </DATETIME>
<BODY>
<HEADLINE>
gforth webserver, why isn't forth used all over ecommerce?
</HEADLINE>
<TEXT>
<POST>
<POSTER> gavino &lt;gavcom...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-13T00:38:00 </POSTDATE>
http://www.jwdt.com/~paysan/httpd-en.html

seems awesome, made in a few hours

I mean if forth is this powerful, why isn't it used all over the
place?
I read bit about colorforth being easy to enable DRIVERs for disk
drives? so it handles low level and high level?
This seems as interesting as haskell or common lisp!!!
forth on bare metal also seems liek dream come true?
Where are links on how to enable that?
</POST>
<POST>
<POSTER> jcomeau_ictx &lt;john.com...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-13T00:54:00 </POSTDATE>
On Aug 12, 10:38 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; http://www.jwdt.com/~paysan/httpd-en.html

&gt; seems awesome, made in a few hours

&gt; I mean if forth is this powerful, why isn't it used all over the
&gt; place?
">

My opinion: because C, and even moreso, scripting languages like
Python and Perl make string handling easier than FORTH does.

<QUOTE PREVIOUSPOST="
&gt; I read bit about colorforth being easy to enable DRIVERs for disk
&gt; drives? so it handles low level and high level?
&gt; This seems as interesting as haskell or common lisp!!!
&gt; forth on bare metal also seems liek dream come true?
&gt; Where are links on how to enable that?
">

There's a bootable ISO of colorForth downloadable from
http://sourceforge.net/projects/colorforth . I've never tried the disk
driver though, not having a disk around I felt OK about possibly
trashing.
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-13T01:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
gavino wrote:
&gt; http://www.jwdt.com/~paysan/httpd-en.html

&gt; seems awesome, made in a few hours

&gt; I mean if forth is this powerful, why isn't it used all over the
&gt; place?
">

Compare the functionality of a web server like Apache or IIS to this one
and then tell me how &quot;powerful&quot; it is.  Like so many people here, you
completely gloss over the details and make apples-to-oranges comparisons.

You might also want to consider stop writing provocative messages in
comp.lang.forth and use that time to instead actually write some code.
Looking back, you've been asking various forms of essentially the same
question for about a year.  Think how if instead of endlessly asking
&quot;can Forth do this&quot; how much you would have learned if you actually sat
down and wrote code.
</POST>
<POST>
<POSTER> gavino &lt;gavcom...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-08-13T01:43:00 </POSTDATE>
On Aug 12, 10:10 pm, John Passaniti &lt;put-my-first-name-

<QUOTE PREVIOUSPOST="
h ... @JapanIsShinto.com&gt; wrote:
&gt; gavino wrote:
&gt; &gt; http://www.jwdt.com/~paysan/httpd-en.html

&gt; &gt; seems awesome, made in a few hours

&gt; &gt; I mean if forth is this powerful, why isn't it used all over the
&gt; &gt; place?

&gt; Compare the functionality of a web server like Apache or IIS to this one
&gt; and then tell me how &quot;powerful&quot; it is.  Like so many people here, you
&gt; completely gloss over the details and make apples-to-oranges comparisons.

&gt; You might also want to consider stop writing provocative messages in
&gt; comp.lang.forth and use that time to instead actually write some code.
&gt; Looking back, you've been asking various forms of essentially the same
&gt; question for about a year.  Think how if instead of endlessly asking
&gt; &quot;can Forth do this&quot; how much you would have learned if you actually sat
&gt; down and wrote code.
">

What is a good forth for a beginner like me?
I have access to an linux computer.
</POST>
<POST>
<POSTER> Bernd Paysan &lt;bernd.pay...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-08-13T06:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jcomeau_ictx wrote:
&gt; On Aug 12, 10:38 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:
&gt;&gt; http://www.jwdt.com/~paysan/httpd-en.html

&gt;&gt; seems awesome, made in a few hours

&gt;&gt; I mean if forth is this powerful, why isn't it used all over the
&gt;&gt; place?

&gt; My opinion: because C, and even moreso, scripting languages like
&gt; Python and Perl make string handling easier than FORTH does.
">

But this example proves otherwise. This is string handling all from top to
bottom, and it's remarkable easy to do in Forth. There's another example,
the wiki forth HTML page generator, which all is string handling from top
to bottom, as well - if you like, you can compare it with the PHP code for
wikis like Dokuwiki.

The reason Forth isn't used for tasks like this is because people think it's
not suitable, and they therefore never give it a try. Or they forget that
they first have to write the (small) string library before it works.

BTW: Apache can do more if you plug in the many modules for it. A plain
Apache without modules can't do anything more than my web server. And you
can write and plug in modules into my web server as well (one, the
proxy.fs, is given as example - this does something you can't do with any
module provided by Apache - redirect apparently &quot;internal&quot; pages to
external ones).

--
Bernd Paysan
&quot;If you want it done right, you have to do it yourself&quot;
http://www.jwdt.com/~paysan/
</POST>
<POST>
<POSTER> an...@mips.complang.tuwien.ac.at (Anton Ertl) </POSTER>
<POSTDATE> 2007-08-13T07:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan &lt;bernd.pay ... @gmx.de&gt; writes:
&gt;proxy.fs, is given as example - this does something you can't do with any
&gt;module provided by Apache - redirect apparently &quot;internal&quot; pages to
&gt;external ones).
">

What's wrong with mod_alias and the Redirect directive?

#
# Redirect allows you to tell clients about documents which used to exist in
# your server's namespace, but do not anymore. This allows you to tell the
# clients where to look for the relocated document.
# Example:
# Redirect permanent /foo http://www.example.com/bar

We use quite a few Redirects in our Apache-based web server.

- anton
--
M. Anton Ertl http://www.complang.tuwien.ac.at/anton/home.html
comp.lang.forth FAQs: http://www.complang.tuwien.ac.at/forth/faq/toc.html
New standard: http://www.forth200x.org/forth200x.html
EuroForth 2007: http://www.complang.tuwien.ac.at/anton/euroforth2007/
</POST>
<POST>
<POSTER> Jerry Avins &lt;j...@ieee.org&gt; </POSTER>
<POSTDATE> 2007-08-13T08:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
gavino wrote:
&gt; On Aug 12, 10:10 pm, John Passaniti &lt;put-my-first-name-
&gt; h ... @JapanIsShinto.com&gt; wrote:
&gt;&gt; gavino wrote:
&gt;&gt;&gt; http://www.jwdt.com/~paysan/httpd-en.html
&gt;&gt;&gt; seems awesome, made in a few hours
&gt;&gt;&gt; I mean if forth is this powerful, why isn't it used all over the
&gt;&gt;&gt; place?
&gt;&gt; Compare the functionality of a web server like Apache or IIS to this one
&gt;&gt; and then tell me how &quot;powerful&quot; it is.  Like so many people here, you
&gt;&gt; completely gloss over the details and make apples-to-oranges comparisons.

&gt;&gt; You might also want to consider stop writing provocative messages in
&gt;&gt; comp.lang.forth and use that time to instead actually write some code.
&gt;&gt; Looking back, you've been asking various forms of essentially the same
&gt;&gt; question for about a year.  Think how if instead of endlessly asking
&gt;&gt; &quot;can Forth do this&quot; how much you would have learned if you actually sat
&gt;&gt; down and wrote code.

&gt; What is a good forth for a beginner like me?
&gt; I have access to an linux computer.
">

Gforth?

Jerry
--
Engineering is the art of making what you want from things you can get.
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-13T10:26:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan wrote:
&gt; BTW: Apache can do more if you plug in the many modules for it. A plain
&gt; Apache without modules can't do anything more than my web server.
">

False.

First, Apache doesn't require inetd in order to handle communications,
so right there it has one capability your web server doesn't.  And
that's not just basic communications, but support for efficiently
handling large numbers of connections.

Second, Apache knows (without any modules) how to support basic features
such as name-based hosting (that is, interpretation of the Host:
parameter to disambiguate between multiple sites hosted on a single IP
address) as well as a number of other features implied by HTTP 1.1.

Third, Apache knows (without any modules) how to deal with real-world
bugs in browsers and other user agents.  A review of the source code
will illustrate the reality that just because a RFC says what the
standard is doesn't mean that real-world users are necessarily following
those standards.  Lamentable, but that's the real world for you.

It's trivial exercise to simply review the Apache documentation and find
lots of features present in the raw, unextended Apache that go far
beyond what your webserver in Forth provides.

But of course, nobody should be surprised by this.  Typical of the
apples to oranges comparisons common here in comp.lang.forth, people
love to gloss over the details.

Apache is a webserver.
Bernd's Forth code is a webserver.
Therefore, they are the same.

Sue is a doctor.
Bob is a doctor.
Therefore, Sue is Bob

Some may see this as a logical fallacy.  I see it as Monday morning in
comp.lang.forth.

&gt; And you

<QUOTE PREVIOUSPOST="
&gt; can write and plug in modules into my web server as well (one, the
&gt; proxy.fs, is given as example - this does something you can't do with any
&gt; module provided by Apache - redirect apparently &quot;internal&quot; pages to
&gt; external ones).
">

State the problem more clearly, and I'll bet I can find the
functionality you think doesn't exist.
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-13T10:29:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
gavino wrote:
&gt; What is a good forth for a beginner like me?
&gt; I have access to an linux computer.
">

First answer:  Gforth.

Second answer:  It doesn't matter.  Pick the first Forth you find in
your package manager and install that.  The core of the language is
going to be the same.  By the time you care about the differences,
you'll know what you need.
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-13T11:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan wrote:
&gt; The reason Forth isn't used for tasks like this is because people think it's
&gt; not suitable, and they therefore never give it a try. Or they forget that
&gt; they first have to write the (small) string library before it works.
">

False.

Except in narrow cases where it makes sense, people don't use Forth for
tasks like this because there is no value to using Forth over any other
language.  You want to write a trivial minimal webserver?  The same kind
of minimalistic approach you took in Forth can be replicated in
virtually any other language.  Except in most other languages, you won't
have to spend any time dealing with string handling primitives since
they are already there.

Most people who have never actually written a significant web
application (embedded or not) don't understand that the webserver itself
is perhaps the least interesting part of the system.

A significant web application is not a five-line CGI script.  It's more
typically (in the embedded case) an application that provides the user
interface for the system.  And that more likely than not is going to
require far more interesting services such as some kind of templating
language, some kind of application framework to keep complexity under
control, media management, and these days AJAX support (which implies
other services).

The problem that most people don't realize is that simple things are
easy, but when the problem scales up and you're writing a complete,
interactive, responsive, and rich user interface using web technologies,
then things start to get more complex.  They'll write their Fahrenheit
to Celsius converter, delight that it works, and then proudly declare
that anything more sophisticated is just a few more primitives away.
They don't have a clue.

People care more about the support needed for significant applications.
*THAT* is where people want to invest their time, not in the
plumbling.  But if the only systems you write do simple things, you
can't appreciate that.

What I strongly suggest anyone who thinks otherwise does is to spend
some time with a web application framework.  It doesn't matter which
one-- Ruby on Rails is nice.  You don't have to understand Ruby but what
you should pay close attention to are the various kinds of things the
framework provides.  For example, Ruby on Rails provides a variation of
the classic MVC paradigm.  Ask yourself why someone would want this.
Ask yourself what does it make easier?  And when you do that, you'll
gain an appreciation of why people don't care about trivia like the
webserver when there are so many more interesting problems to solve.
</POST>
<POST>
<POSTER> &quot;ch...@visc.us&quot; &lt;ch...@visc.us&gt; </POSTER>
<POSTDATE> 2007-08-14T00:12:00 </POSTDATE>
On Aug 12, 9:38 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; http://www.jwdt.com/~paysan/httpd-en.html

&gt; seems awesome, made in a few hours

&gt; I mean if forth is this powerful, why isn't it used all over the
&gt; place?
&gt; Where are links on how to enable that?
">

I've been working on &quot;web&quot; applications full time for nearly seven
years.
And I've been keeping an eye on Forth for nearly six.

Excuse my arrogance when I use cliches like &quot;the fact is&quot;...

The fact is, you can use near any language to program for the web.
The fact is, there are only two important interfaces that need to be
defined in your language.
First, you need regular expressions, they're near universal. Second,
you need an SQL server.
PostgreSQL is your best friend, MySQL is your &quot;other&quot; friend (feel
free to define that on your own).
Oracle, MSSQL, etc, they're political connections with which you
should know how to do business with.

If you have regular expressions and suppose for postgres, you can
create anything I've worked on, and gotten well paid for, over the
last seven years.
Most importantly, you can create any of the high-traffic websites seen
on the Alexa pop charts ( anything above a 3000 ranking ). In that
area, you can easily sustain your lifestyle and occasional
contracting.

Why isn't forth available as a &quot;scripting&quot; solution?

Over-achievement.  Paysan wrote a great example of an HTTP server in
forth. And it would work very well as part of any embedded device. On
a general CPU, using tcpserver, or another glue, leads to terrible
performance compared to Apache and/or lighttpd and/or fastcgi.

Non-participation. I tried, and failed, embarrassingly, to stir-up a
PostgreSQL interface to a Forth language. Call it PL/Forth.
The fact is, it's very easy to port a forth, be it into Parrot
( www.parrotcode.org ) or postgres ( www.postgresql.org ). But there's no
demand, nobody is writing applications using it. There's no community.
Forth-work is very much focused on hardware, on processors. The
internet is very much virtualized, a &quot;scripting&quot; language community.
While forth has a very natural relationship toward Python, perl, php,
ruby, and on... Forth programmers are very far from the field.

And?
Until you bootstrap SQL and regular expressions onto your interface
( it takes minutes to write a gforth program using fastcgi over apache
or lighttpd and others ), you're working in a constrained, kludgey
environment.  And after you've taken care of those two, you're
certainly free to write any web application you like. XML and
Ecmascript are requisites, of course. Submit the package to
freshmeat.net, and forth is a viable web-application.

Otherwise, why bother... It takes very little time/effort to port
forth to any given application. I suspect the Parrot forth
implementation was abandoned for this reason. Really, why bother, it
can be picked up, assembled and committed so easily.
</POST>
<POST>
<POSTER> Alex McDonald &lt;b...@rivadpm.com&gt; </POSTER>
<POSTDATE> 2007-08-14T03:10:00 </POSTDATE>
On Aug 13, 9:12 pm, &quot;ch ... @visc.us&quot; &lt;ch ... @visc.us&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt;   The fact is, it's very easy to port a forth, be it into Parrot
&gt; ( www.parrotcode.org ) or postgres ( www.postgresql.org ). But there's no
&gt; demand, nobody is writing applications using it. There's no community.
&gt; Forth-work is very much focused on hardware, on processors. The
&gt; internet is very much virtualized, a &quot;scripting&quot; language community.
&gt; While forth has a very natural relationship toward Python, perl, php,
&gt; ruby, and on... Forth programmers are very far from the field.
">

I looked at the Parrot VM some time back and discounted it for the
major reason that it's a register based VM, not a stack based VM. The
issues of translation from one to the other are significant, as any
compiler writer will tell you.

Secondly Parrot assumes (from what I could tell) the traditional model
of batch compilation, rather than Forth's method of interpretation and
compilation, and that makes it difficult to impossible to switch
freely between the two. Any Forth written for Parrot would be no
better than a C compiler in terms of its interactivity.

Lastly, Forth provides its own VM with an unlimited number of opcodes
(they're called words).

No point banging a square peg into a round hole.

--
Regards
ALex McDonald
</POST>
<POST>
<POSTER> Bernd Paysan &lt;bernd.pay...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-08-14T08:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
ch ... @visc.us wrote:
&gt;  Non-participation. I tried, and failed, embarrassingly, to stir-up a
&gt; PostgreSQL interface to a Forth language.
">

There's one in bigFORTH, which works, but needs both the C library interface
and the OOF extension (and it's just 250 lines of code). It might need
another 10 lines or so to make it injection-proof (which wasn't a priority,
but I've designed towards it - data and query instructions are separated on
the Forth side, as well).

There's also a regexp compiler in bigFORTH, which is 200 lines of code.

And despite everybody says &quot;you need regexps&quot;, I still didn't manage to come
up with a program that actually can make good use of my bigFORTH regexp
compiler. I know, the PHP version of a wiki formatter is using regexps, but
my Forth version works without. I thought I was convinced about regexps at
some point (that's why I finally wrote a regexp compiler), but I'm again
sceptical, having that compiler lying around for years now, and still
haven't found any good use for it.

BTW performance: It's a browser issue, as well. Modern browsers like
Konqueror or Firefox, which open one connection and keep it open, work
extremely well with Gforth's http, even on systems with low amount of
memory, where Apache just crawls. I used Gforth's http for years on my old
laptop with 32MB RAM, because starting Apache made that laptop completely
unusable. And the startup delay for Gforth is not more than the fork delay
of Apache (forking a large program takes more time than forking inetd and
exec() to Gforth).

There have been some other discussions about Forth socket interfaces, and
Marcel Hendrix has got quite far with that, so eventually, the HTTP server
will implement a direct socket connection in some 30 lines or so. I'm sure,
people will still claim that it's comparing apples with bananas.

--
Bernd Paysan
&quot;If you want it done right, you have to do it yourself&quot;
http://www.jwdt.com/~paysan/
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-14T12:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan wrote:
&gt; And despite everybody says &quot;you need regexps&quot;, I still didn't manage
&gt; to come up with a program that actually can make good use of my
&gt; bigFORTH regexp compiler. I know, the PHP version of a wiki formatter
&gt;  is using regexps, but my Forth version works without. I thought I
&gt; was convinced about regexps at some point (that's why I finally wrote
&gt;  a regexp compiler), but I'm again sceptical, having that compiler
&gt; lying around for years now, and still haven't found any good use for
&gt;  it.
">

Any programming languages' facilities only make sense in the context of
the problem domain you're using them in.  To say you don't need regular
expressions says *nothing* more than the specific kind of work you do
apparently doesn't need them or that you found alternatives to work for
you.  It says *nothing* about anyone else's needs.  It says *nothing*
about if the alternatives you've used are necessarily better or worse
than using regular expressions.

I don't agree with the person you responded to-- that regular
expressions and an interface to SQL-based databases are a requirement
for web-based work.  Regular expressions are a tool that may or may not
be useful, depending on the problem you're trying to solve.  I don't
know why that seems to be a difficult concept for people to accept.  And
no, not every web application needs a database, and when they do,
SQL-based systems aren't necessarily the best.  Again, I don't know why
&quot;right tool for the job&quot; seems to be such a controversial idea around here.

<QUOTE PREVIOUSPOST="
&gt; There have been some other discussions about Forth socket interfaces,
&gt;  and Marcel Hendrix has got quite far with that, so eventually, the
&gt; HTTP server will implement a direct socket connection in some 30
&gt; lines or so. I'm
sure,
&gt; people will still claim that it's comparing apples with bananas.
">

Depends on what you're comparing.  If you state it is a basic HTTP web
server that can be extended, then I wouldn't have any problem.  If you
say it is a replacement for Apache, then you're spewing nonsense.

There is absolutely no surprise that one can create a basic http server
in just a few lines of code.  It's been done endlessly in Perl, Python,
Ruby, Lua, and dozens of other languages.  And in fact, there are cases
where these lightweight web servers make perfect sense for certain
classes of applications.  For example, it's not uncommon to find
applications that embed small web servers in them so they can use
browsers as their user interface.  WikiCalc is one example.
</POST>
<POST>
<POSTER> hel...@gmail.com </POSTER>
<POSTDATE> 2007-08-14T14:34:00 </POSTDATE>
On Aug 13, 6:38 am, gavino &lt;gavcom ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I mean if forth is this powerful, why isn't it used all over the
&gt; place?
">

The simple fact is that Forth is too simple. You can see Forth as a
way to express. If you do not have to express something, Forth is not
the language for you.

ch ... @visc.us wrote some very stupid answer - an SQL-interface or
regular expressions are only missing in Forths of people that will not
use it. This can not be the reason.

Forth is really too simple. Most people expect something like Java
or .NET-framework. They do not see that they write code with an expiry
date. Since Forth is so simple there is no expiry date - if a word is
missing, it's not complicated to implement one usually. It's also not
complicated to write systems that support multiple levels of
compatiblity. But in a hurry business like web-apps nobody cares about
(it even will ensure jobs in future).

-Helmar
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-14T16:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
hel ... @gmail.com wrote:
&gt; Forth is really too simple. Most people expect something like Java
&gt; or .NET-framework. They do not see that they write code with an expiry
&gt; date. Since Forth is so simple there is no expiry date - if a word is
&gt; missing, it's not complicated to implement one usually. It's also not
&gt; complicated to write systems that support multiple levels of
&gt; compatiblity. But in a hurry business like web-apps nobody cares about
&gt; (it even will ensure jobs in future).
">

That's not it either.  Nothing prevents people from building up their
own sets of abstractions, utilities, and so on on top of environments
like Java or .NET.  Just because Java provides a collection class
doesn't force one to use it-- and in some cases, programmers won't use
it because they have specialized requirements.  Just because .NET
supplies high-level serialization functions doesn't mean you're forced
to use them-- you're free to write your own if you have special needs.

No, the real issue with why Forth isn't used as much is something I
touched on before.  People want to spend their time solving interesting
problems, and endlessly reimplementing jellybean code and common
utilities isn't interesting.

Which would you rather do-- reimplement something that dozens or even
hundreds of programmers have implemented before, or work on the &quot;meat&quot;
of the problem?  Which would you find more satisfaction in--
implementing yet another minimal HTTP server, or designing the
application that rides on top of that server?

There is a time and place for everything.  There are cases where
reimplementing a wheel makes sense.  But the problem the Forth community
seems to have is they don't know when it stops making sense.  That's
seen in the antagonism against libraries and the elitist (in the bad
sense of the word) attitudes against programmers who choose to
specialize or who have different core competencies they draw from.
</POST>
<POST>
<POSTER> hel...@gmail.com </POSTER>
<POSTDATE> 2007-08-14T16:42:00 </POSTDATE>
On Aug 14, 10:11 pm, John Passaniti &lt;n ... @JapanIsShinto.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Which would you find more satisfaction in--
&gt; implementing yet another minimal HTTP server, or designing the
&gt; application that rides on top of that server?
">

I dont know. I did not found the minimal server I needed, so I
implemented it and it *was* interesting. Well I did this in Perl, not
in Forth.

-Helmar
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-15T03:48:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; hel ... @gmail.com wrote:
&gt;&gt; Forth is really too simple. Most people expect something like Java
&gt;&gt; or .NET-framework. They do not see that they write code with an expiry
&gt;&gt; date. Since Forth is so simple there is no expiry date - if a word is
&gt;&gt; missing, it's not complicated to implement one usually. It's also not
&gt;&gt; complicated to write systems that support multiple levels of
&gt;&gt; compatiblity. But in a hurry business like web-apps nobody cares about
&gt;&gt; (it even will ensure jobs in future).

&gt; That's not it either.  Nothing prevents people from building up their
&gt; own sets of abstractions, utilities, and so on on top of environments
&gt; like Java or .NET.  Just because Java provides a collection class
&gt; doesn't force one to use it-- and in some cases, programmers won't use
&gt; it because they have specialized requirements.  Just because .NET
&gt; supplies high-level serialization functions doesn't mean you're forced
&gt; to use them-- you're free to write your own if you have special needs.

&gt; No, the real issue with why Forth isn't used as much is something I
&gt; touched on before.  People want to spend their time solving interesting
&gt; problems, and endlessly reimplementing jellybean code and common
&gt; utilities isn't interesting.

&gt; Which would you rather do-- reimplement something that dozens or even
&gt; hundreds of programmers have implemented before, or work on the &quot;meat&quot;
&gt; of the problem?  Which would you find more satisfaction in--
&gt; implementing yet another minimal HTTP server, or designing the
&gt; application that rides on top of that server?
">

Well, after 30+ years involved in Forth projects, I can't recall any of
our folks spending time &quot;reimplementing jellybean code and common
utilities&quot;.  We have on a few occasions written code that did things
that had been done before:  I remember a MAP protocol implementation
that we did for Saturn that ran several times faster than the
implementation they had, and was so small that they could run it on
smaller, cheaper processors than what had previously been required.
They thought that was a great investment.

But, on the whole, at least on PCs, we use what's there.  Our main line
of work is embedded systems, where virtually every project is custom
from top to bottom, where every byte and cycle counts, and where there
are no available libraries to do most of what needs doing.  And in that
arena, we manage to save our customers considerable amounts of money and
time (based on what they say others have estimated with other approaches).

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> &quot;sl...@jedit.org&quot; &lt;sl...@jedit.org&gt; </POSTER>
<POSTDATE> 2007-08-15T04:33:00 </POSTDATE>
On Aug 15, 3:48 am, Elizabeth D Rather &lt;erather ... @forth.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Our main line
&gt; of work is embedded systems, where virtually every project is custom
&gt; from top to bottom, where every byte and cycle counts, and where there
&gt; are no available libraries to do most of what needs doing.  And in that
&gt; arena, we manage to save our customers considerable amounts of money and
&gt; time (based on what they say others have estimated with other approaches).
">

Would you still use Forth in domains where space and performance are
not necessarily top priorities, and instead, one must interoperate
with existing infrastructure, some of which may be quite inelegant,
complex, or plain broken? For example, relational databases, XML, web
services, COM/ActiveX, .NET applications, 3D graphics with OpenGL,
etc.

Slava
</POST>
<POST>
<POSTER> stephen...@mpeforth.com (Stephen Pelc) </POSTER>
<POSTDATE> 2007-08-15T05:55:00 </POSTDATE>
On Tue, 14 Aug 2007 20:11:16 GMT, John Passaniti

<QUOTE PREVIOUSPOST="
&lt;n ... @JapanIsShinto.com&gt; wrote:
&gt;Which would you rather do-- reimplement something that dozens or even
&gt;hundreds of programmers have implemented before, or work on the &quot;meat&quot;
&gt;of the problem?  Which would you find more satisfaction in--
&gt;implementing yet another minimal HTTP server, or designing the
&gt;application that rides on top of that server?
">

MPE has implemented HTTP servers for embedded systems and PCs (see
http://www.mpeforth.com/powernet.htm for more details). We did it for
a valid economic reason. Clients tell us that the base TCP/IP stack
is less than half the size of equivalent C libraries. The economies of
this in an SoC design are considerable.

Similarly, the economies of implementing a SOAP server on a PC come
from interoperability with packages like Excel and ease of
installation with low distribution cost.

<QUOTE PREVIOUSPOST="
&gt;There is a time and place for everything.  There are cases where
&gt;reimplementing a wheel makes sense.  But the problem the Forth community
&gt;seems to have is they don't know when it stops making sense.  That's
&gt;seen in the antagonism against libraries and the elitist (in the bad
&gt;sense of the word) attitudes against programmers who choose to
&gt;specialize or who have different core competencies they draw from.
">

Please don't label us all. I have stated my view about the necessity
for Forth library code many times in this group. Much of the value
in our cross compilers and VFX Forth comes from the source code
libraries shipped with them. We work hard with our clients to
make sure that this is so.

Stephen

--
Stephen Pelc, stephen ... @mpeforth.com
MicroProcessor Engineering Ltd - More Real, Less Time
133 Hill Lane, Southampton SO15 5AF, England
tel: +44 (0)23 8063 1441, fax: +44 (0)23 8033 9691
web: http://www.mpeforth.com - free VFX Forth downloads
</POST>
<POST>
<POSTER> stephen...@mpeforth.com (Stephen Pelc) </POSTER>
<POSTDATE> 2007-08-15T06:23:00 </POSTDATE>
On Wed, 15 Aug 2007 01:33:54 -0700, &quot;sl ... @jedit.org&quot;

<QUOTE PREVIOUSPOST="
&lt;sl ... @jedit.org&gt; wrote:
&gt;Would you still use Forth in domains where space and performance are
&gt;not necessarily top priorities, and instead, one must interoperate
&gt;with existing infrastructure, some of which may be quite inelegant,
&gt;complex, or plain broken? For example,
&gt;  relational databases,
">

been there, done that, got the tee-shirt!

<QUOTE PREVIOUSPOST="
&gt; XML
ditto
&gt; web services
">

ditto

<QUOTE PREVIOUSPOST="
&gt; COM/ActiveX, .NET applications, 3D graphics with OpenGL
">

We have unreleased interfaces for COM/ActiveX, and other people
have released Forth code for all of these.

Stephen

--
Stephen Pelc, stephen ... @mpeforth.com
MicroProcessor Engineering Ltd - More Real, Less Time
133 Hill Lane, Southampton SO15 5AF, England
tel: +44 (0)23 8063 1441, fax: +44 (0)23 8033 9691
web: http://www.mpeforth.com - free VFX Forth downloads
</POST>
<POST>
<POSTER> Jonah Thomas &lt;j2tho...@cavtel.net&gt; </POSTER>
<POSTDATE> 2007-08-15T10:05:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;sl ... @jedit.org&quot; &lt;sl ... @jedit.org&gt; wrote:
&gt; Elizabeth D Rather &lt;erather ... @forth.com&gt; wrote:
&gt; &gt; Our main line
&gt; &gt; of work is embedded systems, where virtually every project is custom
&gt; &gt; from top to bottom, where every byte and cycle counts, and where
&gt; &gt; there are no available libraries to do most of what needs doing.
&gt; &gt; And in that arena, we manage to save our customers considerable
&gt; &gt; amounts of money and time (based on what they say others have
&gt; &gt; estimated with other approaches).

&gt; Would you still use Forth in domains where space and performance are
&gt; not necessarily top priorities, and instead, one must interoperate
&gt; with existing infrastructure, some of which may be quite inelegant,
&gt; complex, or plain broken? For example, relational databases, XML, web
&gt; services, COM/ActiveX, .NET applications, 3D graphics with OpenGL,
&gt; etc.
">

If you have to interact with existing broken code, Forth provides easy
interactive testing. It might be a good choice, particularly
supplemented with the particular tools that you find most helpful in the
particular case. Or there might be some other language implementation
that fits the particular case better. Maybe Python or Ruby will give you
the same benefits and already have all the tools you need.
</POST>
<POST>
<POSTER> Jonah Thomas &lt;j2tho...@cavtel.net&gt; </POSTER>
<POSTDATE> 2007-08-15T10:28:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti &lt;n ... @JapanIsShinto.com&gt; wrote:
&gt; hel ... @gmail.com wrote:
&gt; Nothing prevents people from building up their
&gt; own sets of abstractions, utilities, and so on on top of environments
&gt; like Java or .NET.  Just because Java provides a collection class
&gt; doesn't force one to use it-- and in some cases, programmers won't use

&gt; it because they have specialized requirements.  Just because .NET
&gt; supplies high-level serialization functions doesn't mean you're forced

&gt; to use them-- you're free to write your own if you have special needs.
">

In the old days the complicated tools were inevitably buggy, so you'd
spend a lot of time working around the compiler bugs etc. Maybe now the
complex languages have the bugs removed so that they're easy to use, and
then you can ignore any complexities you aren't interested in. That
would be good.

<QUOTE PREVIOUSPOST="
&gt; No, the real issue with why Forth isn't used as much is something I
&gt; touched on before.  People want to spend their time solving
&gt; interesting problems, and endlessly reimplementing jellybean code and
&gt; common utilities isn't interesting.
">

I doubt that. I think it's more that employed programmers don't use
Forth much because managers don't like it. And unemployed programmers
don't use Forth much because it doesn't look good on a resume. Hobbyists
might get excited about Forth and use it, but if they pick up a random
free implementation to learn Forth on, and then it gives display and
keyboard and disk I/O and nothing else, what do they do with it?

<QUOTE PREVIOUSPOST="
&gt; Which would you rather do-- reimplement something that dozens or even
&gt; hundreds of programmers have implemented before, or work on the &quot;meat&quot;

&gt; of the problem?  Which would you find more satisfaction in--
&gt; implementing yet another minimal HTTP server, or designing the
&gt; application that rides on top of that server?
">

Depending on the application, it might make sense to intertwine the app
with the server. Depending. Maybe a typical server interface is just
what you need, and there's no reason to have any different interface. It
depends on what you're doing.

If you care about the server's security it might make sense to have a
minimal server that does just exactly what you want and no more. It
seems like that ought to be the easiest to make reasonably secure. Or
you could use somebody else's server and let security be their problem.
That's certainly the easy way, provided it doesn't cause *you* security
problems.

<QUOTE PREVIOUSPOST="
&gt; There is a time and place for everything.  There are cases where
&gt; reimplementing a wheel makes sense.  But the problem the Forth
&gt; community seems to have is they don't know when it stops making sense.
&gt;  That's
&gt; seen in the antagonism against libraries and the elitist (in the bad
&gt; sense of the word) attitudes against programmers who choose to
&gt; specialize or who have different core competencies they draw from.
">

I haven't seen any significant antagonism against libraries. Not like
people hear somebody's building a library so they pick up the torches
and pitchforks. It's more that there aren't that many libraries, and a
lot of people scrape along without them rather than build them, and some
people talk like they wouldn't use them if they were available. Not like
there's a Forth cabal, and when somebody says &quot;I don't care what anyboyd
thinks, I'm going to build a string libarary!&quot; then they get him
blacklisted from all the Forth blogs and Forth wikis and his credit
cards are all cancelled and DHS investigates him as a terrorist suspect.
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-15T13:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
sl ... @jedit.org wrote:
&gt; On Aug 15, 3:48 am, Elizabeth D Rather &lt;erather ... @forth.com&gt; wrote:
&gt;&gt; Our main line
&gt;&gt; of work is embedded systems, where virtually every project is custom
&gt;&gt; from top to bottom, where every byte and cycle counts, and where there
&gt;&gt; are no available libraries to do most of what needs doing.  And in that
&gt;&gt; arena, we manage to save our customers considerable amounts of money and
&gt;&gt; time (based on what they say others have estimated with other approaches).

&gt; Would you still use Forth in domains where space and performance are
&gt; not necessarily top priorities, and instead, one must interoperate
&gt; with existing infrastructure, some of which may be quite inelegant,
&gt; complex, or plain broken? For example, relational databases, XML, web
&gt; services, COM/ActiveX, .NET applications, 3D graphics with OpenGL,
&gt; etc.
">

Those aren't fields that I work in, so I'm not really qualified to
answer.  But we do have some customers who use SwiftForth for this type
of work, and they seem quite happy with it.

I also know that Greg Bailey, whom I've mentioned here before, has an
extensive database/internet system that he's used for some major
customers.  It's all Forth (runs totally native on PC hardware) and many
times faster than conventional Windows/*nix-based systems.  Also more
secure, since his software isn't subject to the common exploits.  In 15
years none of his customers has been subjected to any attacks (although
he's detected some attempts).

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-15T17:47:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jonah Thomas wrote:
&gt; In the old days the complicated tools were inevitably buggy, so you'd
&gt; spend a lot of time working around the compiler bugs etc. Maybe now the
&gt; complex languages have the bugs removed so that they're easy to use, and
&gt; then you can ignore any complexities you aren't interested in. That
&gt; would be good.
">

You're being vague here so I don't know exactly what &quot;complicated tools&quot;
you're talking about.  I have certainly in my experience had to deal
with things such as compiler bugs, but the last time I checked, Forth
was the product of human beings and as such is subject to bugs in
various implementations.  I vividly remember some spectacular bugs in
some of the past commercial Forths I've used (valForth, UR/Forth,
MMSForth and some Apple II Forth that I've long since forgotten the name
of).

<QUOTE PREVIOUSPOST="
&gt;&gt; No, the real issue with why Forth isn't used as much is something I
&gt;&gt; touched on before.  People want to spend their time solving
&gt;&gt; interesting problems, and endlessly reimplementing jellybean code and
&gt;&gt; common utilities isn't interesting.

&gt; I doubt that. I think it's more that employed programmers don't use
&gt; Forth much because managers don't like it.
">

Yes, I know that's one of the common conspiracy theories regarding
Forth.  And it wouldn't surprise me if you could actually produce a
manager or two who disliked Forth.  The world is full of irrational
people who dislike things for trivial reasons.

But I seriously doubt this is in any way widespread.  First, most
managers likely don't even know what Forth is because Forth has been
marginalized to just embedded systems (ironically by Forthers
themselves).  So no, the reason why the manager looking to hire a
programmer to do web applications isn't hiring Forth programmers is
because Forth isn't on their radar screen.  Not because they &quot;don't like
it.&quot;

&gt; And unemployed programmers

<QUOTE PREVIOUSPOST="
&gt; don't use Forth much because it doesn't look good on a resume.
">

Again, this doesn't make sense to me.  Explain to me why someone reading
over the typical bloated resume-- where most people will put down
nonsense like HTML as a programming language-- would care in any way
that someone added Forth to the litany of what they know.  Most won't
know what Forth is.  Those who do will either judge it as relevant or not.

Listing proficiency in Forth on my resume has never presented a problem
to me, but I've already had discussions in comp.lang.forth that indicate
I apparently live in some bizarre rift of the universe where people are
rational.  Apparently everyone else lives in Silicon Valley where
apparently the mere mention of Forth causes people to froth.  Or at
least it's a good story and feeds into some people's persecution complexes.

Here's a crazy idea.  The next time someone writes in comp.lang.forth
that they lost a job because they had Forth on their resume, try this
experiment.  Look over their past messages.  Can they communicate well?
Get their resume.  How do they present themselves and their
experience?  Ask them some questions.  Does it sound like they have a clue?

Do this, and I'll bet cold hard cash that FAR MORE OFTEN THAN NOT, the
people who complain that Forth make them lose a job are the same people
you yourself wouldn't want to hire.  But like the black person who was
convinced they didn't get the job because the company had racial biases
or the woman convinced she didn't get the job because of sexist
attitudes, the truth may be more basic.

Nah, don't.  It would hurt people's feelings and it might start a
cascade of critical questions being asked challenging other cherished
assumptions around here.  Yeah, they didn't get the job because of
Forth.  Yeah, that's it.

<QUOTE PREVIOUSPOST="
&gt;&gt; of the problem?  Which would you find more satisfaction in--
&gt;&gt; implementing yet another minimal HTTP server, or designing the
&gt;&gt; application that rides on top of that server?

&gt; Depending on the application, it might make sense to intertwine the app
&gt; with the server. Depending. Maybe a typical server interface is just
&gt; what you need, and there's no reason to have any different interface. It
&gt; depends on what you're doing.
">

EXACTLY!  The key here is that while *some* people only need a HTTP
server to serve up static content, *other* people are doing far more
sophisticated things.  And while *some* people think a five line
Fahrenheit to Celsius temperature converter CGI script demonstrates the
state of the art in web-based user interfaces, there are other people
doing very sophisticated applications that do far more.

The notion that &quot;it depends on what you're doing&quot; is something I would
think would be so fundamental to most of the discussions here in
comp.lang.forth, but all too often, it seems it's the last thing
discussed.  Bernd comes out with his webserver and we have people-- both
neophyte and experienced-- who look at that and say, &quot;gawd, why would
anyone want Apache?&quot;  These are the same people who likely have never
written a significant web application who would understand that the
webserver component is *trivial* compared to the real challenges that a
significant application takes.

<QUOTE PREVIOUSPOST="
&gt; If you care about the server's security it might make sense to have a
&gt; minimal server that does just exactly what you want and no more. It
&gt; seems like that ought to be the easiest to make reasonably secure. Or
&gt; you could use somebody else's server and let security be their problem.
&gt; That's certainly the easy way, provided it doesn't cause *you* security
&gt; problems.
">

Again, there is a time and place for everything.  There are applications
where I might take the same approach Bernd did.  We have an upcoming
project that needs to do little more than serve up a static web page
with a Java app embedded in it.  For that, a simple server is perfect
and something like Apache (even a stripped down embedded version) is
grotesque overkill.

Right tool for the right job.  It's a basic lesson, but when that tool
happens to be written in Forth, all critical thinking and skepticism
seems to go flying out the window here.  Note how few people here ask
questions that probe the boundaries of where Forth makes sense.  It's a
rare and special thing when it happens.

<QUOTE PREVIOUSPOST="
&gt; I haven't seen any significant antagonism against libraries.
">

Then you haven't paid attention.

&gt; Not like

<QUOTE PREVIOUSPOST="
&gt; people hear somebody's building a library so they pick up the torches
&gt; and pitchforks. It's more that there aren't that many libraries, and a
&gt; lot of people scrape along without them rather than build them, and some
&gt; people talk like they wouldn't use them if they were available.
">

Yes, and that's antagonism.  And depending on who those people are and
the perceived clout they have, their opinions influence others.  The end
result is that the Forth community has largely internalized the notion
that &quot;libraries are bad,&quot; supplemented with the usual array of
pejorative, sour-grapes statements to go to justify it.

&gt; Not like

<QUOTE PREVIOUSPOST="
&gt; there's a Forth cabal, and when somebody says &quot;I don't care what anyboyd
&gt; thinks, I'm going to build a string libarary!&quot; then they get him
&gt; blacklisted from all the Forth blogs and Forth wikis and his credit
&gt; cards are all cancelled and DHS investigates him as a terrorist suspect.
">

No, it works the other way.  You start with some of the more
unquestioning hero-worship of Charles Moore, toss in some of the
negative soundbites against the use of libraries (&quot;they are for lazy,
stupid, incompetent programmers&quot;), mix in people who lack the
sophistication to understand the skills needed to build libraries that
are useful, and whirl in a blender.  Pour into a glass and sprinkle with
the fact that aside from highly marginal examples like the FSL and a
handful of people's toolbelts, there are in fact no serious public
libraries.  There-- you have all the motivation any right-thinking
Forther needs to ignore libraries.
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-15T18:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jonah Thomas wrote:
&gt;&gt; Would you still use Forth in domains where space and performance are
&gt;&gt; not necessarily top priorities, and instead, one must interoperate
&gt;&gt; with existing infrastructure, some of which may be quite inelegant,
&gt;&gt; complex, or plain broken? For example, relational databases, XML, web
&gt;&gt; services, COM/ActiveX, .NET applications, 3D graphics with OpenGL,
&gt;&gt; etc.

&gt; If you have to interact with existing broken code, Forth provides easy
&gt; interactive testing.
">

No, probably not.  Forth does indeed provide easy, interactive
testing... FOR FORTH CODE.  But if the underlying system isn't Forth,
then there is the potential for a very big impedance mismatch.  A good
example would be a scripting language where variables could freely
mutate between strings and integers.  To work with that natively, you're
going to need some very un-Forthlike abstractions.

Can it be done?  Sure.  Does Forth provide anything more than any other
interactive interpreted language with a FFI to the underlying system?
No, probably not.

&gt; It might be a good choice, particularly

<QUOTE PREVIOUSPOST="
&gt; supplemented with the particular tools that you find most helpful in the
&gt; particular case. Or there might be some other language implementation
&gt; that fits the particular case better. Maybe Python or Ruby will give you
&gt; the same benefits and already have all the tools you need.
">

Languages like Python and Ruby and Lua feature reasonable FFI's as well
as reasonable extension mechanisms.  And a side benefit is that because
languages like this tend to have a single canonical implementation, it
isn't just hand-waving when people say, &quot;now write an interface to the
underlying system.&quot;  Every Forth presents it's own method of interfacing
to the underlying system.  Other languages don't tend to have that
particular issue.  For example, the way I extend Lua to talk to the
underlying system is pretty much the same no matter what platform
(Windows, MacOS, Linux, VxWorks, etc.) that I'm on.
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-15T18:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Elizabeth D Rather wrote:
&gt; Well, after 30+ years involved in Forth projects, I can't recall any of
&gt; our folks spending time &quot;reimplementing jellybean code and common
&gt; utilities&quot;.
">

Of course not.  You live in the Forth, Inc. bubble where you have at
your disposal 30+ years of code you can reuse, rework, or just inspect
for inspiration or design experience.

Take yourself outside that bubble and put yourself in the shoes of a
&quot;lone wolf&quot; Forth programmer who is proficient with the language, but
hasn't had the 30+ years of practical experience and building up of a
personal tool belt.

For those far more typical users of Forth, they are forced to
reimplement code that other programmers using other programming
languages and environments take for granted.  Much has been written
about the productivity of Forth, but even if you're many times more
productive than other programmers, the Forth programmer is still saddled
with doing more work *before* they even get to the &quot;glory&quot; portion of
the application.

<QUOTE PREVIOUSPOST="
&gt; But, on the whole, at least on PCs, we use what's there.  Our main line
&gt; of work is embedded systems, where virtually every project is custom
&gt; from top to bottom, where every byte and cycle counts, and where there
&gt; are no available libraries to do most of what needs doing.
">

A funny thing happened on the way to 2007.

I'm sitting next to a project we're just finishing up.  It's an embedded
system that combines some very sophisticated and unique work.  There is
no library that implements the core algorithms, no &quot;cookbook&quot; that could
be applied to what it does.  Significant effort went into performance
and size.

But the same project also has elements that are jellybean.  For
starters, it can receive firmware updates from USB memory devices.  So
that means in addition to every unique thing it does, it *also* has to
do some pretty mundane things.  It needs to deal with USB.  It needs to
read data from a FAT filesystem.  It needs to be able to manipulate that
filesystem and leave files behind.

The same project also has a web-based user interface.  So again in
addition to the unique parts of the system, it also has to serve content
over HTTP, has to support AJAX, and so on.  At the same time, it *also*
has to do some very unique things and to present a reasonable
programmer's interface to what is controls.

So when you look at this kind of project, you see something I think is
increasingly common:  You see elements of the system that are mundane
and common-- elements to provide a standards-based connectivity to other
systems (such as networking) and hardware (such as portable memory
devices), elements to bring friendly user control based on familiar
interfaces (such as web browsers), and so on.  At the same time, these
modern embedded systems *also* still continue doing what they do best--
unique, application-specific systems that do things that require
consideration of performance and size and cost.

So when you look at modern embedded systems that combine elements of
both the mundane and the unique, a question comes up:  Where should you
be putting your effort?  In our case, we recognized that the value we as
a company could bring to this system wasn't in reimplementing yet
another FAT file system driver, wasting time creating yet another HTTP
server, or developing unique new communication protocols.  Instead, we
spent effort on the algorithms that write the data to the FAT file
system, writing the higher-level abstractions on top of the HTTP server,
and developing the core algorithms instead of goofing around creating
new proprietary communications protocols.

So what that means in a practical sense is that while the Forther who
thought they needed to reimplement a HTTP server was taking the first
yawn reading the relevant RFC's, we were working on the higher-level
code that made our user interface unique.  While the Forther who wanted
to rewrite a FAT driver was on the second round of testing with some USB
memory devices they got at the store, we were working on the data
formats we would write to the device.

To me, if you had to isolate the single biggest problem the Forth
community has, it's a prevailing attitude that unless you write every
last byte of code in a system, then you're doing something wrong.  It's
an attitude that might have served the embedded folk well in the past,
but increasingly it's counterproductive.  And of course, it makes no
sense in domains (like web applications) where the value doesn't come
from the low-level services (like HTTP servers) but in the high-level
application.
</POST>
<POST>
<POSTER> John Passaniti &lt;n...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-15T19:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Stephen Pelc wrote:
&gt; MPE has implemented HTTP servers for embedded systems and PCs (see
&gt; http://www.mpeforth.com/powernet.htm for more details). We did it for
&gt; a valid economic reason.
">

I guess I shouldn't have been too surprised.  I went to your page and
after the HTTP server, you did something that I haven't see anyone else
here even address.  Here's what your page says:

Powernet uses a near copyless implementation for good
performance and low memory footprint. PowerNet v4.0 is
smaller and faster than previous releases. A full
build on an ARM including the Forth open interpreter/
compiler, RTOS support, three serial drivers, Ethernet
driver, UDP and TCP, and Echo, Telnet and HTTP (with
ASP, CGI and ForthScript) servers requires 116kb of ROM.

It's that last sentence that puts you apart.  Unlike the rest of the
peanut gallery, you're not just talking about a raw HTTP server.  And
I'm guessing that's because you recognize that such a thing is trivial
and uninteresting.  Right after it, you list ASP, CGI, and ForthScript.
It suggests you understand that building web applications requires
more than just the ability to serve static content.

Of course, the devil is in the details.  I have a strong suspicion that
what you call ASP isn't, CGI isn't, and ForthScript is likely either
some templating words to allow Forth code to exist inside static web pages.

But even if your definitions of ASP and CGI and ForthScript are trivial
abstractions that faintly reflect on the promise, at least if it comes
from someone like you, maybe people here will finally understand that
web applications are about more than the ability to serve web pages.

<QUOTE PREVIOUSPOST="
&gt;&gt; There is a time and place for everything.  There are cases where
&gt;&gt; reimplementing a wheel makes sense.  But the problem the Forth community
&gt;&gt; seems to have is they don't know when it stops making sense.  That's
&gt;&gt; seen in the antagonism against libraries and the elitist (in the bad
&gt;&gt; sense of the word) attitudes against programmers who choose to
&gt;&gt; specialize or who have different core competencies they draw from.

&gt; Please don't label us all. I have stated my view about the necessity
&gt; for Forth library code many times in this group. Much of the value
&gt; in our cross compilers and VFX Forth comes from the source code
&gt; libraries shipped with them. We work hard with our clients to
&gt; make sure that this is so.
">

Are those source code libraries part of any public distribution of code?
If not, you're part of the problem.  I'm not suggesting that you
should turn MPE into a total open source company.  But there is likely
significant jellybean code that could be used to seed public
repositories of reusable Forth source while protecting the unique code
that you use to differentiate yourself from the competition.  Well
written, well documented, well tested code from a recognized Forth
expert is exactly the kind of thing that would bootstrap a larger public
effort.
</POST>
<POST>
<POSTER> Jonah Thomas &lt;j2tho...@cavtel.net&gt; </POSTER>
<POSTDATE> 2007-08-15T20:04:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti &lt;n ... @JapanIsShinto.com&gt; wrote:
&gt; Jonah Thomas wrote:
&gt; &gt;&gt; No, the real issue with why Forth isn't used as much is something I

&gt; &gt;&gt; touched on before.  People want to spend their time solving
&gt; &gt;&gt; interesting problems, and endlessly reimplementing jellybean code
&gt; &gt;and&gt; common utilities isn't interesting.

&gt; &gt; I doubt that. I think it's more that employed programmers don't use
&gt; &gt; Forth much because managers don't like it.

&gt; So no, the reason why the manager looking to hire a
&gt; programmer to do web applications isn't hiring Forth programmers is
&gt; because Forth isn't on their radar screen.  Not because they &quot;don't
&gt; like it.&quot;
">

Yes. That's what I should have said.

<QUOTE PREVIOUSPOST="
&gt;  &gt; And unemployed programmers
&gt; &gt; don't use Forth much because it doesn't look good on a resume.

&gt; Explain to me why someone reading
&gt; over the typical bloated resume-- where most people will put down
&gt; nonsense like HTML as a programming language-- would care in any way
&gt; that someone added Forth to the litany of what they know.  Most won't
&gt; know what Forth is.  Those who do will either judge it as relevant or
&gt; not.
">

I agree. For most jobs it doesn't help the resume. If you care about
that when you do a self-funded project, you'll do something that will
help the resume. Again I said it wrong.

<QUOTE PREVIOUSPOST="
&gt; The notion that &quot;it depends on what you're doing&quot; is something I would

&gt; think would be so fundamental to most of the discussions here in
&gt; comp.lang.forth, but all too often, it seems it's the last thing
&gt; discussed.  Bernd comes out with his webserver and we have people--
&gt; both neophyte and experienced-- who look at that and say, &quot;gawd, why
&gt; would anyone want Apache?&quot;  These are the same people who likely have
&gt; never written a significant web application who would understand that
&gt; the webserver component is *trivial* compared to the real challenges
&gt; that a significant application takes.
">

Well, if what you need is a webserver component you can add to a Forth
system, Apache is overkill. A complicated interface, with lots of
capabilities on the far side that are out of your control, that you have
to use just right. If you're building a significant application in
Forth, the trivial webserver component is just right. Of course, if that
isn't what you're doing you might easily prefer Apache.

It looks to me like the central goodness of Bernd's component is that it
gives the core functionality in a way that can be added to many Forths.
If all you want is web stuff in a professional Forth, you can get that
with SwiftForth and ProForth. There are some limitations because they
have products to sell and can't give everything away for free, but those
aren't giant limitations, and for a professional application the prices
are fine. But there are lots of hobbyist Forths that give you just
keyboard, monitor, disk and maybe COM ports. Getting some of what it
takes to do webservers with them is very nice.

<QUOTE PREVIOUSPOST="
&gt; Right tool for the right job.  It's a basic lesson, but when that tool

&gt; happens to be written in Forth, all critical thinking and skepticism
&gt; seems to go flying out the window here.  Note how few people here ask
&gt; questions that probe the boundaries of where Forth makes sense.  It's
&gt; a rare and special thing when it happens.
">

There used to be an ideology that said it makes sense to start from bare
metal and design the application with a minimal number of separate
levels. When you get specialists designing each level, who don't know
how the other levels work, they likely get mismatches of various sorts.
Especially when you have higher levels that were originally designed for
something else and you're trying to warp them a little for your
application, things can turn real real inefficient. And you can
re-implement the same routine at each level, because it didn't seem
important enough to put into the simple interface but it was useful in
different contexts. So you could not only get the same routine
implemented six different times but sometimes it may be implemented
particularly inefficiently, or maybe even with bugs missing at other
levels. How mcuh better if you can simplify the application to the point
that one great programmer can do the whole thing, from the bottom up!

It's a pleasant ideology. I'd like to believe it could be that way.
There are some success stories, and some failures, and lots of times no
great programmer gets the opportunity. I think even when that approach
works it's self-limiting. If the existing tools don't fit the problem
domain very well and you come up with a better interface, the B team
*ought* to copy your interface so they'll do better, and next time it
will be harder for you to outcompete them. The lone cowboy just isn't
going to beat the professional team consistently, becsause they'll keep
improving and the closer they are to perfection the less room there is
to beat them. Plus, sometimes they really can easily adapt something
they've done before and get an adequate result quickly and cheaply.
There's a lot more room for the great innovator when the standard
methods are plainly inadequate.

I want to believe in it, so when I hear about simple Forth solutions
replacing complex mundane solutions, I like it. I want it to be true.
And sometimes it is true. Sometimes the complex stuff does lots and lots
of things that aren't useful. &quot;My ginsu knife is better than your paring
knife. Mine has a serrated blade on one side and a straight blade on the
other. It has a can opener, a bottle opener, a grater, a cheese slicer,
an apple corer, a garlic press, and a turkey baster. And that's just on
the blade. The handle unfolds to be a nutcracker, and the end of the
handle is a potato masher.&quot; &quot;How good is it at paring apples?&quot; &quot;Great!
The best way is to put the blade in a vice and turn the apple against
it, and in good conditions six people can pare apples at the same time,
three per edge.&quot;

When I hear about a simple solution outdoing a standard solution, I
don't immediately get suspicious and assume it's too good to be true and
try to disprove it. For some circumstances, the simple approach might be
just perfect. I like it when it works out. Of course, when my money is
on the line I consider it very carefully. But when it's a story with an
outcome I like, well, what's the harm in basking in it awhile?

<QUOTE PREVIOUSPOST="
&gt; &gt; I haven't seen any significant antagonism against libraries.

&gt; Then you haven't paid attention.

&gt;  &gt; Not like
&gt; &gt; people hear somebody's building a library so they pick up the
&gt; &gt; torches and pitchforks. It's more that there aren't that many
&gt; &gt; libraries, and a lot of people scrape along without them rather than
&gt; &gt; build them, and some people talk like they wouldn't use them if they
&gt; &gt; were available.

&gt; Yes, and that's antagonism.  And depending on who those people are and

&gt; the perceived clout they have, their opinions influence others.  The
&gt; end result is that the Forth community has largely internalized the
&gt; notion that &quot;libraries are bad,&quot; supplemented with the usual array of
&gt; pejorative, sour-grapes statements to go to justify it.
">

If that level of antagonism is important to you, how come you say
managers don't discourage Forth?
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-15T22:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; Elizabeth D Rather wrote:
&gt;&gt; Well, after 30+ years involved in Forth projects, I can't recall any
&gt;&gt; of our folks spending time &quot;reimplementing jellybean code and common
&gt;&gt; utilities&quot;.

&gt; Of course not.  You live in the Forth, Inc. bubble where you have at
&gt; your disposal 30+ years of code you can reuse, rework, or just inspect
&gt; for inspiration or design experience.

&gt; Take yourself outside that bubble and put yourself in the shoes of a
&gt; &quot;lone wolf&quot; Forth programmer who is proficient with the language, but
&gt; hasn't had the 30+ years of practical experience and building up of a
&gt; personal tool belt.

&gt; For those far more typical users of Forth, they are forced to
&gt; reimplement code that other programmers using other programming
&gt; languages and environments take for granted.  Much has been written
&gt; about the productivity of Forth, but even if you're many times more
&gt; productive than other programmers, the Forth programmer is still saddled
&gt; with doing more work *before* they even get to the &quot;glory&quot; portion of
&gt; the application.
">

Well, the &quot;Forth, Inc. bubble&quot; is a pretty large one, with several
thousand users and mechanisms (mostly email lists augmented by a
searchable database of past emails) for communicating and sharing code.
We include quite a bit of &quot;toolbelt&quot; code with our products, and I'm
sure MPE does, too.  Wil Baden published his fairly extensive toolbelt.
There are communities around most of the widely used public
implementations, as well, although there isn't the equivalent of
centralized depositories that some of the more widely used languages have.

IMO the &quot;lone wolf&quot; who has to start from scratch for everything is
doing so mostly by choice, not by necessity.

...

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; I'm sitting next to a project we're just finishing up.  It's an embedded
&gt; system that combines some very sophisticated and unique work.  There is
&gt; no library that implements the core algorithms, no &quot;cookbook&quot; that could
&gt; be applied to what it does.  Significant effort went into performance
&gt; and size.

&gt; But the same project also has elements that are jellybean.  For
&gt; starters, it can receive firmware updates from USB memory devices.  So
&gt; that means in addition to every unique thing it does, it *also* has to
&gt; do some pretty mundane things.  It needs to deal with USB.  It needs to
&gt; read data from a FAT filesystem.  It needs to be able to manipulate that
&gt; filesystem and leave files behind.

&gt; The same project also has a web-based user interface.  So again in
&gt; addition to the unique parts of the system, it also has to serve content
&gt; over HTTP, has to support AJAX, and so on.  At the same time, it *also*
&gt; has to do some very unique things and to present a reasonable
&gt; programmer's interface to what is controls.
">

Yes, those are fairly generic, and good examples of the toolbelt itmes
we share, as mentioned above.  However, they often include some
assembler code (less nowadays with optimizing compilers) and assumptions
about the multitasking environment in our products.  So, they're easily
sharable within the 'bubble', and probably fairly easy to adapt to other
Forths.

...

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; So when you look at modern embedded systems that combine elements of
&gt; both the mundane and the unique, a question comes up:  Where should you
&gt; be putting your effort?  In our case, we recognized that the value we as
&gt; a company could bring to this system wasn't in reimplementing yet
&gt; another FAT file system driver, wasting time creating yet another HTTP
&gt; server, or developing unique new communication protocols.  Instead, we
&gt; spent effort on the algorithms that write the data to the FAT file
&gt; system, writing the higher-level abstractions on top of the HTTP server,
&gt; and developing the core algorithms instead of goofing around creating
&gt; new proprietary communications protocols.

&gt; So what that means in a practical sense is that while the Forther who
&gt; thought they needed to reimplement a HTTP server was taking the first
&gt; yawn reading the relevant RFC's, we were working on the higher-level
&gt; code that made our user interface unique.  While the Forther who wanted
&gt; to rewrite a FAT driver was on the second round of testing with some USB
&gt;  memory devices they got at the store, we were working on the data
&gt; formats we would write to the device.
">

Using outside code (especially in another language) isn't always an
instant thing, though, unless you've used it before.  First you have to
find it, and maybe pick which of several versions most closely meets
your needs.  Then you have to write whatever 'glue' code is needed, and
sort out whatever issues there may be re documentation, &quot;undocumented
features&quot;, etc.  Sometimes it's quicker to use the pre-existing code,
but not always.

<QUOTE PREVIOUSPOST="
&gt; To me, if you had to isolate the single biggest problem the Forth
&gt; community has, it's a prevailing attitude that unless you write every
&gt; last byte of code in a system, then you're doing something wrong.  It's
&gt; an attitude that might have served the embedded folk well in the past,
&gt; but increasingly it's counterproductive.  And of course, it makes no
&gt; sense in domains (like web applications) where the value doesn't come
&gt; from the low-level services (like HTTP servers) but in the high-level
&gt; application.
">

That attitude might or might not prevail here on c.l.f (I'm not sure
it's as pervasive as you seem to think), but in our 'bubble' (which is
probably a good deal larger than the c.l.f community, not to mention the
communities surrounding other popular implementations) there's quite a
lot of shared and sharable code around.

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-15T23:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jonah Thomas wrote:
&gt; Well, if what you need is a webserver component you can add to a Forth
&gt; system, Apache is overkill.
">

I have an exercise for you-- and for anyone else who thinks what you
wrote is categorically true.  I want you to go to the online Apache
documentation, and I want you to look through both the raw, unextended
services it provides and the additional services it provides in the core
modules.

What I want you to do is to page through the section on configuration
and just skim.  You don't have to read everything and you don't have to
understand it all.  But what you should do is make a mental note about
the kinds of functionality Apache provides.  Take a look also at the
performance-related configuration variables and again, you don't have to
understand what everything does, but stop for a moment and think about
why those configuration variables exist.

When you're done (it shouldn't take more than about 20 minutes of
careful skimming), I'd like you to come back here to comp.lang.forth and
tell me that you still think Apache is overkill.

I'll fearlessly predict what will happen.  You'll first learn how to
qualify your statements.  Instead of saying Apache is overkill, you'll
likely quickly come to an understanding that there are classes of
applications where a small in-application web server couldn't possibly
cut it.  And you'll learn that yes, there are classes of applications
where Apache is overkill.  But you apparently don't appreciate the
difference yet.

Another thing it's possible you'll learn is that web applications can
involve a number of services that aren't necessarily obvious.  For
example, one very common thing to do with embedded webservers is to
present a web-based user interface to configure the system.  But since
normal HTTP traffic is sent in the clear, it's dangerous to put such a
device on a public network.  You'll want to encrypt communications with
SSL, and there is a of lot of detail there.

The stock answer is that &quot;it's just a few more lines of code.&quot;  Maybe.
But to write the code, you have to understand the standards (and often,
the deviations from the standards).  And you then need to design it.
And then you code it.  And then you test it.  And all the while that
you're doing this, YOU AREN'T WRITING A LINE OF APPLICATION CODE.
You're working on the plumbing.

THAT is why people use webservers such as Apache.  Apache isn't some
penultimate thing of perfect beauty.  It's quite ugly in places.  But
Apache isn't just a sequence of bytes spinning on a hard drive.  It's
the experience of hundreds of contributors.  It's years of testing.
It's years of performance tuning.  It's years of security analysis.
It's not perfect, but it's got a hell of a lot more thought in it than
an ad-hoc webserver hacked in Forth.

<QUOTE PREVIOUSPOST="
&gt; It looks to me like the central goodness of Bernd's component is that it
&gt; gives the core functionality in a way that can be added to many Forths.
">

Sort of.  In it's present form, the Forth must be hosted on a Unix or
Unix-like operating system that offers inetd.  So, it won't be of help
under Windows (without yet more layers of software like Cygwin).  It
would certainly be possible to remove that dependency and have the
webserver code directly work with sockets.  But that, again, is non-zero
time spent on a trivial part of the application when that same time
could be spent on far more interesting places.

<QUOTE PREVIOUSPOST="
&gt; I want to believe in it, so when I hear about simple Forth solutions
&gt; replacing complex mundane solutions, I like it. I want it to be true.
&gt; And sometimes it is true.
">

And sometimes it isn't.

There seems to be a lot of romanticism here in comp.lang.forth.  It's a
form of sentimentalized nostalgia-- like when someone tells you, &quot;things
were better back in the good old days.&quot;  Which old days were those?
When child labor was common?  When women couldn't vote?  When blacks
were slaves?

The problem with romanticism over the past is that it's very easy to
remember the parts that were genuinely better, and very easy to forget
the negatives.  The same goes for software.

I look back at what I was doing in the 80's and it's true-- I had much
more control over the hardware and it was both powerful and empowering.
I knew how my systems worked from the highest level of the application
down to the transistor level.

But let's look at the negatives.  Because I designed the hardware and
software, the limits of my experience and my prejudices got in the way.
If I didn't understand something, I either had to spend the time to
understand that (delaying me) or I had to find a different solution
(potentially less elegant).

I look at the work I'm doing now, and while I lament that I sometimes
have less control over the hardware and less deep understanding of parts
of the software (such as when under an operating system), I look at the
scope of the work I'm doing now and it blows me away.  Being part of a
group where we can not only concentrate on what we're best at but also
collaborate and share ideas has allowed me to work on projects that
would have been far outside the scope of what I could do alone.  And I'm
getting unexpected benefits too-- fresh perspectives that challenge my
views.  New ideas that I wouldn't have ever come up with myself.

Those were things I didn't have in the &quot;good old days&quot; of being a lone
wolf and designing everything myself.

<QUOTE PREVIOUSPOST="
&gt; When I hear about a simple solution outdoing a standard solution, I
&gt; don't immediately get suspicious and assume it's too good to be true and
&gt; try to disprove it. For some circumstances, the simple approach might be
&gt; just perfect. I like it when it works out. Of course, when my money is
&gt; on the line I consider it very carefully. But when it's a story with an
&gt; outcome I like, well, what's the harm in basking in it awhile?
">

What's the harm in believing a lie?  Do you work for the Bush
administration?

When someone offers a simple solution outperforming a standard solution,
I rarely get &quot;suspicious.&quot;  But I do tend to dive deeper.  To me, saying
that a custom solution crafted for a specific problem can outperform
something that's more generic isn't news.  It's simple reality and it
doesn't ruffle my feathers at all.

But it's also not the full story.  Crafting a custom solution takes
time, and few people here seem to ask the question, &quot;is it worth the
time it takes?&quot;  The answer is of course, sometimes yes, and sometimes
no.  And if you think about it some more, you'll probably be able to see
the edges and know when it is justified and when it isn't.

What bothers me here is that such things are seldom if ever discussed.
And for me, really understanding something comes from finding the edges
and asking questions like, &quot;when is this technique justified&quot; and &quot;are
there situations where this fails.&quot;

If you've been following the Pattern Language people, you probably know
that they don't just list their design patterns and expect people to
blindly follow them.  Patterns typically include sections that describe
the context they provide a solution for (instead of universal statements
that the pattern is always valid).  And perhaps more importantly,
patterns typically include sections that describe when the pattern isn't
recommended.

Think about that the next time you read here in comp.lang.forth offers
some terse statement about what others should do.  Ask yourself &quot;what is
the context this advice is offered in&quot; and &quot;when does this advice fail.&quot;
If more people did that here in comp.lang.forth, it would probably do
far more for the Forth language than anything else.

<QUOTE PREVIOUSPOST="
&gt;&gt; the perceived clout they have, their opinions influence others.  The
&gt;&gt; end result is that the Forth community has largely internalized the
&gt;&gt; notion that &quot;libraries are bad,&quot; supplemented with the usual array of
&gt;&gt; pejorative, sour-grapes statements to go to justify it.

&gt; If that level of antagonism is important to you, how come you say
&gt; managers don't discourage Forth?
">

Again, most managers have never heard of Forth, don't understand it, and
unless they are presented with compelling arguments for moving to
something they have no knowledge of, will likely choose something
familiar.  Most managers are going to be Forth-neutral.  That's not
anything like the antagonism seen against libraries by (some) Forthers.
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-16T02:47:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; Jonah Thomas wrote:
&gt;&gt; Well, if what you need is a webserver component you can add to a Forth
&gt;&gt; system, Apache is overkill.

&gt; I have an exercise for you-- and for anyone else who thinks what you
&gt; wrote is categorically true.  I want you to go to the online Apache
&gt; documentation, and I want you to look through both the raw, unextended
&gt; services it provides and the additional services it provides in the core
&gt; modules.

&gt; What I want you to do is to page through the section on configuration
&gt; and just skim.  You don't have to read everything and you don't have to
&gt; understand it all.  But what you should do is make a mental note about
&gt; the kinds of functionality Apache provides.  Take a look also at the
&gt; performance-related configuration variables and again, you don't have to
&gt; understand what everything does, but stop for a moment and think about
&gt; why those configuration variables exist.

&gt; When you're done (it shouldn't take more than about 20 minutes of
&gt; careful skimming), I'd like you to come back here to comp.lang.forth and
&gt; tell me that you still think Apache is overkill.

&gt; I'll fearlessly predict what will happen.  You'll first learn how to
&gt; qualify your statements.  Instead of saying Apache is overkill, you'll
&gt; likely quickly come to an understanding that there are classes of
&gt; applications where a small in-application web server couldn't possibly
&gt; cut it.  And you'll learn that yes, there are classes of applications
&gt; where Apache is overkill.  But you apparently don't appreciate the
&gt; difference yet.
">

We use Apache for FORTH, Inc.'s web site.  It's a very good program.  We
never really considered a Forth solution for that.  But the issue is
when a general, fairly complete solution is or is not necessary and
appropriate for an embedded application.  Apache, with all its goodness,
is pretty big, and expects OS services which are even bigger and more
complex.  We provide specific web services for some embedded apps, and
found it much easier to write the subset of functionality we needed than
to figure out how to shoehorn Apache into the resources available to us,
and provide an interface to it (not to mention the issue of per unit
costs to our customer for bigger products).  And we did study for a
while before reaching that conclusion.

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-16T03:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Elizabeth D Rather wrote:
&gt; We use Apache for FORTH, Inc.'s web site.  It's a very good program.  We
&gt; never really considered a Forth solution for that.  But the issue is
&gt; when a general, fairly complete solution is or is not necessary and
&gt; appropriate for an embedded application.
">

That may be your issue, but in this thread, we're not just discussing
embedded systems (note the subject line and past conversation in this
thread).

I bring up Apache not out of any deep love for it-- in the embedded
system we've now completing, we didn't use Apache because it would be
grotesque overkill.  We instead used Xavante, which is written in Lua
and is much lighter-weight.  I bring up Apache mostly because what
seeded this conversation was a poster noting Bernd's webserver code and
saying &quot;gosh, why would anyone use Apache when we have this?&quot;

I wish people could get past the specific examples given and abstract to
the larger questions being raised.  The real question here is when is it
appropriate to build from scratch and when is it better to reuse
existing code.  I've been making what I would hope would be an entirely
uncontroversial statement:  That there is no general answer-- that in
order to answer that question with any intelligence, you have to start
with project requirements and a consideration of where effort is best
spent.  That is, you have to answer the question by asking questions, or
at the very least you have to be able to see the edges between the two
and use your intuition and experience to make the decision.

I consider that uncontroversial.  But when the discussion comes up in
comp.lang.forth, thoughtful reflection seems to rub people the wrong
way.  To ask the question is to fly in the face of Forth dogma and
romanticized ideals-- that it's *always* better to build from scratch,
and that reuse of code (which dives into the parallel discussion about
libraries) is bad.

Another idea that I think is uncontroversial is that some people here
freely consider the costs of one approach (for libraries it might be
licensing, size, speed, and complexity), but they don't consider the
costs of the alternative Forth solution (for building from scratch the
time taken to design, code, and test that code).  You see this when
people say &quot;using X would mean $10 in licensing costs, 4 times bigger
code, and much greater complexity, so we should build it ourselves in
Forth.&quot;

&gt; Apache, with all its goodness,

<QUOTE PREVIOUSPOST="
&gt; is pretty big, and expects OS services which are even bigger and more
&gt; complex.  We provide specific web services for some embedded apps, and
&gt; found it much easier to write the subset of functionality we needed than
&gt; to figure out how to shoehorn Apache into the resources available to us,
&gt; and provide an interface to it (not to mention the issue of per unit
&gt; costs to our customer for bigger products).  And we did study for a
&gt; while before reaching that conclusion.
">

Did that study look at webservers other than Apache?  I assume you
realize there are many others out there, including those designed to be
used inside embedded systems.

Did you also look into building Forth into the webserver?  There are
modules (like mod_perl, mod_python, mod_ruby, etc.) that build those
respective languages into the webserver, allowing it to have dynamic
content driven by code in those languages.  Nothing would prevent
someone from doing the same for Forth and getting the same benefits
users of those other languages have.

I assume that since you used the phrase &quot;web services&quot; that the embedded
webserver you looked at wasn't serving just static pages, but something
driven by Forth code (perhaps using templating or other techniques).  Is
this the case?

My point in asking these questions isn't to suggest your study's
conclusion was wrong.  My point is to find the edges of your study so
that the peanut gallery here who hangs off the advice of experts can
understand the limits of what that study looked into.
</POST>
<POST>
<POSTER> Bernd Paysan &lt;bernd.pay...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-08-16T04:02:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Elizabeth D Rather wrote:
&gt; Well, the &quot;Forth, Inc. bubble&quot; is a pretty large one, with several
&gt; thousand users and mechanisms (mostly email lists augmented by a
&gt; searchable database of past emails) for communicating and sharing code.
&gt;   We include quite a bit of &quot;toolbelt&quot; code with our products, and I'm
&gt; sure MPE does, too.  Wil Baden published his fairly extensive toolbelt.
">

And most other Forth systems that have been maintained for a longer period
of time come with quite a lot of tools, as well. When I program Forth
applications, I use the code I've written in the last 20 years. And you get
that code when you download bigFORTH.

--
Bernd Paysan
&quot;If you want it done right, you have to do it yourself&quot;
http://www.jwdt.com/~paysan/
</POST>
<POST>
<POSTER> John Passaniti &lt;put-my-first-name-h...@JapanIsShinto.com&gt; </POSTER>
<POSTDATE> 2007-08-16T05:19:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan wrote:
&gt; Elizabeth D Rather wrote:
&gt;&gt; Well, the &quot;Forth, Inc. bubble&quot; is a pretty large one, with several
&gt;&gt; thousand users and mechanisms (mostly email lists augmented by a
&gt;&gt; searchable database of past emails) for communicating and sharing code.
&gt;&gt;   We include quite a bit of &quot;toolbelt&quot; code with our products, and I'm
&gt;&gt; sure MPE does, too.  Wil Baden published his fairly extensive toolbelt.

&gt; And most other Forth systems that have been maintained for a longer period
&gt; of time come with quite a lot of tools, as well. When I program Forth
&gt; applications, I use the code I've written in the last 20 years. And you get
&gt; that code when you download bigFORTH.
">

You're both proving my point.

I am saying that implementing low-level code (what I call &quot;jellybean&quot;)
is a no-brainer to you and Elizabeth because you have years of past code
to draw on.  But new Forthers and those who haven't had enough
experience to build a toolbelt are in a different boat.  For them, the
cost of reimplementing the jellybean code is much greater.  They don't
have a legacy of code to reuse, and the Forth community doesn't have
much in the way of significant code that can be reused.

This is a discussion about the economics of writing code verses code
reuse.  The economics are quite different for those who have legacy and
resources than for those who don't.
</POST>
<POST>
<POSTER> stephen...@mpeforth.com (Stephen Pelc) </POSTER>
<POSTDATE> 2007-08-16T05:14:00 </POSTDATE>
On Wed, 15 Aug 2007 22:54:45 GMT, John Passaniti

<QUOTE PREVIOUSPOST="
&lt;n ... @JapanIsShinto.com&gt; wrote:
&gt;So what that means in a practical sense is that while the Forther who
&gt;thought they needed to reimplement a HTTP server was taking the first
&gt;yawn reading the relevant RFC's, we were working on the higher-level
&gt;code that made our user interface unique.  While the Forther who wanted
&gt;to rewrite a FAT driver was on the second round of testing with some USB
&gt;  memory devices they got at the store, we were working on the data
&gt;formats we would write to the device.
">

We've been using our PowerNet stack for over 10 years. Our file
system has been around for some time, and so on. Your issues are
with open source Forth libraries, not with availability.

<QUOTE PREVIOUSPOST="
&gt;To me, if you had to isolate the single biggest problem the Forth
&gt;community has, it's a prevailing attitude that unless you write every
&gt;last byte of code in a system, then you're doing something wrong.  It's
&gt;an attitude that might have served the embedded folk well in the past,
&gt;but increasingly it's counterproductive.  And of course, it makes no
&gt;sense in domains (like web applications) where the value doesn't come
&gt;from the low-level services (like HTTP servers) but in the high-level
&gt;application.
">

I'm inclined to agree. A well written library is a thing of wonder.
Our new engineer finished an Ethernet driver recently and had the
full PowerNet running five minutes later. I'll add that MPE finds
it frustrating that few in the Forth community take code reuse
seriously.

Stephen

--
Stephen Pelc, stephen ... @mpeforth.com
MicroProcessor Engineering Ltd - More Real, Less Time
133 Hill Lane, Southampton SO15 5AF, England
tel: +44 (0)23 8063 1441, fax: +44 (0)23 8033 9691
web: http://www.mpeforth.com - free VFX Forth downloads
</POST>
<POST>
<POSTER> stephen...@mpeforth.com (Stephen Pelc) </POSTER>
<POSTDATE> 2007-08-16T05:27:00 </POSTDATE>
On Wed, 15 Aug 2007 23:20:26 GMT, John Passaniti

<QUOTE PREVIOUSPOST="
&lt;n ... @JapanIsShinto.com&gt; wrote:
&gt;Are those source code libraries part of any public distribution of code?
&gt;If not, you're part of the problem.  I'm not suggesting that you
&gt;should turn MPE into a total open source company.
">

We're not an open source company. However, that appears to be
the core of your complaint, not just from this post but from
others.

The other side of that coin is that MPE *buys* library code
from third parties.

Stephen

--
Stephen Pelc, stephen ... @mpeforth.com
MicroProcessor Engineering Ltd - More Real, Less Time
133 Hill Lane, Southampton SO15 5AF, England
tel: +44 (0)23 8063 1441, fax: +44 (0)23 8033 9691
web: http://www.mpeforth.com - free VFX Forth downloads
</POST>
<POST>
<POSTER> Bernd Paysan &lt;bernd.pay...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-08-16T07:45:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; You're both proving my point.

&gt; I am saying that implementing low-level code (what I call &quot;jellybean&quot;)
&gt; is a no-brainer to you and Elizabeth because you have years of past code
&gt; to draw on.  But new Forthers and those who haven't had enough
&gt; experience to build a toolbelt are in a different boat.
">

But they can download my code! I'm an open source developer, my &quot;jellybean&quot;
*is* available! Your point is moot.

They can also buy Forth Inc.'s or MPE's offering, to get to their jellybean
(which is a different set of stuff than mine, e.g. you can't buy something
like MINOS from MPE).

--
Bernd Paysan
&quot;If you want it done right, you have to do it yourself&quot;
http://www.jwdt.com/~paysan/
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-16T14:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Bernd Paysan wrote:
&gt; John Passaniti wrote:
&gt;&gt; You're both proving my point.

&gt;&gt; I am saying that implementing low-level code (what I call &quot;jellybean&quot;)
&gt;&gt; is a no-brainer to you and Elizabeth because you have years of past code
&gt;&gt; to draw on.  But new Forthers and those who haven't had enough
&gt;&gt; experience to build a toolbelt are in a different boat.

&gt; But they can download my code! I'm an open source developer, my &quot;jellybean&quot;
&gt; *is* available! Your point is moot.

&gt; They can also buy Forth Inc.'s or MPE's offering, to get to their jellybean
&gt; (which is a different set of stuff than mine, e.g. you can't buy something
&gt; like MINOS from MPE).
">

Exactly.  No Forth programmer has to start from the basics of ANS Forth.
There's a rich variety of implementations to choose from, each of
which includes libraries and user communities.  One has only to look at
the various offerings and decide whose &quot;jellybeans&quot; are most relevant to
the project at hand.

Nor does this approach &quot;lock you in&quot; to a particular implementation.
It's clear which features are standard and which are not, and usually a
simple prologue is sufficient to enable portability to another
implementation if that's desirable.

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> John Doty &lt;j...@whispertel.LoseTheH.net&gt; </POSTER>
<POSTDATE> 2007-08-16T14:53:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; Elizabeth D Rather wrote:
&gt;&gt; Well, after 30+ years involved in Forth projects, I can't recall any
&gt;&gt; of our folks spending time &quot;reimplementing jellybean code and common
&gt;&gt; utilities&quot;.

&gt; Of course not.  You live in the Forth, Inc. bubble where you have at
&gt; your disposal 30+ years of code you can reuse, rework, or just inspect
&gt; for inspiration or design experience.

&gt; Take yourself outside that bubble and put yourself in the shoes of a
&gt; &quot;lone wolf&quot; Forth programmer who is proficient with the language, but
&gt; hasn't had the 30+ years of practical experience and building up of a
&gt; personal tool belt.

&gt; For those far more typical users of Forth, they are forced to
&gt; reimplement code that other programmers using other programming
&gt; languages and environments take for granted.  Much has been written
&gt; about the productivity of Forth, but even if you're many times more
&gt; productive than other programmers, the Forth programmer is still saddled
&gt; with doing more work *before* they even get to the &quot;glory&quot; portion of
&gt; the application.

&gt;&gt; But, on the whole, at least on PCs, we use what's there.  Our main
&gt;&gt; line of work is embedded systems, where virtually every project is
&gt;&gt; custom from top to bottom, where every byte and cycle counts, and
&gt;&gt; where there are no available libraries to do most of what needs doing.

&gt; A funny thing happened on the way to 2007.

&gt; I'm sitting next to a project we're just finishing up.  It's an embedded
&gt; system that combines some very sophisticated and unique work.  There is
&gt; no library that implements the core algorithms, no &quot;cookbook&quot; that could
&gt; be applied to what it does.  Significant effort went into performance
&gt; and size.

&gt; But the same project also has elements that are jellybean.  For
&gt; starters, it can receive firmware updates from USB memory devices.  So
&gt; that means in addition to every unique thing it does, it *also* has to
&gt; do some pretty mundane things.  It needs to deal with USB.  It needs to
&gt; read data from a FAT filesystem.  It needs to be able to manipulate that
&gt; filesystem and leave files behind.

&gt; The same project also has a web-based user interface.  So again in
&gt; addition to the unique parts of the system, it also has to serve content
&gt; over HTTP, has to support AJAX, and so on.  At the same time, it *also*
&gt; has to do some very unique things and to present a reasonable
&gt; programmer's interface to what is controls.

&gt; So when you look at this kind of project, you see something I think is
&gt; increasingly common:  You see elements of the system that are mundane
&gt; and common-- elements to provide a standards-based connectivity to other
&gt; systems (such as networking) and hardware (such as portable memory
&gt; devices), elements to bring friendly user control based on familiar
&gt; interfaces (such as web browsers), and so on.  At the same time, these
&gt; modern embedded systems *also* still continue doing what they do best--
&gt; unique, application-specific systems that do things that require
&gt; consideration of performance and size and cost.

&gt; So when you look at modern embedded systems that combine elements of
&gt; both the mundane and the unique, a question comes up:  Where should you
&gt; be putting your effort?  In our case, we recognized that the value we as
&gt; a company could bring to this system wasn't in reimplementing yet
&gt; another FAT file system driver, wasting time creating yet another HTTP
&gt; server, or developing unique new communication protocols.  Instead, we
&gt; spent effort on the algorithms that write the data to the FAT file
&gt; system, writing the higher-level abstractions on top of the HTTP server,
&gt; and developing the core algorithms instead of goofing around creating
&gt; new proprietary communications protocols.

&gt; So what that means in a practical sense is that while the Forther who
&gt; thought they needed to reimplement a HTTP server was taking the first
&gt; yawn reading the relevant RFC's, we were working on the higher-level
&gt; code that made our user interface unique.  While the Forther who wanted
&gt; to rewrite a FAT driver was on the second round of testing with some USB
&gt;  memory devices they got at the store, we were working on the data
&gt; formats we would write to the device.

&gt; To me, if you had to isolate the single biggest problem the Forth
&gt; community has, it's a prevailing attitude that unless you write every
&gt; last byte of code in a system, then you're doing something wrong.  It's
&gt; an attitude that might have served the embedded folk well in the past,
&gt; but increasingly it's counterproductive.  And of course, it makes no
&gt; sense in domains (like web applications) where the value doesn't come
&gt; from the low-level services (like HTTP servers) but in the high-level
&gt; application.
">

Well said! For simple jobs, Forth keeps them simple (and the LSE dialect
is better at this than Standard Forth ;-)). For complex jobs, various
people will have published various relevant pieces. So, choose an
environment that facilitates plumbing them together, and proceed. A
Forth designed to play nice inside such an environment makes a handy
component. But know your requirements and choose appropriate means.

--
John Doty, Noqsi Aerospace, Ltd.
http://www.noqsi.com/
--
Specialization is for robots.
</POST>
<POST>
<POSTER> Elizabeth D Rather &lt;erather...@forth.com&gt; </POSTER>
<POSTDATE> 2007-08-16T15:02:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti wrote:
&gt; Elizabeth D Rather wrote:
&gt;&gt; We use Apache for FORTH, Inc.'s web site.  It's a very good program.
&gt;&gt; We never really considered a Forth solution for that.  But the issue
&gt;&gt; is when a general, fairly complete solution is or is not necessary and
&gt;&gt; appropriate for an embedded application.

&gt; That may be your issue, but in this thread, we're not just discussing
&gt; embedded systems (note the subject line and past conversation in this
&gt; thread).
&gt; ...

&gt; I wish people could get past the specific examples given and abstract to
&gt; the larger questions being raised.  The real question here is when is it
&gt; appropriate to build from scratch and when is it better to reuse
&gt; existing code.  I've been making what I would hope would be an entirely
&gt; uncontroversial statement:  That there is no general answer-- that in
&gt; order to answer that question with any intelligence, you have to start
&gt; with project requirements and a consideration of where effort is best
&gt; spent.  That is, you have to answer the question by asking questions, or
&gt; at the very least you have to be able to see the edges between the two
&gt; and use your intuition and experience to make the decision.
">

Yes, I agree with your concern to focus on the general issue, which is
why I brought up embedded systems.  And I also agree with your
&quot;uncontroversial statement&quot;.

<QUOTE PREVIOUSPOST="
&gt; I consider that uncontroversial.  But when the discussion comes up in
&gt; comp.lang.forth, thoughtful reflection seems to rub people the wrong
&gt; way.  To ask the question is to fly in the face of Forth dogma and
&gt; romanticized ideals-- that it's *always* better to build from scratch,
&gt; and that reuse of code (which dives into the parallel discussion about
&gt; libraries) is bad.
">

I'm not really sure folks here are as absolutist and dogmatic as you
think.  The people who have practical, professional problems to solve
are pretty pragmatic about cost/benefit tradeoffs and will certainly use
pre-existing code when it makes sense.  But there's also a community of
folks here for whom Forth is more of an intellectual exercise.  For
them, there's a subjective value in doing it from scratch just as one
might walk to the store for exercise rather than take the bus.

...

<QUOTE PREVIOUSPOST="
&gt;  &gt; Apache, with all its goodness,
&gt;&gt; is pretty big, and expects OS services which are even bigger and more
&gt;&gt; complex.  We provide specific web services for some embedded apps, and
&gt;&gt; found it much easier to write the subset of functionality we needed
&gt;&gt; than to figure out how to shoehorn Apache into the resources available
&gt;&gt; to us, and provide an interface to it (not to mention the issue of per
&gt;&gt; unit costs to our customer for bigger products).  And we did study for
&gt;&gt; a while before reaching that conclusion.

&gt; Did that study look at webservers other than Apache?  I assume you
&gt; realize there are many others out there, including those designed to be
&gt; used inside embedded systems.
">

Yes, we looked at several approaches.  Most had costs in complexity,
size, and interfacing issues that made our approach more practical and
cost-effective.

<QUOTE PREVIOUSPOST="
&gt; Did you also look into building Forth into the webserver?  There are
&gt; modules (like mod_perl, mod_python, mod_ruby, etc.) that build those
&gt; respective languages into the webserver, allowing it to have dynamic
&gt; content driven by code in those languages.  Nothing would prevent
&gt; someone from doing the same for Forth and getting the same benefits
&gt; users of those other languages have.

&gt; I assume that since you used the phrase &quot;web services&quot; that the embedded
&gt; webserver you looked at wasn't serving just static pages, but something
&gt; driven by Forth code (perhaps using templating or other techniques).  Is
&gt; this the case?
">

The needs in this case were pretty limited and specific.  The embedded
system was primarily doing data acquisition, supplying data to a host
and getting configuration info from it.  A small subset of the protocol
was all that was needed.

<QUOTE PREVIOUSPOST="
&gt; My point in asking these questions isn't to suggest your study's
&gt; conclusion was wrong.  My point is to find the edges of your study so
&gt; that the peanut gallery here who hangs off the advice of experts can
&gt; understand the limits of what that study looked into.
">

We would never claim that what we implemented was a complete web server
or a general solution to any problem, but it did contain some code that
will be very easy to reuse for similar projects in the future.

Cheers,
Elizabeth

--
==================================================
Elizabeth D. Rather   (US &amp; Canada)   800-55-FORTH
FORTH Inc.                         +1 310-491-3356
5155 W. Rosecrans Ave. #1018  Fax: +1 310-978-9454
Hawthorne, CA 90250
http://www.forth.com

&quot;Forth-based products and Services for real-time
applications since 1973.&quot;
==================================================
</POST>
<POST>
<POSTER> Jonah Thomas &lt;j2tho...@cavtel.net&gt; </POSTER>
<POSTDATE> 2007-08-17T09:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Passaniti &lt;put-my-first-name-h ... @JapanIsShinto.com&gt; wrote:
&gt; Jonah Thomas wrote:
&gt; &gt; Well, if what you need is a webserver component you can add to a
&gt; &gt; Forth system, Apache is overkill.

&gt; I want you to go to the online Apache
&gt; documentation, and I want you to look through both the raw, unextended

&gt; services it provides and the additional services it provides in the
&gt; core modules. [....]
&gt; What I want you to do is to page through the section on configuration
&gt; and just skim. [....]
&gt; When you're done (it shouldn't take more than about 20 minutes of
&gt; careful skimming), I'd like you to come back here to comp.lang.forth
&gt; and tell me that you still think Apache is overkill.

&gt; I'll fearlessly predict what will happen.  You'll first learn how to
&gt; qualify your statements.  Instead of saying Apache is overkill, you'll

&gt; likely quickly come to an understanding that there are classes of
&gt; applications where a small in-application web server couldn't possibly

&gt; cut it.  And you'll learn that yes, there are classes of applications
&gt; where Apache is overkill.  But you apparently don't appreciate the
&gt; difference yet.
">

I've done that now. I tend toward the idea that the classes of
applications for which Apache is not overkill are likely not best done
in Forth.

<QUOTE PREVIOUSPOST="
&gt; Another thing it's possible you'll learn is that web applications can
&gt; involve a number of services that aren't necessarily obvious.  For
&gt; example, one very common thing to do with embedded webservers is to
&gt; present a web-based user interface to configure the system.  But since

&gt; normal HTTP traffic is sent in the clear, it's dangerous to put such a

&gt; device on a public network.  You'll want to encrypt communications
&gt; with SSL, and there is a of lot of detail there.
">

I'm interested in minimalism. I don't claim that minimal solutions are
always best. Not always the cheapest, not always the quickest to
produce, and for some purposes they can't do enough. But it's something
I'm interested in. It's one of Forth's ecological niches. If you want
minimalism Forth can provide it easier than lots of things, though Forth
systems aren't limited to that. There are various circumstances where
minimalist approaches are good, and I tend to think that the industry is
doing less of that than it ought to. So, if you use a lot of Apache
functions you have given up minimalism. I counted 70 Apache directives
that start with the letter A. Presumably you can get it working with a
small fraction of directives and add more as you need them. But....

If you already have SSL for some other purpose, it makes perfect sense
to use it for the configuration interface. If you don't already have it
some other approach might be better. Maybe something that uses things
you do already have.

<QUOTE PREVIOUSPOST="
&gt; The stock answer is that &quot;it's just a few more lines of code.&quot;  Maybe.

&gt; But to write the code, you have to understand the standards (and
&gt; often, the deviations from the standards).  And you then need to
&gt; design it. And then you code it.  And then you test it.  And all the
&gt; while that you're doing this, YOU AREN'T WRITING A LINE OF APPLICATION
&gt; CODE. You're working on the plumbing.
">

Yes. So, let's review the bidding. If you have an application that's
written in Forth and it benefits from a simple webserver, you can do
that easily in Forth just as you can in many other languages. If you
need a complex webserver that fits multiple standards and also fits the
deviations major webbrowsers make from those standards -- then I don't
think we're in Kansas anymore, Toto. You could do that in Forth just as
you could in many general-purposes languages, but do you want to be a
competitor in the full-service webserver market? If that fits your
business plan then go for it, but it isn't going to be simple.

If you're trying for minimalism (which not all Forth users do, and not
all Forth users ought to do) then it makes sense to reinvent wheels
whenever you need a particular sort of wheel. It does not make sense to
redesign the HumV transmission to government specs. If you have to fit a
very complex specification in precisely the way that foreign complex
parts demand, there isn't a lot of room for minimalism. You're probably
locked out of that market, unless you get invited in. &quot;Redesign the
wheel, not the transmission.&quot;

<QUOTE PREVIOUSPOST="
&gt; THAT is why people use webservers such as Apache.  Apache isn't some
&gt; penultimate thing of perfect beauty.  It's quite ugly in places.  But
&gt; Apache isn't just a sequence of bytes spinning on a hard drive.  It's
&gt; the experience of hundreds of contributors.  It's years of testing.
&gt; It's years of performance tuning.  It's years of security analysis.
&gt; It's not perfect, but it's got a hell of a lot more thought in it than

&gt; an ad-hoc webserver hacked in Forth.
">

Sure. I'm thinking that if you need that sort of thing then you aren't
playing to Forth's strengths. Forth is strongest when the job is to cut
out things that aren't necessary and do the work simpler. You can use
Forth for practically anything -- it's a general-purpose programming
language -- but for a lot of purposes Forth is just another language,
and something else might be better. When you get to do the whole thing
in Forth you can redesign interfaces when that makes sense. When you do
one piece in Forth and use other pieces OTS where you have to fit their
interfaces, that's fine when their interfaces are well-designed and the
other components work as you need them to. If you have to cobble
together a bunch of things that don't quite fit your needs, Forth might
be a good glue, or maybe something else would be better.

<QUOTE PREVIOUSPOST="
&gt; &gt; It looks to me like the central goodness of Bernd's component is
&gt; &gt; that it gives the core functionality in a way that can be added to
&gt; &gt; many Forths.

&gt; Sort of.  In it's present form, the Forth must be hosted on a Unix or
&gt; Unix-like operating system that offers inetd.  So, it won't be of help

&gt; under Windows (without yet more layers of software like Cygwin).  It
&gt; would certainly be possible to remove that dependency and have the
&gt; webserver code directly work with sockets.  But that, again, is
&gt; non-zero time spent on a trivial part of the application when that
&gt; same time could be spent on far more interesting places.
">

Note that Marcel has done just that. He has a socket toolset that can be
modified to fit practically any Windows or Linux Forth. And that gives
him a simple webserver, a simple email reader and writer, a simple
Usenet newsreader, etc. I'd like to think that it would be less work to
fit his sockets package to a Forth than to interface that Forth to
Apache. Of course you don't get as much, but what you get is all in
Forth which is one potential advantage. Not as nice when the time is
spent on a trivial part of one application, which fits your point that
libraries can be a very good thing.

<QUOTE PREVIOUSPOST="
&gt; &gt; I want to believe in it, so when I hear about simple Forth solutions
&gt; &gt; replacing complex mundane solutions, I like it. I want it to be
&gt; &gt; true. And sometimes it is true.

&gt; And sometimes it isn't.
">

Sure. Sometimes it's faster and cheaper to fit giant components together
and get simple jobs done. Particularly when the big components fit
together well. Sometimes the complications build on themselves and the
product gets more and more brittle. Experts who can do that sort of
thing well are obviously quite valuable, since so many people do it
badly. Experts who can build minimal systems well are also valuable
since many people would do that badly too.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; I look back at what I was doing in the 80's and it's true-- I had much

&gt; more control over the hardware and it was both powerful and
&gt; empowering.
&gt;   I knew how my systems worked from the highest level of the
&gt;   application
&gt; down to the transistor level.

&gt; But let's look at the negatives.  Because I designed the hardware and
&gt; software, the limits of my experience and my prejudices got in the
&gt; way.
&gt;   If I didn't understand something, I either had to spend the time to
&gt; understand that (delaying me) or I had to find a different solution
&gt; (potentially less elegant).

&gt; I look at the work I'm doing now, and while I lament that I sometimes
&gt; have less control over the hardware and less deep understanding of
&gt; parts of the software (such as when under an operating system), I look
&gt; at the scope of the work I'm doing now and it blows me away.  Being
&gt; part of a group where we can not only concentrate on what we're best
&gt; at but also collaborate and share ideas has allowed me to work on
&gt; projects that would have been far outside the scope of what I could do
&gt; alone.  And I'm getting unexpected benefits too-- fresh perspectives
&gt; that challenge my views.  New ideas that I wouldn't have ever come up
&gt; with myself.
">

My prejudice is that complex applications that no one really understands
in detail can be dangerous. It might be better to avoid them. But in
practice I use a complex webbrowser, and when it crashes I just start it
up again. I use various complex products and hope they work.

Sure, it's a sort of romanticism. There's a place for that. People who
keep up old methods from nostalgia or romanticism or whatever and who
look for places they might work, are maintaining tools that might
actually be useful for some things. Maintain diversity both by trying
new stuff and by keeping the old stuff.

I like getting fresh perspectives. I'd be interested in hearing about
some that could be imported into Forth.

<QUOTE PREVIOUSPOST="
&gt; When someone offers a simple solution outperforming a standard
&gt; solution, I rarely get &quot;suspicious.&quot;  But I do tend to dive deeper.
&gt; To me, saying that a custom solution crafted for a specific problem
&gt; can outperform something that's more generic isn't news.  It's simple
&gt; reality and it doesn't ruffle my feathers at all.
">

Custom solutions from scratch are inevitably expensive, unless the goals
are minimal. But standard solutions tend to keep building on ...
read more »
</POST>
<POST>
<POSTER> m...@iae.nl (Marcel Hendrix) </POSTER>
<POSTDATE> 2007-08-17T13:46:00 </POSTDATE>
Jonah Thomas &lt;j2tho ... @cavtel.net&gt; wrote Re: gforth webserver, why isn't forth used all over ecommerce?
[..]

<QUOTE PREVIOUSPOST="
&gt;&gt;                                                                   It
&gt;&gt; would certainly be possible to remove that dependency and have the
&gt;&gt; webserver code directly work with sockets.  But that, again, is
&gt;&gt; non-zero time spent on a trivial part of the application when that
&gt;&gt; same time could be spent on far more interesting places.
&gt; Note that Marcel has done just that. He has a socket toolset that can be
&gt; modified to fit practically any Windows or Linux Forth. And that gives
&gt; him a simple webserver, a simple email reader and writer, a simple
&gt; Usenet newsreader, etc.
">

Not a webserver, Bernd's code needs Cygwin (which I have, but am
hesitant to configure for this kind of thing), so I am still waiting
for somebody's three line Windows-also code.

OTOH, the toolkit also includes a telnet interface and both RSS and IRC
clients with almost unbeatably low LOCs ;-)

People with real newsreaders may have noticed from headers that I have
been using a not-so-simple Forth news and email program since 2002.

<QUOTE PREVIOUSPOST="
&gt;                         I'd like to think that it would be less work to
&gt; fit his sockets package to a Forth than to interface that Forth to
&gt; Apache.
">

I won't hesitate to interface to Apache when the need arises. But for many
things it apparently doesn't. And until then, I figure it can't hurt to
know how things work.

-marcel
</POST>
<POST>
<POSTER> Bernd Paysan &lt;bernd.pay...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-08-15T17:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
sl ... @jedit.org wrote:
&gt; Would you still use Forth in domains where space and performance are
&gt; not necessarily top priorities, and instead, one must interoperate
&gt; with existing infrastructure, some of which may be quite inelegant,
&gt; complex, or plain broken? For example, relational databases, XML, web
&gt; services, COM/ActiveX, .NET applications, 3D graphics with OpenGL,
&gt; etc.
">

Let's go trough, point by point, and give examples of each:

* relational databases -&gt; I've written a 200 lines PostgreSQL interface.
Would be even less if I repeated the PHP mistake to just give the query
string to PostgreSQL.
* XML: Jenny Brian had a talk at an EuroForth about it, it was not much
code, and quite elegant. The idea is that each XML token is a Forth word.
* web services: Don't know.
* COM/ActiveX: Egmont Woizel has done quite some work in that direction with
his comForth 4.
* .NET: There's a Forth from Microsoft for .NET, it's one of the examples,
and probably quite ideosyncratic (never tried it).
* 3D graphics with OpenGL: I've done a 3D-turtle in bigFORTH, and written
some example code like an animated swap dragon or a chrismas tree.

--
Bernd Paysan
&quot;If you want it done right, you have to do it yourself&quot;
http://www.jwdt.com/~paysan/
</POST>
</TEXT>
</BODY>
</DOC>
