<DOC>
<DOCID> eng-NG-31-135591-9755444 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-09-25T09:30:00 </DATETIME>
<BODY>
<HEADLINE>
I love Ruby but what is the deal with... this !
</HEADLINE>
<TEXT>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T09:30:00 </POSTDATE>
I love Ruby but what is the deal with the lack of a VM ?

I love Ruby but what is the deal with the lack of performance ?

Why does FreeBASIC run faster than my lovely Ruby code ?

Why do I have to ship source code with my Ruby app ?

Does this mean I have no choice but to develop Open Source Code
forever using Ruby ?

How will I ever be able to make any money coding Ruby when I have to
ship source code to all my customers ?

Why have all other languages that attempted to be commercial successes
failed because programmers had to ship source code with their apps for
those languages ? (*Check the history of Smalltalk*)

Where the heck is Ruby 1.9.0 for crying out-loud, I mean it's going on
2 years and still no stable Ruby 1.9.0 for me to play with at work !

I want to use Ruby for absolutely everything !

I want Ruby to be the only computer language anyone can legally use in
the USA !

I want to run for congress to get a law passed to make Ruby the
national programming language.

I want all other Moneky Coders like me to have to use the lovely Ruby
code I love to write !

Ruby Rocks !  (*Pass me another Red Bull so I can get back to work
writing more Ruby code !*)
</POST>
<POST>
<POSTER> Gregory Seidman &lt;gsslist+r...@anthropohedron.net&gt; </POSTER>
<POSTDATE> 2007-09-25T09:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, Sep 25, 2007 at 10:35:06PM +0900, Ruby Maniac wrote:
&gt; I love Ruby but what is the deal with the lack of a VM ?
&gt; I love Ruby but what is the deal with the lack of performance ?
&gt; Why does FreeBASIC run faster than my lovely Ruby code ?
">

Ruby is a language written to scratch someone's (Matz) itch. It happens to
be quite nice as a language, but its development isn't driven by corporate
concerns or corporate money.

<QUOTE PREVIOUSPOST="
&gt; Why do I have to ship source code with my Ruby app ?
">

You don't. Check out rubyscript2exe, among other things.

<QUOTE PREVIOUSPOST="
&gt; Does this mean I have no choice but to develop Open Source Code
&gt; forever using Ruby ?
&gt; How will I ever be able to make any money coding Ruby when I have to
&gt; ship source code to all my customers ?
">

Absolutely not. Just because you ship source code doesn't mean that the
code is not protected by copyright laws. Indeed, if not for copyright
protection there would be no such thing as open source licenses, since they
depend upon copyright law protecting the source code. If you wish to
develop an application and make it available under a license that allows
only single use on a single processor machine with less than 1GB of RAM and
only on alternate Tuesdays, you are free to do so and the license (should
anyone enter into such a licensing agreement with you) is enforceable.

<QUOTE PREVIOUSPOST="
&gt; Why have all other languages that attempted to be commercial successes
&gt; failed because programmers had to ship source code with their apps for
&gt; those languages ? (*Check the history of Smalltalk*)
">

Smalltalk may or may not have attempted to be a commercial success. As of
now, Ruby is *not* attempting to become a commercial success, except
insofar as Microsoft is supporting/pushing IronRuby (which does have a VM
since it involves a Ruby to CLR bytecode compiler).

<QUOTE PREVIOUSPOST="
&gt; Where the heck is Ruby 1.9.0 for crying out-loud, I mean it's going on
&gt; 2 years and still no stable Ruby 1.9.0 for me to play with at work !
">

As far as I know, Ruby development is following a versioning scheme similar
to what Linux development used to follow. That is, odd-numbered point
releases are unstable. When it is stable it will be called 2.0 (last I
heard, anyway).

<QUOTE PREVIOUSPOST="
&gt; I want to use Ruby for absolutely everything !
&gt; I want Ruby to be the only computer language anyone can legally use in
&gt; the USA !
&gt; I want to run for congress to get a law passed to make Ruby the
&gt; national programming language.
&gt; I want all other Moneky Coders like me to have to use the lovely Ruby
&gt; code I love to write !
">

If you really mean any of that, you are a fool. Ruby is a single language,
a single tool. It is the right tool for many jobs, but not for all jobs.
Don't limit yourself. If you are unhappy with the state of Ruby right now,
take a break from it and learn some other languages (my suggestions:
Lisp/Scheme, Erlang, Haskell, OCAML, C, C++, C#, PostScript, MIPS assembly,
SPARC assembly, x86 assembly, and not necessarily in that order) to broaden
the set of tools in your toolbox.

<QUOTE PREVIOUSPOST="
&gt; Ruby Rocks !  (*Pass me another Red Bull so I can get back to work
&gt; writing more Ruby code !*)
">

Ruby is the most pleasant language I've ever used. It also has its warts.
Have a little perspective.

--Greg
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T10:05:00 </POSTDATE>
On Sep 25, 6:52 am, Gregory Seidman &lt;gsslist+r ... @anthropohedron.net&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; On Tue, Sep 25, 2007 at 10:35:06PM +0900, Ruby Maniac wrote:
&gt; &gt; I love Ruby but what is the deal with the lack of a VM ?
&gt; &gt; I love Ruby but what is the deal with the lack of performance ?
&gt; &gt; Why does FreeBASIC run faster than my lovely Ruby code ?

&gt; Ruby is a language written to scratch someone's (Matz) itch. It happens to
&gt; be quite nice as a language, but its development isn't driven by corporate
&gt; concerns or corporate money.

&gt; &gt; Why do I have to ship source code with my Ruby app ?

&gt; You don't. Check out rubyscript2exe, among other things.

&gt; &gt; Does this mean I have no choice but to develop Open Source Code
&gt; &gt; forever using Ruby ?
&gt; &gt; How will I ever be able to make any money coding Ruby when I have to
&gt; &gt; ship source code to all my customers ?

&gt; Absolutely not. Just because you ship source code doesn't mean that the
&gt; code is not protected by copyright laws. Indeed, if not for copyright
&gt; protection there would be no such thing as open source licenses, since they
&gt; depend upon copyright law protecting the source code. If you wish to
&gt; develop an application and make it available under a license that allows
&gt; only single use on a single processor machine with less than 1GB of RAM and
&gt; only on alternate Tuesdays, you are free to do so and the license (should
&gt; anyone enter into such a licensing agreement with you) is enforceable.

&gt; &gt; Why have all other languages that attempted to be commercial successes
&gt; &gt; failed because programmers had to ship source code with their apps for
&gt; &gt; those languages ? (*Check the history of Smalltalk*)

&gt; Smalltalk may or may not have attempted to be a commercial success. As of
&gt; now, Ruby is *not* attempting to become a commercial success, except
&gt; insofar as Microsoft is supporting/pushing IronRuby (which does have a VM
&gt; since it involves a Ruby to CLR bytecode compiler).

&gt; &gt; Where the heck is Ruby 1.9.0 for crying out-loud, I mean it's going on
&gt; &gt; 2 years and still no stable Ruby 1.9.0 for me to play with at work !

&gt; As far as I know, Ruby development is following a versioning scheme similar
&gt; to what Linux development used to follow. That is, odd-numbered point
&gt; releases are unstable. When it is stable it will be called 2.0 (last I
&gt; heard, anyway).

&gt; &gt; I want to use Ruby for absolutely everything !
&gt; &gt; I want Ruby to be the only computer language anyone can legally use in
&gt; &gt; the USA !
&gt; &gt; I want to run for congress to get a law passed to make Ruby the
&gt; &gt; national programming language.
&gt; &gt; I want all other Moneky Coders like me to have to use the lovely Ruby
&gt; &gt; code I love to write !

&gt; If you really mean any of that, you are a fool. Ruby is a single language,
&gt; a single tool. It is the right tool for many jobs, but not for all jobs.
&gt; Don't limit yourself. If you are unhappy with the state of Ruby right now,
&gt; take a break from it and learn some other languages (my suggestions:
&gt; Lisp/Scheme, Erlang, Haskell, OCAML, C, C++, C#, PostScript, MIPS assembly,
&gt; SPARC assembly, x86 assembly, and not necessarily in that order) to broaden
&gt; the set of tools in your toolbox.

&gt; &gt; Ruby Rocks !  (*Pass me another Red Bull so I can get back to work
&gt; &gt; writing more Ruby code !*)

&gt; Ruby is the most pleasant language I've ever used. It also has its warts.
&gt; Have a little perspective.

&gt; --Greg
">

I was not able to get rubyscript2exe to work when I gave it a whirl.

Once upon a time, Smalltalk was a commercially successful language
with several public companies selling it but then one day Smalltalk
fell into disrepute and all those public companies ceased to be public
companies and now Smalltalk is largely Open Source and no longer a
commercial success.  One of the problems with Smalltalk was the fact
that source code had to be shipped with Smalltalk apps.

Copyright Laws do NOT protect you from reverse engineering regardless
of what the License Agreement says, reverse engineering is a time
honored art that is fully supported by current copyright laws.

Believe it or not, reverse engineering is a bit easier when you have
full source to play with... I just thought I would toss this out for
all of us to ponder.

Even when rubyscript2exe is successfully used the source code is still
available and must be available or Ruby cannot work.

I love Ruby !  I want this made perfectly clear.

I seriously want Ruby used for every single programming problem known
to mankind and I will hate all those who fail to live up to this
ideal.  Maybe I am just a lazy programmer who doesn't want to learn
any new languages but I love Ruby so much I cannot stand to even be in
the same room with anyone who even mentions any other languages other
than Ruby.

You call me foolish because I use Ruby for everything but I think I am
a genius with a vision.

Recently I was given the task of importing data from one SQL Server
2005 database to another and rather than allow a co-worker use C# to
code a faster way to accomplish this I chose to use Ruby even though
the work took weeks to complete and that Moron who wanted to use C#
might have completed the work in less than a day I know Ruby as a
superior language is well worth the weeks of time my team has invested
in the process or doing a rather simple data import task.  Ruby rocks !
</POST>
<POST>
<POSTER> &quot;Walter Purvis&quot; &lt;wpmailingli...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T11:23:00 </POSTDATE>
Troll.
</POST>
<POST>
<POSTER> &quot;Rob Sanheim&quot; &lt;rsanh...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T12:50:00 </POSTDATE>
Please don't feed the trolls.  Move along...nothing to see here.
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T14:42:00 </POSTDATE>
On Sep 25, 8:23 am, &quot;Walter Purvis&quot; &lt;wpmailingli ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Troll.
">

Do you classify all those who have an opposing viewpoint as being a
&quot;Troll&quot; ?
</POST>
<POST>
<POSTER> Phlip &lt;phlip2...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T15:07:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; Do you classify all those who have an opposing viewpoint as being a
&gt; &quot;Troll&quot; ?
">

Classify someone who writes posts only to stir up trouble as a troll.
Example: Posting &quot;Perl sucks&quot; to a Perl newsgroup. If someone actually
had a valid question, they could phrase it more diplomatically, such
as &quot;Perl has room for improvement&quot;.

So lack of this diplomacy is a very clear indicator someone doesn't
actually care about the answer.

--
Phlip
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T16:55:00 </POSTDATE>
On Sep 25, 12:07 pm, Phlip &lt;phlip2 ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; Do you classify all those who have an opposing viewpoint as being a
&gt; &gt; &quot;Troll&quot; ?

&gt; Classify someone who writes posts only to stir up trouble as a troll.
&gt; Example: Posting &quot;Perl sucks&quot; to a Perl newsgroup. If someone actually
&gt; had a valid question, they could phrase it more diplomatically, such
&gt; as &quot;Perl has room for improvement&quot;.

&gt; So lack of this diplomacy is a very clear indicator someone doesn't
&gt; actually care about the answer.

&gt; --
&gt;  Phlip
">

Well pardon me for causing &quot;trouble&quot; simply by talking about the
inefficiencies of Ruby...  If the Ruby community weren't so sensitive
about this sort of topic we might well have a more powerful (faster,
more efficient) Ruby language to use.  Punishing those who talk about
Ruby's inefficiencies will not resolve those inefficiencies however it
will work to guarantee those sides of Ruby remain ingrained in the
langauge as has been the case for a very long while, it seems.
</POST>
<POST>
<POSTER> Phlip &lt;phlip2...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T17:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; Well pardon me for causing &quot;trouble&quot; simply by talking about the
&gt; inefficiencies of Ruby...  If the Ruby community weren't so sensitive
&gt; about this sort of topic we might well have a more powerful (faster,
&gt; more efficient) Ruby language to use.
">

(Another trolloid technique is frequently returning to appeasement and
abasement, but I'll make one more attempt at rationality here!)

You just said &quot;if the newsgroup weren't so civilized, and demanding of
polite discourse, Ruby might be a better language.&quot;

That's kind'a silly.

--
Phlip
</POST>
<POST>
<POSTER> John Joyce &lt;dangerwillrobinsondan...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T17:40:00 </POSTDATE>
We know how slow it is and whether or not it is important.
We're not really worried about it, but we do look forward to upcoming
speed increases..
What we are generally interested in is doing things and making things
with Ruby :)
Focus on that, and you'll find that Ruby is either good or not for you.
People here generally use other languages as well, and are not Ruby
only people.
We appreciate Ruby because of other languages in many cases.
There is actually a great deal of pragmatism in the Ruby community.
If there is a better approach that is not Ruby we will recommend it
and use it.
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-25T20:14:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ruby Maniac wrote:
&gt; Well pardon me for causing &quot;trouble&quot; simply by talking about the
&gt; inefficiencies of Ruby...  If the Ruby community weren't so sensitive
&gt; about this sort of topic we might well have a more powerful (faster,
&gt; more efficient) Ruby language to use.  Punishing those who talk about
&gt; Ruby's inefficiencies will not resolve those inefficiencies however it
&gt; will work to guarantee those sides of Ruby remain ingrained in the
&gt; langauge as has been the case for a very long while, it seems.
">

First of all, nobody is punishing anyone as far as I can tell. I see
name calling, but nobody has punished anyone yet. Second, a number of
people in the Ruby community, myself among them, *are* working to
improve Ruby performance *and* to promote the concepts of profiling,
load and scalability testing, and software performance engineering. Yes,
we *are* sensitive about it, and we *will* have a more powerful Ruby
language *because* of that sensitivity.

Now if you'd like to help out, email me off list and I'll give you some
pointers on what this performance engineering business is all about. Or,
if you want to help the Python community improve their speed, go over to
their mailing lists and I'm sure someone will hand you some tasks.
</POST>
<POST>
<POSTER> Curt Sampson &lt;c...@cynic.net&gt; </POSTER>
<POSTDATE> 2007-09-25T20:22:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, 25 Sep 2007, Ruby Maniac wrote:
&gt; Once upon a time, Smalltalk was a commercially successful language....
">

Well, that's debatable. It all depends on where you set your bar;
Smalltalk was never all that widely deployed.

If measured by the number of dollars paid to programmers to write code
over any given period of time, I would not be suprised if at this point
Ruby is more &quot;commerically successful&quot; than Smalltalk ever was. It's
important not to forget that a vast amount of programming is done not to
make products which are sold to others but for internal consumption. In
fact, this appeared to me to be the majority of Smalltalk use.

<QUOTE PREVIOUSPOST="
&gt; One of the problems with Smalltalk was the fact that source code had
&gt; to be shipped with Smalltalk apps.
">

Actually, there were several implementations where it didn't; you could
build a system image and just ship that. It was likely more difficult to
reverse engineeer than Java bytecode.

At any rate, you could have a nice argument over whether this was
the biggest problem for commerical Smalltalk development. The vastly
different development and build control environment (particularly that
it was not file-based) could well have contributed more than that.

<QUOTE PREVIOUSPOST="
&gt; Believe it or not, reverse engineering is a bit easier when you have
&gt; full source to play with... I just thought I would toss this out for
&gt; all of us to ponder.
">

No! Say it isn't so! None of us here had ever realized that!

Basically, distributing the source code just isn't that big a problem
for many people, and it seems to include you, or you would be using
another language, wouldn't you?

Every language has its tradeoffs, and if you're not happy with Ruby's,
you'd be far better off either fixing the problems (it is open source,
after all) or finding a language whose tradeoffs more suit you than
by ranting on a mailing list. I can say almost for certain that this
discussion will eat a lot of your time to no good end.

You might keep in mind that most of the Ruby developers are pretty well
aware of the problems with Ruby, and it's not because of their lack of
knowledge of these problems that they're not fixed. I leave it to you as
an exercise to find out why your pet peeves are not yet fixed.

cjs
--
Curt Sampson         &lt;c ... @cynic.net&gt;         +81 90 7737 2974
http://www.starling-software.com
The power of accurate observation is commonly called cynicism
by those who have not got it.    --George Bernard Shaw
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-25T20:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Gregory Seidman wrote:
&gt; Ruby is the most pleasant language I've ever used. It also has its warts.
&gt; Have a little perspective.
">

Most of the warts *I've* seen on Ruby are things it &quot;inherited&quot; from
Perl, like &quot;$_&quot;. :)
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T20:52:00 </POSTDATE>
On Sep 25, 2:08 pm, Phlip &lt;phlip2 ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; Well pardon me for causing &quot;trouble&quot; simply by talking about the
&gt; &gt; inefficiencies of Ruby...  If the Ruby community weren't so sensitive
&gt; &gt; about this sort of topic we might well have a more powerful (faster,
&gt; &gt; more efficient) Ruby language to use.

&gt; (Another trolloid technique is frequently returning to appeasement and
&gt; abasement, but I'll make one more attempt at rationality here!)

&gt; You just said &quot;if the newsgroup weren't so civilized, and demanding of
&gt; polite discourse, Ruby might be a better language.&quot;

&gt; That's kind'a silly.

&gt; --
&gt;  Phlip
">

So who specifically would my remarks be offending, assuming I was
being less than civil in this thread ?
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T20:55:00 </POSTDATE>
On Sep 25, 2:40 pm, John Joyce &lt;dangerwillrobinsondan ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; We know how slow it is and whether or not it is important.
&gt; We're not really worried about it, but we do look forward to upcoming
&gt; speed increases..
&gt; What we are generally interested in is doing things and making things
&gt; with Ruby :)
&gt; Focus on that, and you'll find that Ruby is either good or not for you.
&gt; People here generally use other languages as well, and are not Ruby
&gt; only people.
&gt; We appreciate Ruby because of other languages in many cases.
&gt; There is actually a great deal of pragmatism in the Ruby community.
&gt; If there is a better approach that is not Ruby we will recommend it
&gt; and use it.
">

The feeling that there is only one tool for all tasks generally leads
to the failure to recognize the right tool for the right job.

I have a nice big basket of languages I can draw upon when making
assessments as to which one might be best suited to a particular task
rather than only using one language for everything at the expense of
he who employs me since it can take quite some time to make Ruby work
in place of a better method for coding stored procs such as when SQL
Server 2005 is being used and C# might be a better choice in terms of
runtime performance.
</POST>
<POST>
<POSTER> Ruby Maniac &lt;rubyman...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-25T20:56:00 </POSTDATE>
On Sep 25, 5:34 pm, &quot;M. Edward (Ed) Borasky&quot; &lt;zn ... @cesmail.net&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; Gregory Seidman wrote:
&gt; &gt; Ruby is the most pleasant language I've ever used. It also has its warts.
&gt; &gt; Have a little perspective.

&gt; Most of the warts *I've* seen on Ruby are things it &quot;inherited&quot; from
&gt; Perl, like &quot;$_&quot;. :)
">

Seems to me like Ruby borrowed far more from Smalltalk than Perl and
we know how Smalltalk failed to remain a success in the marketplace.
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-09-25T21:03:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Curt Sampson wrote:
&gt; On Tue, 25 Sep 2007, Ruby Maniac wrote:

&gt;&gt; Once upon a time, Smalltalk was a commercially successful language....

&gt; Well, that's debatable. It all depends on where you set your bar;
&gt; Smalltalk was never all that widely deployed.
">

Once upon a time, there were *two* -- or was it three? -- Lisp machines.
They existed ... they had revenues and users and all that. Once upon a
time, Paul Graham wrote an e-commerce application in Lisp that he sold
to Yahoo, who then re-wrote it in C/C++.

Was Lisp a &quot;commercial success?&quot; Hardly.

<QUOTE PREVIOUSPOST="
&gt; If measured by the number of dollars paid to programmers to write code
&gt; over any given period of time, I would not be suprised if at this point
&gt; Ruby is more &quot;commerically successful&quot; than Smalltalk ever was. It's
&gt; important not to forget that a vast amount of programming is done not to
&gt; make products which are sold to others but for internal consumption. In
&gt; fact, this appeared to me to be the majority of Smalltalk use.
">

I personally think that it is almost always a mistake to do &quot;a vast
amount of programming ... not to make products which are sold to others
but for internal consumption&quot;. Programmers should be paid to produce
software that fills profitable markets, not to do infrastructure
projects that could be done using off-the-shelf software.

I personally think if you need software infrastructure, you should
document your requirements and select a product from one of three (or
more) vendors that can meet them. If there *aren't* three vendors that
can meet them, your requirements need to be re-done.
</POST>
<POST>
<POSTER> Marc Heiler &lt;sheve...@linuxmail.org&gt; </POSTER>
<POSTDATE> 2007-09-25T21:55:00 </POSTDATE>
Ruby Maniac, please stop the ruby-is-slow crusade for a little while.
By now we are really aware of your opinion, and this is now the fourth
starting message about the SAME topic in a short time.
--
Posted via http://www.ruby-forum.com/ .
</POST>
<POST>
<POSTER> Michael Glaesemann &lt;g...@seespotcode.net&gt; </POSTER>
<POSTDATE> 2007-09-25T22:36:00 </POSTDATE>
On Sep 25, 2007, at 20:55 , Marc Heiler wrote:

<QUOTE PREVIOUSPOST="
&gt; Ruby Maniac, please stop the ruby-is-slow crusade for a little while.
">

Marc (and others),

A killfile is a wonderful thing. I haven't seen anything from Ruby
Maniac in a couple of days. I've seen a number of people *complain*
about him, but hopefully that will subside soon enough.

Michael Glaesemann
grzm seespotcode net
</POST>
<POST>
<POSTER> Gregory Seidman &lt;gsslist+r...@anthropohedron.net&gt; </POSTER>
<POSTDATE> 2007-09-26T09:47:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, Sep 26, 2007 at 10:00:03AM +0900, Ruby Maniac wrote:
&gt; On Sep 25, 2:40 pm, John Joyce &lt;dangerwillrobinsondan ... @gmail.com&gt;
&gt; wrote:
&gt; &gt; We know how slow it is and whether or not it is important.
&gt; &gt; We're not really worried about it, but we do look forward to upcoming
&gt; &gt; speed increases..
&gt; &gt; What we are generally interested in is doing things and making things
&gt; &gt; with Ruby :)
&gt; &gt; Focus on that, and you'll find that Ruby is either good or not for you.
&gt; &gt; People here generally use other languages as well, and are not Ruby
&gt; &gt; only people.
&gt; &gt; We appreciate Ruby because of other languages in many cases.
&gt; &gt; There is actually a great deal of pragmatism in the Ruby community.
&gt; &gt; If there is a better approach that is not Ruby we will recommend it
&gt; &gt; and use it.

&gt; The feeling that there is only one tool for all tasks generally leads
&gt; to the failure to recognize the right tool for the right job.

&gt; I have a nice big basket of languages I can draw upon when making
&gt; assessments as to which one might be best suited to a particular task
&gt; rather than only using one language for everything at the expense of
&gt; he who employs me since it can take quite some time to make Ruby work
&gt; in place of a better method for coding stored procs such as when SQL
&gt; Server 2005 is being used and C# might be a better choice in terms of
&gt; runtime performance.
">

Okay, here's where I'm ready to call troll. Compare and contrast the
paragraph above with this quote from a previous message by &quot;Ruby Maniac&quot;:

<QUOTE PREVIOUSPOST="
&gt; Recently I was given the task of importing data from one SQL Server
&gt; 2005 database to another and rather than allow a co-worker use C#
&gt; to code a faster way to accomplish this I chose to use Ruby even
&gt; though the work took weeks to complete and that Moron who wanted to
&gt; use C# might have completed the work in less than a day I know Ruby
&gt; as a superior language is well worth the weeks of time my team has
&gt; invested in the process or doing a rather simple data import task.
&gt; Ruby rocks !
">

Yeah. That'd be a direct contradiction.

*plonk*

--Greg
</POST>
<POST>
<POSTER> &quot;Terry Poulin&quot; &lt;bigbos...@ippimail.com&gt; </POSTER>
<POSTDATE> 2007-09-26T19:26:00 </POSTDATE>
Ruby Manic, it seems every where I look for you I seem to see tendencies for
being a Pain In The Neck. If I could, I'd probably set my MUA to ignore all
threats started by you....

I am usually not one to use the word Troll -- but I think you are getting to
be classifiable as one!

Don't like that Ruby 2.0 is not out yet? Get off your butt and help them.

Think Ruby 1.8.x is to slow? Get over it or don't use it.

Can't stand the possibility of reverse engineering? Then employ an obfuscater
and write a Ruby To Machine Code compiler for the result -- I would love to
use one! Maybe you could even work out a way to use the intermediate
representation to further obfuscate the code.

If you can't stand the way Ruby does things, ether put up or push off. No one
forces you to use Ruby. I doubt many businesses would stipulate it ether
unless they require Rails people.

Even installed YARV for testing yet?

Using one tool for every thing is bad for business. I think it's nice when
some one has a 'Just for fun' moment. Such as doing a project in C they would
usually do in Shell/Batch or vice versa.

I've learned a number of languages, each is useful and worth using at some
point.  My new target is Scheme -- I find Ruby works best for most regular
tasks. And has more portability for 'in house' needs here then POSIX Shell
scripting if tasks are more complex then I would care to type into a CLI.

In business, using Ruby in place of C# when the trade off looks like Weeks vs
Days. Is just stupid in my humble opinion from the point of view of people
having to *pay* for such work. When no one is footing the bill for it, it's
ok. Maybe this is why I prefer Vim to Notepad. The effect fullness out ways
the cost of learning.

Don't start threads to whine, poke, or encourage chaos. Ether make do with
what you do have, help make it better, or go troll some other seas.

If Ruby won't cut it for you, maybe you should try Python. But I wouldn't wish
you on the Python community !

TerryP.

--

Email and shopping with the feelgood factor!
55% of income to good causes. http://www.ippimail.com
</POST>
<POST>
<POSTER> Curt Sampson &lt;c...@cynic.net&gt; </POSTER>
<POSTDATE> 2007-10-14T02:29:00 </POSTDATE>
On Wed, 26 Sep 2007, M. Edward (Ed) Borasky wrote:

<QUOTE PREVIOUSPOST="
&gt; I personally think that it is almost always a mistake to do &quot;a vast
&gt; amount of programming ... not to make products which are sold to others
&gt; but for internal consumption&quot;.  Programmers should be paid to produce
&gt; software that fills profitable markets, not to do infrastructure
&gt; projects that could be done using off-the-shelf software.
">

This sounds like an opinion held firmly enough that it's unswayable, but
just in case you care to contemplate it, I'll tell you why I disagree.

In my world, at least, programming is cheap. Solving problems can be
expensive and difficult, but the coding aspect of that is generally
fairly trivial. In fact, due to the flexability you have when writing
custom software, it can be easier than trying to configure a commerical
package.

Another way of looking at it is that all that time you spend tweaking
XML configuration files is just another form of programming anyway. Why
not just do it in Ruby (or whatever) instead, if that's easier?

(This is not to say I don't use off-the-shelf software, BTW.)

cjs
--
Curt Sampson         &lt;c ... @cynic.net&gt;         +81 90 7737 2974
http://www.starling-software.com
The power of accurate observation is commonly called cynicism
by those who have not got it.    --George Bernard Shaw
</POST>
<POST>
<POSTER> &quot;M. Edward (Ed) Borasky&quot; &lt;zn...@cesmail.net&gt; </POSTER>
<POSTDATE> 2007-10-14T06:16:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Curt Sampson wrote:
&gt; On Wed, 26 Sep 2007, M. Edward (Ed) Borasky wrote:

&gt;&gt; I personally think that it is almost always a mistake to do &quot;a vast
&gt;&gt; amount of programming ... not to make products which are sold to others
&gt;&gt; but for internal consumption&quot;.  Programmers should be paid to produce
&gt;&gt; software that fills profitable markets, not to do infrastructure
&gt;&gt; projects that could be done using off-the-shelf software.

&gt; This sounds like an opinion held firmly enough that it's unswayable, but
&gt; just in case you care to contemplate it, I'll tell you why I disagree.

&gt; In my world, at least, programming is cheap. Solving problems can be
&gt; expensive and difficult, but the coding aspect of that is generally
&gt; fairly trivial. In fact, due to the flexability you have when writing
&gt; custom software, it can be easier than trying to configure a commerical
&gt; package.
">

Well ... that I think depends on the task to be accomplished. But in
general, if at all possible you should buy (or acquire open source)
infrastructure rather than build it. Here's what I recommend:

1. Collect your requirements.
2. See what you can buy (or acquire) that best meets them.
3. If there are fewer than three viable sources, go back to your
stakeholders and start axing requirements. Remember, you're trying to
minimize costs and free up programmers to produce software you can sell.

OK ... now assume you've got the requirements negotiated down to the
point where there are three or more viable sources. If there are more
than three, throw out all but the three most expensive. Why? Because
they are either incompetent or competent and attempting to buy the
business. In either case, you don't want to deal with them.

Now you're ready to go out for bids. Make *damn* sure all three can meet
your requirements, and that they aren't written to favor one of the
sources. If your requirements don't pass this test, again, go back to
your stakeholders and negotiate until you get what you need -- a set of
requirements that three competent sources can meet.

All I'm saying, when you really think about it, is that you need to
apply the YAGNI principle to infrastructure ruthlessly. You Ain't Gonna
Need It, and putting a real price tag on it by forcing yourself to buy
it and justify buying it forces you to think about it, rather than just
saying, &quot;hey, for only ten lines of Ruby code I can ...&quot;

<QUOTE PREVIOUSPOST="
&gt; Another way of looking at it is that all that time you spend tweaking
&gt; XML configuration files is just another form of programming anyway. Why
&gt; not just do it in Ruby (or whatever) instead, if that's easier?
">

If you did your procurement right, *you* shouldn't have to do a lot of
configuration or customization or any other kind of programming
disguised as system administration. You bought infrastructure -- the
vendor should teach you how to use it and fix it when it's broken. You
shouldn't have to do things with it that it wasn't meant to do, write
scripts or edit XML files to work around defects, interface it to
someone else's pet database, etc.

If you *have* to build infrastructure, by all means, do it in a
pragmatic, agile manner with Ruby or similar tools. But don't do it just
because it's *fun* or because you think you're saving money, because you
aren't saving money -- you're spending it.
</POST>
<POST>
<POSTER> Chad Perrin &lt;per...@apotheon.com&gt; </POSTER>
<POSTDATE> 2007-10-14T13:25:00 </POSTDATE>
On Sun, Oct 14, 2007 at 07:16:50PM +0900, M. Edward (Ed) Borasky wrote:

<QUOTE PREVIOUSPOST="
&gt; Curt Sampson wrote:
&gt; &gt;On Wed, 26 Sep 2007, M. Edward (Ed) Borasky wrote:

&gt; &gt;&gt;I personally think that it is almost always a mistake to do &quot;a vast
&gt; &gt;&gt;amount of programming ... not to make products which are sold to others
&gt; &gt;&gt;but for internal consumption&quot;.  Programmers should be paid to produce
&gt; &gt;&gt;software that fills profitable markets, not to do infrastructure
&gt; &gt;&gt;projects that could be done using off-the-shelf software.

&gt; &gt;This sounds like an opinion held firmly enough that it's unswayable, but
&gt; &gt;just in case you care to contemplate it, I'll tell you why I disagree.

&gt; &gt;In my world, at least, programming is cheap. Solving problems can be
&gt; &gt;expensive and difficult, but the coding aspect of that is generally
&gt; &gt;fairly trivial. In fact, due to the flexability you have when writing
&gt; &gt;custom software, it can be easier than trying to configure a commerical
&gt; &gt;package.

&gt; Well ... that I think depends on the task to be accomplished. But in
&gt; general, if at all possible you should buy (or acquire open source)
&gt; infrastructure rather than build it. Here's what I recommend:
">

I tend to agree that it's better to reuse than to recreate.  Beyond that,
however, I start running into some disagreements with you.

<QUOTE PREVIOUSPOST="
&gt; 1. Collect your requirements.
&gt; 2. See what you can buy (or acquire) that best meets them.
&gt; 3. If there are fewer than three viable sources, go back to your
&gt; stakeholders and start axing requirements. Remember, you're trying to
&gt; minimize costs and free up programmers to produce software you can sell.
">

Axing requirements should happen earlier than that -- not because you
should be trying to maximize the field of existing software that fills
your needs, but because too many requirements are a sign of poor focus.
Whether or not you can find more than three off-the-shelf software
packages that suit your requirements list has basically nothing to do
with that.  You can have very specific, well-defined requirements and not
find a single off-the-shelf solution that'll work, and you can similarly
have scattered, unfocused, poorly considered requirements for which there
are thousands of options.  Most often, however, what you end up with in
cases of scattered, unfocused, poorly considered requirements is a VP who
insists that something like MS Exchange is the *only* solution that can
possibly work for your &quot;needs&quot;.

<QUOTE PREVIOUSPOST="
&gt; OK ... now assume you've got the requirements negotiated down to the
&gt; point where there are three or more viable sources. If there are more
&gt; than three, throw out all but the three most expensive. Why? Because
&gt; they are either incompetent or competent and attempting to buy the
&gt; business. In either case, you don't want to deal with them.
">

You've just thrown out open source software again -- and you've limited
the choices to the industry dominating options, which may or may not be
worth a damn.  This sounds surprisingly like an &quot;enterprise resource
management software acquisition&quot; process, which tends to end up with a
company investing $120,000 in a piece of software that's going to cost
another $40,000 to get installed and configured, and still may not work
properly.  Maybe I'm exaggerating a little, for the average case, but I
think that's only because the average case gets a little more lucky than
that.

. . and that's the problem: the success of this scheme seems to be
significantly predicated upon an assumption of luck.

<QUOTE PREVIOUSPOST="
&gt; Now you're ready to go out for bids. Make *damn* sure all three can meet
&gt; your requirements, and that they aren't written to favor one of the
&gt; sources. If your requirements don't pass this test, again, go back to
&gt; your stakeholders and negotiate until you get what you need -- a set of
&gt; requirements that three competent sources can meet.
">

At this point, it's starting to sound more like &quot;Plan your acquisition
based on what looks good to middle-management, then play damage control
to try to limit the amount of obscene costs such a middle-management
conceived plan of acquisition tends to engender.&quot;  I think there are
better ways -- and they start with bringing more focus to your
requirements in the first place, nailing it down to what you absolutely
cannot give up with a short list of wanna-haves, then just checking to
see what fits that (regardless of how many of them there are in the
market or how much they cost).

<QUOTE PREVIOUSPOST="
&gt; All I'm saying, when you really think about it, is that you need to
&gt; apply the YAGNI principle to infrastructure ruthlessly. You Ain't Gonna
&gt; Need It, and putting a real price tag on it by forcing yourself to buy
&gt; it and justify buying it forces you to think about it, rather than just
&gt; saying, &quot;hey, for only ten lines of Ruby code I can ...&quot;
">

I agree somewhat, in that you should write the software yourself only if
something premade either:

1. doesn't exist to suit your needs, or
2. costs far, far more than the resources involved in writing it
yourself.

Of course, that also assumes you have the discipline in your organization
to avoid going nuts on feature-adding while writing it yourself.  Then
again, we're assuming your organization has the discipline to cut down
requirements rather than going with the mediocre &quot;feature rich&quot; &quot;industry
standard solution&quot; just because it &quot;does everything&quot; -- failing to think
about whether or not it'll do it well or consistently (or for a
reasonable price).

<QUOTE PREVIOUSPOST="
&gt; &gt;Another way of looking at it is that all that time you spend tweaking
&gt; &gt;XML configuration files is just another form of programming anyway. Why
&gt; &gt;not just do it in Ruby (or whatever) instead, if that's easier?

&gt; If you did your procurement right, *you* shouldn't have to do a lot of
&gt; configuration or customization or any other kind of programming
&gt; disguised as system administration. You bought infrastructure -- the
&gt; vendor should teach you how to use it and fix it when it's broken. You
&gt; shouldn't have to do things with it that it wasn't meant to do, write
&gt; scripts or edit XML files to work around defects, interface it to
&gt; someone else's pet database, etc.
">

You've pretty much limited your field of vendors to IBM, at this point.
Hopefully they have something that suits your needs.

Yes, I'm overstating the case a bit -- but it's to make a point.

Editing XML files in ERP and similar software markets isn't about working
around defects, unless you consider that entire software market to be
defective (which is certainly a valid viewpoint in many cases); it's just
how the software is configured for your needs.  If you consider the
entire market to be defective, however, you've just come back to the
&quot;roll your own solution&quot; answer to the problem.

It's probably worth keeping in mind that in certain niches of
off-the-shelf software markets, *nothing* that you can find to buy is
likely to be worth the time spent evaluating it, let alone the incredible
price tag it carries.

<QUOTE PREVIOUSPOST="
&gt; If you *have* to build infrastructure, by all means, do it in a
&gt; pragmatic, agile manner with Ruby or similar tools. But don't do it just
&gt; because it's *fun* or because you think you're saving money, because you
&gt; aren't saving money -- you're spending it.
">

With that statement, it seems like we're in agreement again.  Funny how
that happens.

I think a big part of the problem in our points of disagreement here is
that you seem to view software as a product, and I see it as process.
Software is basically just a process specification, and the computer is
the part of the organization that executes that process.  The point is to
streamline operations and make certain tasks more efficient so that they
consume fewer resources -- perhaps making completion of those tasks
affordable at all, thus providing your organization with the ability to
accomplish more.  That's what all process is: a means of making
operations &quot;better&quot;.

A product is something you slot into process because your process demands
it, like providing chairs for your employees to use when they're working
in their cubicles.

Confusing products with process is, I think, one of the biggest problems
the software industry has right now.

--
CCD CopyWrite Chad Perrin [ http://ccd.apotheon.org ]
They always say that when life gives you lemons you should make lemonade.
I always wonder -- isn't the lemonade going to suck if life doesn't give
you any sugar?
</POST>
</TEXT>
</BODY>
</DOC>
