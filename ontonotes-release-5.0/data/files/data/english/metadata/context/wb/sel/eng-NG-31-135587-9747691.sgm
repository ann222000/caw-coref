<DOC>
<DOCID> eng-NG-31-135587-9747691 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2008-02-03T13:28:00 </DATETIME>
<BODY>
<HEADLINE>
&quot;Sorting&quot; assignment
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;Ivica&quot; &lt;prljavi_blu...@hi.t-com.hr&gt; </POSTER>
<POSTDATE> 2008-02-03T13:28:00 </POSTDATE>
First, I would like to thank everybody in my previous thread called &quot;general
tree assignment in c&quot;.
It's not about some kind of student's lazyness, the problem is a little bit
depper. Guy, whose job was to taught us programming basics and C was so bad
so he got fired at our hard initiative so we are faced with severe problems
in this subject called &quot;algorithms and data structures&quot;.

Now, we have to write something like this:

We have program which prints news. There are unlimited number of news(?).
Every news contains subject and body text. Also, we count how much was every
news read. Everytime a news get read, we add 1 to to the value &quot;read&quot;.
Create functions which will print the top 5 of the news, how much in average
something gets read, and what's the difference between the top news and the
news in the middle.

I am looking at switch case usage and bubblesort?

Sorry for any bad translation from croatian to english.

Thank you for your time.
</POST>
<POST>
<POSTER> &quot;osmium&quot; &lt;r124c4u...@comcast.net&gt; </POSTER>
<POSTDATE> 2008-02-03T14:13:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; writes:
&gt; First, I would like to thank everybody in my previous thread called
&gt; &quot;general tree assignment in c&quot;.
&gt; It's not about some kind of student's lazyness, the problem is a little
&gt; bit depper. Guy, whose job was to taught us programming basics and C was
&gt; so bad so he got fired at our hard initiative so we are faced with severe
&gt; problems in this subject called &quot;algorithms and data structures&quot;.

&gt; Now, we have to write something like this:

&gt; We have program which prints news. There are unlimited number of news(?).
&gt; Every news contains subject and body text. Also, we count how much was
&gt; every news read. Everytime a news get read, we add 1 to to the value
&gt; &quot;read&quot;.
&gt; Create functions which will print the top 5 of the news, how much in
&gt; average something gets read, and what's the difference between the top
&gt; news and the news in the middle.

&gt; I am looking at switch case usage and bubblesort?
">

I can't see how switch/case would be helpful in any of this.

WRT the bubble sort.  I presume you want to sort by number times read so you
can determine the median and the top 5?  You *could* use a bubble sort to do
that but you really shouldn't.  Bubble sort is OK for very small data sets,
such as 10 items or so and is also a way to teach raw sorting principles.
After that it is pretty much abandoned.  A much better way is to use qsort()
in &lt;stdlib.h&gt;.  It is not real easy for a novice to use but there are a lot
of questions and answers already posted in the newsgroups.  You can access
these articles by clicking on more|Groups in Google. You may want to use the
&quot;advanced&quot; option.
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2008-02-03T14:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;osmium&quot; &lt;r124c4u ... @comcast.net&gt; wrote in message
&gt; WRT the bubble sort.  I presume you want to sort by number times read so &gt;
&gt; you can determine the median and the top 5?  You *could* use a bubble sort
&gt; to do that but you really shouldn't.  Bubble sort is OK for very small
&gt; data sets, such as 10 items or so and is also a way to teach raw sorting
&gt; principles. After that it is pretty much abandoned.
">

Bubble sort is also very good when no item is likely to switch position by
more than one or two places. An example is a &quot;times read&quot; list. After each
person reads one or two entries, the list must be sorted, but it is already
very nearly sorted. A couple of entries may swap places, but bubblesort will
terminate on a couple of runs.
The main problem you get is that at initiation everything has a score of
zero, so an item can move from bottom to top, making bubblesort N^2.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> John Slimick &lt;slim...@cameron.upb.pitt.edu&gt; </POSTER>
<POSTDATE> 2008-02-03T17:09:00 </POSTDATE>
On 2008-02-03, Malcolm McLean &lt;regniz ... @btinternet.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;osmium&quot; &lt;r124c4u ... @comcast.net&gt; wrote in message
&gt;&gt; WRT the bubble sort.  I presume you want to sort by number times read so &gt;
&gt;&gt; you can determine the median and the top 5?  You *could* use a bubble sort
&gt;&gt; to do that but you really shouldn't.  Bubble sort is OK for very small
&gt;&gt; data sets, such as 10 items or so and is also a way to teach raw sorting
&gt;&gt; principles. After that it is pretty much abandoned.
&gt; Bubble sort is also very good when no item is likely to switch position by
&gt; more than one or two places. An example is a &quot;times read&quot; list. After each
&gt; person reads one or two entries, the list must be sorted, but it is already
&gt; very nearly sorted. A couple of entries may swap places, but bubblesort will
&gt; terminate on a couple of runs.
&gt; The main problem you get is that at initiation everything has a score of
&gt; zero, so an item can move from bottom to top, making bubblesort N^2.
">

Isn't there some kind of binary tree where
each node contains the key and the frequency,
where the most common keys appear around the root?
This is dynamic, where you build the tree from
the keys as you encounter them. Your five most
common would be the root, the roots of the two
subtrees, and two of the four subsubtrees.

I'm sorry, but I just can't recall the name of this
technique.

john slimick
slim ... @pitt.edu
</POST>
<POST>
<POSTER> Logan Shaw &lt;lshaw-use...@austin.rr.com&gt; </POSTER>
<POSTDATE> 2008-02-03T18:06:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
John Slimick wrote:
&gt; Isn't there some kind of binary tree where
&gt; each node contains the key and the frequency,
&gt; where the most common keys appear around the root?
&gt; This is dynamic, where you build the tree from
&gt; the keys as you encounter them. Your five most
&gt; common would be the root, the roots of the two
&gt; subtrees, and two of the four subsubtrees.

&gt; I'm sorry, but I just can't recall the name of this
&gt; technique.
">

Do you mean a heap?  With a heap, the element at the top
is the highest (or lowest) according to some ordering.
You can remove the top element, then &quot;re-heapify&quot; so
that the new highest element goes to the top and the
appropriate other elements shift places to take up the
vacant spots.  A single element removal can be done in
O(log n) time, so you could find the top m elements
out of n by repeating this process m times, for a total
running time of O(m log n).

- Logan
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T01:15:00 </POSTDATE>
On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; First, I would like to thank everybody in my previous thread called &quot;general
&gt; tree assignment in c&quot;.
&gt; It's not about some kind of student's lazyness, the problem is a little bit
&gt; depper. Guy, whose job was to taught us programming basics and C was so bad
&gt; so he got fired at our hard initiative so we are faced with severe problems
&gt; in this subject called &quot;algorithms and data structures&quot;.
">

Let me get this straight, homeboy. You were sitting on your fat asses
in some goddamn programming class, and growing up in a country in
which the critical facility was shall we say made to atrophy by
politicians who set you against your brothers in a genocidal war, you
lacked the will to do the work.

Taking a cue from your Fearless Leaders, you decided to find a
minority, here of one, and of course it was the mere teacher, wasn't
it.

How could you even know he was &quot;so bad&quot;? You're the student: he (was)
the teacher.

Did he make mistakes? And was he himself so terrorized by a society
which has so discouraged dialogue that he discouraged your criticism?
Did you find the mistakes? Why didn't you make this part of the
learning effort?

<QUOTE PREVIOUSPOST="
&gt; Now, we have to write something like this:

&gt; We have program which prints news. There are unlimited number of news(?).
&gt; Every news contains subject and body text. Also, we count how much was every
&gt; news read. Everytime a news get read, we add 1 to to the value &quot;read&quot;.
&gt; Create functions which will print the top 5 of the news, how much in average
&gt; something gets read, and what's the difference between the top news and the
&gt; news in the middle.

&gt; I am looking at switch case usage and bubblesort?
">

Even if the teacher was a bonehead, he could have at least told you a
little secret about bubble sort, homeboy: that it seems to work for
small test volumes but slows to a crawl in the real world.

Hint: write a procedure to divide the items to be sorted into two
bins, one to the left of a selected item (can be any item, initially,
such as the first) such that all items in the bin on the left are less
than the selected item, and that all items on the right are greater.

Then redo the above for the left bin. Then redo it for the right bin.
Continue until you run out of things to do and you're done.

What's interesting is that this &quot;quicksort&quot; algorithm was probably
repeatedly invented by your forefathers on farms and factories to sort
apples and ingots but you're so busy hounding your teachers for not
transforming you into successful western Yuppies overnight that you've
forgotten how to learn.

<QUOTE PREVIOUSPOST="
&gt; Sorry for any bad translation from croatian to english.
">

I don't mind your bad Croatian. I don't think you had the right to get
a teacher fired because you don't know the subject. This shit came out
of the Chinese Cultural Revolution and the Nazi era.

If I have misunderstood the situation, my apologies. But if you got a
teacher fired, you're yet another mob.

<QUOTE PREVIOUSPOST="
&gt; Thank you for your time.
">
</POST>
<POST>
<POSTER> Richard Heathfield &lt;r...@see.sig.invalid&gt; </POSTER>
<POSTDATE> 2008-02-04T03:51:00 </POSTDATE>
Ivica said:

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt; We have program which prints news. There are unlimited number of news(?).
&gt; Every news contains subject and body text. Also, we count how much was
&gt; every news read. Everytime a news get read, we add 1 to to the value
&gt; &quot;read&quot;. Create functions which will print the top 5 of the news, how much
&gt; in average something gets read, and what's the difference between the top
&gt; news and the news in the middle.

&gt; I am looking at switch case usage and bubblesort?
">

Others have commented on the efficiency of Bubble Sort, so I will not do so
here. I would suggest using a binary search tree to record the news items,
using &quot;subject&quot; as the key, and storing the body text and frequency count
within the node data for that key. On discovering that a news item has
been read, search for that item in the tree. If you find it, add 1 to its
&quot;read&quot; value. If you don't, add the new node, setting the &quot;read&quot; value to
1.

Count the items as you go. When you've got all the data, you can remove the
items from the tree one at a time (easiest to start at the leaves), and
use them to build a new tree ordered on the &quot;read&quot; value. This has the
advantage of using no extra memory. Alternatively, if memory is not an
issue, you can just put them into an array, and re-sort on &quot;read&quot;. Then
you are in a position to answer all your &quot;how much/what&quot; questions.

--
Richard Heathfield &lt; http://www.cpax.org.uk &gt;
Email: - http://www . +rjh@
Google users: &lt; http://www.cpax.org.uk/prg/writings/googly.php &gt;
&quot;Usenet is a strange place&quot; - dmr 29 July 1999
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-04T06:44:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
">

news:fo514c$li8$1@ss408.t-com.hr ...

<QUOTE PREVIOUSPOST="
&gt; We have program which prints news. There are unlimited number of news(?).
&gt; Every news contains subject and body text. Also, we count how much was
&gt; every news read. Everytime a news get read, we add 1 to to the value
&gt; &quot;read&quot;.
&gt; Create functions which will print the top 5 of the news, how much in
&gt; average something gets read, and what's the difference between the top
&gt; news and the news in the middle.

&gt; I am looking at switch case usage and bubblesort?
">

You've given little practical detail so I'm assuming you just have a list of
the news like this, when there are N news items:

# SUBJECT BODY READ
1 &quot;Subject1&quot; &quot;Body1&quot; 12
2 &quot;Subject2&quot; &quot;Body2&quot; 7
3 &quot;Subject3&quot; &quot;Body3&quot; 23
...
N &quot;SubjectN&quot; &quot;BodyN&quot; 21

It sounds like everything has already been read and you want to sort by the
Read count, with highest count at the top. The first column is just an
index, you don't actually need to store this, but it might be useful to do
so to simplify sorting.

You haven't specified language, but let's assume the worst case, C (you
mentioned C in your other thread).

So you have 4 arrays of N items: Index, Subject (of char*), Body (of char*),
and Read. Index initially contains 1 to N.

Work out the average first, that's easy: the total of Read values divided by
N.

Now to the sort, which I suggest you do by manipulating the numbers in the
Index array rather than swapping everything around. After sorting, the Index
values in my example, looking only at the first 3, will start as (1,2,3) but
end up as (3,1,2) (because article #3 has been read the most).

Then print the top 5 using for example:

for (i=1; i&lt;=5; ++i) printf(&quot;# %d: Subject: %s \n&quot;, i, Subject[Index[i]]);

I haven't specified a sort method; bubble sort is fine if there are only a
few dozen or few hundred articles. but you might get extra marks for a
cleverer sort.

With bubble sort, when comparing items A and B (A,B are indices into the
arrays), compare using Read[A] and Read[B], and if necessary, swap Index[A]
and Index[B].

Notes: you need to check there are in fact at least 5 articles for printing
the results; also there is at least 1 article for the average; also in C
array bounds start at zero.

--
Bart
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T06:58:00 </POSTDATE>
To original poster: these comments are for Richard Heathfield, and not
directed at you.

On Feb 4, 4:51 pm, Richard Heathfield &lt;r ... @see.sig.invalid&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Ivica said:

&gt; &lt;snip&gt;

&gt; &gt; We have program which prints news. There are unlimited number of news(?).
&gt; &gt; Every news contains subject and body text. Also, we count how much was
&gt; &gt; every news read. Everytime a news get read, we add 1 to to the value
&gt; &gt; &quot;read&quot;. Create functions which will print the top 5 of the news, how much
&gt; &gt; in average something gets read, and what's the difference between the top
&gt; &gt; news and the news in the middle.

&gt; &gt; I am looking at switch case usage and bubblesort?

&gt; Others have commented on the efficiency of Bubble Sort, so I will not do so
&gt; here.
">

Why not? I would sincerely like to hear DIFFERENT ways of describing
how this sort works, in particularly how it slows down rapidly. Note
that it is one sort algorithm that nobody in his right mind would
actually use in doing actual manual labor; and yet it is presented
seriously as a possible candidate in computer science classes. The OP
and his mates seem to have eliminated their teacher right after
learning the bubble sort, and the teacher was either a dull fellow
(but not duller than his students) or followed a canned lesson plan
which presented the bubble sort first...implicitly as something we can
do now we have computers, but which is idiotic.

The bubble sort is presented in responsible CS classes as a curio, and
a limit case of stupidity from which more elegant sorts can be built;
even the interchange sort is better for smallscale ventures. But in
technical institutes where the administration allows teachers to be
mistreated in Maoist fashion, the students are systematically unable
to get beyond the basics because the teachers are being taken out into
the yard and shot (or something), and they mistakenly treasure the
simplest algorithms for that reason.

The result? The creation of a New Class proud of knowing bubble sorts,
that looks down upon London cabbies who swot 60,000+ destination to
get The Knowledge, or Starbuck's or McDonald's clerks who in fact have
learned quantitatively more, who crafts the software that tells the
clerk at Starbuck's how to screw up a latte, or tries to get to
Belgravia before the London cabbie...and doesn't, of course.

I suggest, Richard, that you point offline and elsethread in this
context not from a malign intent, which you may have when it comes to
spreading gossip and rumor about people, but from a standpoint overly
influenced by storage efficiency. You have a common illusion: that
teaching somebody is always saying things that are true.

You never invite the person to dialog with you man to man. Everything
is a FAQ, with all the contempt for the questioner that that acronym
(o just another newbie with the same old question) implies.

<QUOTE PREVIOUSPOST="
&gt;I would suggest using a binary search tree to record the news items,
">

You gonna tell the OP how to make a binary search tree? Should it be
an array, with left and right branches as integer valued indexes
restricted to the array lower bound and the array upperbound? Or given
that you love C's butt, is it going to be a floating magic struct that
multiplies behind the scenes like crazy?

Either way has its positives or negatives. The problem is that in
order to be right, and to maintain a false dominance, you restrict
your suggestion to one level above safe words.

<QUOTE PREVIOUSPOST="
&gt; using &quot;subject&quot; as the key, and storing the body text and frequency count
&gt; within the node data for that key. On discovering that a news item has
">

It appears that the OP is at the level of using primitive language
constructs (switch) and very simple algorithms. How do you expect him
to know what a tree is?

This is a common strategy in corporate speech. The corporate
representative uses certain buzzwords without definition, and the
audience, not wanting to seem ill-informed, nods their head sagely.

The point being that you do indeed answer questions but you do so
without risk.

<QUOTE PREVIOUSPOST="
&gt; been read, search for that item in the tree. If you find it, add 1 to its
&gt; &quot;read&quot; value. If you don't, add the new node, setting the &quot;read&quot; value to
&gt; 1.

&gt; Count the items as you go. When you've got all the data, you can remove the
&gt; items from the tree one at a time (easiest to start at the leaves), and
&gt; use them to build a new tree ordered on the &quot;read&quot; value. This has the
&gt; advantage of using no extra memory. Alternatively, if memory is not an
&gt; issue, you can just put them into an array, and re-sort on &quot;read&quot;. Then
&gt; you are in a position to answer all your &quot;how much/what&quot; questions.
">

There is absolutely nothing wrong with what you say in reply to the
OP, and this is the problem. You carefully skirt what you probably
know are gaps in the OP's knowledge lest you get into the same space
of risk, of making mistakes, that the OP's teacher was in in the
classroom, in front of students that seem to have been a rather ugly
mob implicitly supported by an administration ready to split the
teachers from the students in order to exploit both.

<QUOTE PREVIOUSPOST="
&gt; --
&gt; Richard Heathfield &lt; http://www.cpax.org.uk &gt;
&gt; Email: - http://www . +rjh@
&gt; Google users: &lt; http://www.cpax.org.uk/prg/writings/googly.php &gt;
&gt; &quot;Usenet is a strange place&quot; - dmr 29 July 1999
">
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-04T07:03:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote in message
">

news:vUCpj.1404$XI.601@text.news.virginmedia.com ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
&gt; news:fo514c$li8$1@ss408.t-com.hr ...
&gt;&gt; I am looking at switch case usage and bubblesort?
&gt; With bubble sort, when comparing items A and B (A,B are indices into the
&gt; arrays), compare using Read[A] and Read[B], and if necessary, swap
&gt; Index[A]
&gt; and Index[B].
">

There was a good reason for not going into the sort details :-)

To sort 'in-place' like here using an Index array, you need to compare
Read[Index[A]] and Read[Index[B]]. Otherwise the sort will never end (Read[]
never changes order).

--
Bart
</POST>
<POST>
<POSTER> Willem &lt;wil...@stack.nl&gt; </POSTER>
<POSTDATE> 2008-02-04T10:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
">

) Let me get this straight, homeboy. You were sitting on your fat asses
) in some goddamn programming class...
) &lt;snip&gt;

Please stop vandalizing this thread with your bullying.

SaSW, Willem
--
Disclaimer: I am in no way responsible for any of the statements
made in the above text. For all I know I might be
drugged or something..
No I'm not paranoid. You all think I'm paranoid, don't you !
#EOT
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T10:59:00 </POSTDATE>
On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; First, I would like to thank everybody in my previous thread called &quot;general
&gt; tree assignment in c&quot;.
&gt; It's not about some kind of student's lazyness, the problem is a little bit
&gt; depper. Guy, whose job was to taught us programming basics and C was so bad
&gt; so he got fired at our hard initiative so we are faced with severe problems
&gt; in this subject called &quot;algorithms and data structures&quot;.

&gt; Now, we have to write something like this:

&gt; We have program which prints news. There are unlimited number of news(?).
&gt; Every news contains subject and body text. Also, we count how much was every
&gt; news read. Everytime a news get read, we add 1 to to the value &quot;read&quot;.
&gt; Create functions which will print the top 5 of the news, how much in average
&gt; something gets read, and what's the difference between the top news and the
&gt; news in the middle.

&gt; I am looking at switch case usage and bubblesort?
">

If you use the bubble sort, your application may be too slow to manage
realistic amounts of news, and it appears you ganged up on your
instructor and got rid of him before you could learn about the
relative efficiency of sorting algorithms. Bubble sorting is how not
to sort.

Here is a C example of a simple program that sorts a list of random
numbers using the method of exchanging between two bins (partition
exchange) that I mentioned in my first post.

As I said, this algorithm grabs an arbitrary member and then compares
it to every other member, throwing each compared member into bin A or
bin B depending on whether it is greater than, or less than (or equal
to) the arbitrary member (called the pivot).

After the first pass. all members of bin A are less than or equal to
the pivot, and all members of bin B are greater than the pivot. The
program then calls itself, first for the A bin and then for the B bin.

This &quot;recursive&quot; call is not a loop since it calls the quicksort for
half the size each time through, therefore the size of bin A and bin B
approaches one, and the main quicksort exits when there are fewer than
2 entries.

But when A and B are one cell, this means that A &lt;= pivot &lt; B for all
members because the two recursive calls you see in the code cover all
the values. But that means that the entire array is sorted in rather
less time than a bubble sort, which maximizes the number of times an
entry must travel to get to its final position. For any arbitrary
entry, the probability of its having to move reduces each time the
quicksort is recursively called.

This is what intelligent workers might do on a farm when sorting
apples. They wouldn't use bubble sort. I think a programmer invented
that time sink.

Here is the code. Examine it in a monospace font such as Courier New.

// ***** Quicksort (partition exchange) example *****

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

const int SIZE = 27;

int quicksortPartition
(int intArray[],
int intLeft,
int intRight,
int intPivotIndex)
{
int intPivotValue = intArray[intPivotIndex];
intArray[intPivotIndex] = intArray[intRight];
intArray[intRight] = intPivotValue;
int intStoreIndex = intLeft;
int intIndex1;
int intExchange;
for (intIndex1 = intLeft;
intIndex1 &lt; intRight;
intIndex1++)
{
if (intArray[intIndex1] &lt;= intPivotValue)
{
intExchange = intArray[intIndex1];
intArray[intIndex1] = intArray[intStoreIndex];
intArray[intStoreIndex] = intExchange;
intStoreIndex += 1;
}
}
intPivotValue = intArray[intStoreIndex];
intArray[intStoreIndex] = intArray[intRight];
intArray[intRight] = intPivotValue;
return intStoreIndex;

<QUOTE PREVIOUSPOST="
}
">

void quicksort(int intArray[],
int intLeft,
int intRight)
{
if (intRight &gt; intLeft)
{
int intPivotNewIndex = quicksortPartition
(intArray,
intLeft,
intRight,
intLeft);
quicksort(intArray,
intLeft,
intPivotNewIndex - 1);
quicksort(intArray,
intPivotNewIndex + 1,
intRight);
}

<QUOTE PREVIOUSPOST="
}
">

int main(int argc,char *argv[])
{
int intArray[SIZE];
int intUpperBound = SIZE - 1;
int intIndex1;
for (intIndex1 = 0; intIndex1 &lt; SIZE; intIndex1++)
{
intArray[intIndex1] =
(int)(frand() * 99);
printf(&quot;%2d &quot;, intArray[intIndex1]);
}
printf(&quot;\n&quot;);
quicksort(intArray, 0, intUpperBound);
for (intIndex1 = 0; intIndex1 &lt; SIZE; intIndex1++)
{
printf(&quot;%2d &quot;, intArray[intIndex1]);
}
printf(&quot;\n&quot;);
return 0;

<QUOTE PREVIOUSPOST="
}

&gt; Sorry for any bad translation from croatian to english.

&gt; Thank you for your time.
">

REFERENCES

Hoare 1961: Hoare, C. A. R. &quot;Partition: Algorithm 63,&quot; &quot;Quicksort:
Algorithm 64,&quot; and &quot;Find: Algorithm 65.&quot; Comm. ACM 4(7), 321-322,
1961

Wikipedia 2008: &quot;Quicksort&quot;. http://en.wikipedia.org/wiki/Quicksort
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T11:07:00 </POSTDATE>
On Feb 4, 11:31 pm, Willem &lt;wil ... @stack.nl&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; spinoza1111wrote:

&gt; ) Let me get this straight, homeboy. You were sitting on your fat asses
&gt; ) in some goddamn programming class...
&gt; ) &lt;snip&gt;

&gt; Please stop vandalizing this thread with your bullying.
">

My comments were based accurately on what he said he did as part of a
class which appears, from his comments, to have gotten rid of their
teacher in a way that is all too common in inferior and for-profit
technical institutes, and this was wrong.

*Tu quoque*, as I have said, is a favorite tactic of the bully.
However, in my post &quot;Advice to Adult Victims of Cyberbullying&quot; I
defined bullying as the rejection of an individual human person (the
denial of his human right to mutuality of recognition and respect),
generalized from evidence usually fabricated or trumped-up. I have
focused my comments on his behavior which I found disturbing, and as
of this evening I followed up with a helpful code example
demonstrating an alternative to his choice of a bubble sort.

It is true that my only evidence was the original poster's remarks. If
he can explain himself and show that he did NOT form a mob with the
rest of his class, complain to the administration, and get a teacher
fired based on the feelings and opinions of students alone, then I'll
be the first to apologize.

Therefore, mein Herr, you can stop vandalizing this thread with YOUR
bullying.

<QUOTE PREVIOUSPOST="
&gt; SaSW, Willem
&gt; --
&gt; Disclaimer: I am in no way responsible for any of the statements
&gt;             made in the above text. For all I know I might be
&gt;             drugged or something..
&gt;             No I'm not paranoid. You all think I'm paranoid, don't you !
&gt; #EOT
">
</POST>
<POST>
<POSTER> Willem &lt;wil...@stack.nl&gt; </POSTER>
<POSTDATE> 2008-02-04T11:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
">

) *Tu quoque*, as I have said, is a favorite tactic of the bully.

Your favourite tactic, it seems, is to throw around as many accusations
as possible at as many people as possible, so that whenever you are
accused of anything, you can claim it's 'tu quoque'.

SaSW, Willem
--
Disclaimer: I am in no way responsible for any of the statements
made in the above text. For all I know I might be
drugged or something..
No I'm not paranoid. You all think I'm paranoid, don't you !
#EOT
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-04T12:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
&gt; On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:
&gt;&gt; I am looking at switch case usage and bubblesort?

&gt; If you use the bubble sort, your application may be too slow to manage
&gt; realistic amounts of news, and it appears you ganged up on your
">

&lt;snip sort code&gt;

Yes that's pretty fast, although up to N=1000, I could not detect much
difference between this and bubble sort. At N=10K there was a clear
difference, although bubble sort still took only 0.75secs (at N=100K there's
no contest).

But bubble sort has the huge advantage of being extremely simple. For this
assignment, may be best to get /anything/ working first then worry about
improving the sort speed, although I doubt the test data will be big enough
to show a difference.

--
Bart
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T12:09:00 </POSTDATE>
On Feb 5, 12:17 am, Willem &lt;wil ... @stack.nl&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; spinoza1111 wrote:

&gt; ) *Tu quoque*, as I have said, is a favorite tactic of the bully.

&gt; Your favourite tactic, it seems, is to throw around as many accusations
&gt; as possible at as many people as possible, so that whenever you are
&gt; accused of anything, you can claim it's 'tu quoque'.
">

That's false, mein Herr. I treated Ben with kid gloves because the man
did his homework. I treated Malcolm well simply because he started out
by using my name and has remained collegial. Neither of them are in
any sense in my camp; Ben (while not making absurd generalizations
based on elsethread rumor sites) felt that my code was misguided and
buggy, and Norman believes I go off-topic. &quot;Andy&quot; has described some
of my claims as &quot;howlers&quot; but has tentatively suggested that bullying
is indeed going on here.

You're only looking at posts that mention you, in all probability, in
the usual usenet narcissism, so you can take your amateur psychology
and you can shove it.

What I am saying is that just as there is a genuine difference between
Obama and McCain on one side, and Hilary and Romney on the other, that
transcends political differences considered one by one and in the
small, there is a morally significant difference between what you,
Heathfield, Howard et al. do on the one hand, and what people like
McLean, Bacarisse, and Andy do.

Heathfield, Howard, you et al. are thinglike people who transmit
mechanisms of social control that have been most elaborated in
Amerikkka, mechanisms that make people afraid of critical thinking,
because in critical thinking they may offend their immediate
community, be found in the wrong on some important or less-important
point, or be found in some way deficient in terms of a pseudo-
morality, and thereafter themselves objectified, and treated as not
worthy of community membership.

Lvica's teacher, I believe, was targeted by a class which was failing
to learn a difficult subject, but which has been mobilized by Western-
style mass media to believe in its right to understand &quot;everything&quot;
without hard work, in the same way that formerly Communist politicians
like Milosevic and Tudjman simplified their jobs by making the issue
of post-Communist Yugoslavia a matter of &quot;them&quot; (those Serbs, those
Moslems, that bozo CS teacher) and used a &quot;freed&quot; media to hammer home
this message to peoples thought unworthy of complexity.

The purpose in the Yugoslavian wars was to create a closed and tu
quoque system in which, for example, the less powerful Bosnian Moslems
or Kosovar Moslems could be renarrated as &quot;the real bullies&quot; based on
local incidents immediately amplified and distorted in essentially the
same way issues are amplified and distorted here.

Heathfield's purpose here is to create such a system in which the self-
appointed thought leaders need never worry about substantive criticism
from others, who will, it is hoped, remain mobilized against the
Other.

<QUOTE PREVIOUSPOST="
&gt; SaSW, Willem
&gt; --
&gt; Disclaimer: I am in no way responsible for any of the statements
&gt;             made in the above text. For all I know I might be
&gt;             drugged or something..
&gt;             No I'm not paranoid. You all think I'm paranoid, don't you !
&gt; #EOT
">
</POST>
<POST>
<POSTER> Willem &lt;wil...@stack.nl&gt; </POSTER>
<POSTDATE> 2008-02-04T12:49:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
">

) ..., there is a morally significant difference between what you,
) Heathfield, Howard et al. do on the one hand, and what people like
) McLean, Bacarisse, and Andy do.

They weren't there the last time you vandalized this newsgroup.

SaSW, Willem
--
Disclaimer: I am in no way responsible for any of the statements
made in the above text. For all I know I might be
drugged or something..
No I'm not paranoid. You all think I'm paranoid, don't you !
#EOT
</POST>
<POST>
<POSTER> &quot;Ivica&quot; &lt;prljavi_blu...@hi.t-com.hr&gt; </POSTER>
<POSTDATE> 2008-02-04T13:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;spinoza1111&quot; &lt;spinoza1 ... @yahoo.com&gt; wrote in message
">

news:9785845b-de37-47f3-b50c-f5ca69f148ff@q77g2000hsh.googlegroups.com ...

<QUOTE PREVIOUSPOST="
&gt; Let me get this straight, homeboy. You were sitting on your fat asses
&gt; in some goddamn programming class, and growing up in a country in
&gt; which the critical facility was shall we say made to atrophy by
&gt; politicians who set you against your brothers in a genocidal war, you
&gt; lacked the will to do the work.
">

What the hell are you talking about? You are lucky that you are far from me,
since I will probably having fun now breaking your backbone because of this
garbage you have written in this thread.

You, little wannabe smartass came to me with approach &quot;hey look at me, I
read politics for mommy's imbeciles and I like to talk about things which I
really shouldn't talk about since I wasn't there&quot;.

You are talking to me about genocide? You, little asshole, whose biggest
genocide was genocide on your neurons which you did it by yourself.

Since this is a programming thread and not &quot;how to smack imbecile's ass&quot;, I
will stay on topic.

No, we weren't &quot;sitting on our fat asses&quot;, since the guy was total imbecile
unable to &quot;transport&quot; his knowledge to us and that wasn't just only our
intention, since his colleagues where against him too. Then, board have
decided. Since that's an expensive private school, not every wannabe
professor can work there. Now, some other guys are doing that subject as it
should be.

Democracy is nice, isn't it?

<QUOTE PREVIOUSPOST="
&gt; Taking a cue from your Fearless Leaders, you decided to find a
&gt; minority, here of one, and of course it was the mere teacher, wasn't
&gt; it.
">

You have the answer above, Herr Troll Leader.

<QUOTE PREVIOUSPOST="
&gt; How could you even know he was &quot;so bad&quot;? You're the student: he (was)
&gt; the teacher.
">

He was bad. He had asshole attitude to students and looked at them like
lower human race since he is physician, and &quot;he must teach us programming
basics&quot;.

<QUOTE PREVIOUSPOST="
&gt; Did he make mistakes? And was he himself so terrorized by a society
&gt; which has so discouraged dialogue that he discouraged your criticism?
&gt; Did you find the mistakes? Why didn't you make this part of the
&gt; learning effort?
">

Yes, he made a lot of mistakes. Board sent him to private classes of
something like &quot;learn how to teach properly&quot; but that didn't help him
noticeably.

<QUOTE PREVIOUSPOST="
&gt; Even if the teacher was a bonehead, he could have at least told you a
&gt; little secret about bubble sort, homeboy: that it seems to work for
&gt; small test volumes but slows to a crawl in the real world.
">

No, he didn't told us that. Believe it or not.

<QUOTE PREVIOUSPOST="
&gt; Hint: write a procedure to divide the items to be sorted into two
&gt; bins, one to the left of a selected item (can be any item, initially,
&gt; such as the first) such that all items in the bin on the left are less
&gt; than the selected item, and that all items on the right are greater.

&gt; Then redo the above for the left bin. Then redo it for the right bin.
&gt; Continue until you run out of things to do and you're done.
">

Finally end of trolling part.

<QUOTE PREVIOUSPOST="
&gt; What's interesting is that this &quot;quicksort&quot; algorithm was probably
&gt; repeatedly invented by your forefathers on farms and factories to sort
&gt; apples and ingots but you're so busy hounding your teachers for not
&gt; transforming you into successful western Yuppies overnight that you've
&gt; forgotten how to learn.
">

Oh, you are back.

<QUOTE PREVIOUSPOST="
&gt; I don't mind your bad Croatian. I don't think you had the right to get
&gt; a teacher fired because you don't know the subject. This shit came out
&gt; of the Chinese Cultural Revolution and the Nazi era.
">

Oh, you are back with even better shit now.

<QUOTE PREVIOUSPOST="
&gt; If I have misunderstood the situation, my apologies. But if you got a
&gt; teacher fired, you're yet another mob.
">

:-) It is funny that you have written a enermous amount of monologue shit
and now, you came with &quot;If I have misunderstood&quot;.

Lovely.

Now, put your finger right in your worn ass and fuck off from here in
triplejumps and leave this newsgroup to the people who like to share
experiences and show somebody little altruism to prove themselves that they
are a good people. Something that you shall never learn with this approach
to the tematics and life generally.

Hop! Hop! Hop! :-*

P.S. I usually ignore trolls like you, but this is was a way too much.
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T21:48:00 </POSTDATE>
On Feb 5, 1:01 am, &quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; spinoza1111wrote:
&gt; &gt; On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:
&gt; &gt;&gt; I am looking at switch case usage and bubblesort?

&gt; &gt; If you use the bubble sort, your application may be too slow to manage
&gt; &gt; realistic amounts of news, and it appears you ganged up on your

&gt; &lt;snip sort code&gt;

&gt; Yes that's pretty fast, although up to N=1000, I could not detect much
&gt; difference between this and bubble sort. At N=10K there was a clear
&gt; difference, although bubble sort still took only 0.75secs (at N=100K there's
&gt; no contest).

&gt; But bubble sort has the huge advantage of being extremely simple. For this
">

Bubble sort is simple, all right...to the point of
incomprehensibility. Students need to relate abstract mathematical
algorithms to their conscious performance of actual manual labor, and
nobody would sort books or tools using a bubble sort.

Bubble sort maximizes the amount of separate movements. Now, the
management theorist Frederick Taylor said he was minimizing the number
of separate movements of railword worker Schmitt in his 1920s work on
industrial engineering. Paradoxically, Taylor reduced the number of
motions m only to get to a fatter value for m/t, since he didn't care
about Schmitt, who he dismissed, in a racist fashion, as a &quot;little
Pennsylvania Dutchman&quot;.

Of course, I don't care (except in some special case where transfer of
a member is computationally expensive, and nearly all of these
situations can be fixed by sorting links instead of actual members)
about using a lot of computer time; a computer isn't a little
Pennsylvania Dutchman. But to say that the bubble sort is &quot;simple&quot;
makes sense only as the sort of abstraction which is incomprehensible
to people with experience in the real world. That would be interchange
or quicksort because those algorithms are closer to what biological
systems evolve.

Gee, I guess this is a &quot;Marxist&quot; philosophy of computer science. Wow,
Pretty scary.

But the fact is that computer science textbook authors need to get out
more. Students, I believe, don't find the bubble sort &quot;simpler&quot; except
in the rawest and most OVER-simplified sense that it takes the fewest
(if the most incomprehensible) and shortest (if most opaque) words for
the instructor to describe before he's hounded out of a job by some
hard initiative. I don't think the students in lvica's class can
explain why it works. They were told it works.

<QUOTE PREVIOUSPOST="
&gt; assignment, may be best to get /anything/ working first then worry about
&gt; improving the sort speed, although I doubt the test data will be big enough
&gt; to show a difference.
">

...which means that the students won't be able to ramp up to speed on
a real job with real volumes and when their bubble sort seems to take
&quot;too long&quot;, will try to find someone new to blame.

<QUOTE PREVIOUSPOST="
&gt; --
&gt; Bart
">
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-04T21:51:00 </POSTDATE>
On Feb 5, 1:01 am, &quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; spinoza1111 wrote:
&gt; &gt; On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:
&gt; &gt;&gt; I am looking at switch case usage and bubblesort?

&gt; &gt; If you use the bubble sort, your application may be too slow to manage
&gt; &gt; realistic amounts of news, and it appears you ganged up on your

&gt; &lt;snip sort code&gt;

&gt; Yes that's pretty fast, although up to N=1000, I could not detect mu
">

Hint: draw the curve for x=y**2 or draw the curve for x=log(y) and
rotate it 90 degrees. Magnify the curve near zero. The quicksort and
similar algorithms take a while to get started, of course, on
overcoming the speed of bubble or interchange sorts.

<QUOTE PREVIOUSPOST="
&gt; difference between this and bubble sort. At N=10K there was a clear
&gt; difference, although bubble sort still took only 0.75secs (at N=100K there's
&gt; no contest).

&gt; But bubble sort has the huge advantage of being extremely simple. For this
&gt; assignment, may be best to get /anything/ working first then worry about
&gt; improving the sort speed, although I doubt the test data will be big enough
&gt; to show a difference.

&gt; --
&gt; Bart
">
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-05T01:28:00 </POSTDATE>
On Feb 5, 1:49 am, Willem &lt;wil ... @stack.nl&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; spinoza1111wrote:

&gt; ) ..., there is a morally significant difference between what you,
&gt; ) Heathfield, Howard et al. do on the one hand, and what people like
&gt; ) McLean, Bacarisse, and Andy do.

&gt; They weren't there the last time you vandalized this newsgroup.
">

Sure they were. If you mean McLean, Bacarisse and Andy, they all
responded to the thread I started on Beautiful Code early last month.
Heathfield and Howard cluttered the thread deliberately, Howard by
direct attacks of the most foul kind, and Heathfield by using the
thread to discuss me with third parties in a way that would be
considered unacceptably rude in a face to face situation. In so doing,
they violate a basic rule, which is &quot;don't feed the trolls&quot;: if you
regard a person as a &quot;troll&quot;, then it's your responsibility not to
&quot;encourage&quot; him. I don't regard myself as a troll, but Heathfield and
Howard clearly do so regard me, and are being deeply dishonest when
they deliberately obscure constructive discussion, whether on-topic or
off-topic, with their claims about personalities.

<QUOTE PREVIOUSPOST="
&gt; SaSW, Willem
&gt; --
&gt; Disclaimer: I am in no way responsible for any of the statements
&gt;             made in the above text. For all I know I might be
&gt;             drugged or something..
&gt;             No I'm not paranoid. You all think I'm paranoid, don't you !
&gt; #EOT
">
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-05T02:19:00 </POSTDATE>
On Feb 5, 2:32 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;spinoza1111&quot; &lt;spinoza1 ... @yahoo.com&gt; wrote in message

&gt; news:9785845b-de37-47f3-b50c-f5ca69f148ff@q77g2000hsh.googlegroups.com ...

&gt; &gt; Let me get this straight, homeboy. You were sitting on your fat asses
&gt; &gt; in some goddamn programming class, and growing up in a country in
&gt; &gt; which the critical facility was shall we say made to atrophy by
&gt; &gt; politicians who set you against your brothers in a genocidal war, you
&gt; &gt; lacked the will to do the work.

&gt; What the hell are you talking about? You are lucky that you are far from me,
&gt; since I will probably having fun now breaking your backbone because of this
&gt; garbage you have written in this thread.

&gt; You, little wannabe smartass came to me with approach &quot;hey look at me, I
&gt; read politics for mommy's imbeciles and I like to talk about things which I
&gt; really shouldn't talk about since I wasn't there&quot;.
">

The problem about being &quot;there&quot;, in Zagreb, was that you were being
fed lies by a controlled media. I probably had a better feel for what
was going on since during the war which your politicians started, I
was a daily reader of The New York Times, which had independent
correspondents working on all sides. Sunsequently I read several
histories of the events in Serbia, Croatia and Bosnia including &quot;To
End a War&quot; by Richard Holbrooke, Bill Clinton's secretary of state,
who helped your country win its 1995 war with Serbia, but only to
bring Milosevic to a peace conference in Ohio, and end the Bosnian
phase of the Yugoslavian wars.

<QUOTE PREVIOUSPOST="
&gt; You are talking to me about genocide? You, little asshole, whose biggest
&gt; genocide was genocide on your neurons which you did it by yourself.
">

Yeah, I'm talking about genocide, homeboy, a genocide which historians
agree was Serbian and Croatian in origin, and which resulted from a
controlled media which politicians used to encourage people to pick on
the weak instead of talk back to the fat cats.

<QUOTE PREVIOUSPOST="
&gt; Since this is a programming thread and not &quot;how to smack imbecile's ass&quot;, I
&gt; will stay on topic.
">

Good. I'm glad to see you don't emulate its thought leaders.

<QUOTE PREVIOUSPOST="
&gt; No, we weren't &quot;sitting on our fat asses&quot;, since the guy was total imbecile
&gt; unable to &quot;transport&quot; his knowledge to us and that wasn't just only our
&gt; intention, since his colleagues where against him too. Then, board have
&gt; decided. Since that's an expensive private school, not every wannabe
&gt; professor can work there. Now, some other guys are doing that subject as it
&gt; should be.
">

If he was a total imbecile, why was he hired? It still sounds to me
that rather than do due diligence, the board hired him and threw him
in front of students to see if he'd be popular. You guys were learning
computer science in the wrong way (you need to use Java, not C) and
started to fail, and in a post-Communist populist reaction, the board
saved itself having to do any work by canning him.

What I'm saying is that your input was for the most part biased and
worthless but appeared to have been the deciding factor.

<QUOTE PREVIOUSPOST="
&gt; Democracy is nice, isn't it?
">

That's not democracy: it's mobocracy, and it's the sort of appeal to
the least common denominator that got your country involved in a war
that my country had to help you get out of.

How are you guys going to pass AP Computer Science for USA schools if
you think in C?

<QUOTE PREVIOUSPOST="
&gt; &gt; Taking a cue from your Fearless Leaders, you decided to find a
&gt; &gt; minority, here of one, and of course it was the mere teacher, wasn't
&gt; &gt; it.

&gt; You have the answer above, Herr Troll Leader.
">

Your only input, as far as I can tell, is that the guy was disliked by
the other teachers. You may find in later life that they were right
and he was wrong. Or, you may find yourself driving a cab in Chicago,
unable to get hired as a programmer.

The point is that you and your fellow students should not have been
the one to make the decision.

<QUOTE PREVIOUSPOST="
&gt; &gt; How could you even know he was &quot;so bad&quot;? You're the student: he (was)
&gt; &gt; the teacher.

&gt; He was bad. He had asshole attitude to students and looked at them like
&gt; lower human race since he is physician, and &quot;he must teach us programming
&gt; basics&quot;.
">

Back in the Sixties, we despised all teachers as a general rule. My
first computer science teacher couldn't get the Fortran compiler
working (I did so myself a year later), and the campus was on strike
because of the US war in SE Asia. Nonetheless, I learned on my own and
didn't blame the world for my problems.

You have a &quot;consumerist&quot; attitude towards education in which you don't
suspend judgement on the teacher and this means, IMO, that you are
going to stumble from switch statement to bubble sort.

Did you talk back to the teacher and ask him to change, tough guy?
This would have been better than going behind his back if that's what
you did.

<QUOTE PREVIOUSPOST="
&gt; &gt; Did he make mistakes? And was he himself so terrorized by a society
&gt; &gt; which has so discouraged dialogue that he discouraged your criticism?
&gt; &gt; Did you find the mistakes? Why didn't you make this part of the
&gt; &gt; learning effort?

&gt; Yes, he made a lot of mistakes. Board sent him to private classes of
&gt; something like &quot;learn how to teach properly&quot; but that didn't help him
&gt; noticeably.
">

Is there really one way of how to teach properly? And are you certain
you guys know how to learn properly? When I discovered in my CS class
in 1970 that Sherman's &quot;Programming and Coding for Digital Computers&quot;
covered the IBM 7090 fixed word length mainframe and had no content
whatsoever about the decimal and variable word length IBM 1401 that we
had to use, I didn't whine about the teacher. No, I wrote snail mail
to IBM and two weeks later got The IBM 1401 Reference Manual.

<QUOTE PREVIOUSPOST="
&gt; &gt; Even if the teacher was a bonehead, he could have at least told you a
&gt; &gt; little secret about bubble sort, homeboy: that it seems to work for
&gt; &gt; small test volumes but slows to a crawl in the real world.

&gt; No, he didn't told us that. Believe it or not.
">

Maybe he was going to.

Think about how it works. The basic implementation almost &quot;squares&quot;
the number of entries by passing over them repeatedly, all the way
until there are no exchanges (in a slight improvement where the basic
algorithm squares the entries), and any arbitrary element takes a very
long while to get to its final position. Whereas in the quicksort the
probability of any arbitrary element reaching its final position early
in the game is high, and increases for each iteration as the bins get
smaller each time by one half.

If the guy was presenting the bubble sort as a real sorting algorithm
this was a mistake on his part, but not warranting termination. In
halfway decent CS classes, it is presented as a limit case and how not
to sort.

<QUOTE PREVIOUSPOST="
&gt; &gt; Hint: write a procedure to divide the items to be sorted into two
&gt; &gt; bins, one to the left of a selected item (can be any item, initially,
&gt; &gt; such as the first) such that all items in the bin on the left are less
&gt; &gt; than the selected item, and that all items on the right are greater.

&gt; &gt; Then redo the above for the left bin. Then redo it for the right bin.
&gt; &gt; Continue until you run out of things to do and you're done.

&gt; Finally end of trolling part.
">

I'm not trolling you, homeboy. I am saying that you and your
classmates' behavior is ruining your chances of learning CS. In
another post, I've provided you with the code for partition exchange.

<QUOTE PREVIOUSPOST="
&gt; &gt; What's interesting is that this &quot;quicksort&quot; algorithm was probably
&gt; &gt; repeatedly invented by your forefathers on farms and factories to sort
&gt; &gt; apples and ingots but you're so busy hounding your teachers for not
&gt; &gt; transforming you into successful western Yuppies overnight that you've
&gt; &gt; forgotten how to learn.

&gt; Oh, you are back.

&gt; &gt; I don't mind your bad Croatian. I don't think you had the right to get
&gt; &gt; a teacher fired because you don't know the subject. This shit came out
&gt; &gt; of the Chinese Cultural Revolution and the Nazi era.

&gt; Oh, you are back with even better shit now.
">

&quot;Nothing is related to anything else&quot; and &quot;forget the past&quot; may be the
content of Croatian education. I think it's a mistake.

<QUOTE PREVIOUSPOST="
&gt; &gt; If I have misunderstood the situation, my apologies. But if you got a
&gt; &gt; teacher fired, you're yet another mob.

&gt; :-) It is funny that you have written a enermous amount of monologue shit
&gt; and now, you came with &quot;If I have misunderstood&quot;.

&gt; Lovely.
">

Nothing you have posted has changed my mind. You're not qualified to
get a teacher fired, and you got a teacher fired.

<QUOTE PREVIOUSPOST="
&gt; Now, put your finger right in your worn ass and fuck off from here in
&gt; triplejumps and leave this newsgroup to the people who like to share
&gt; experiences and show somebody little altruism to prove themselves that they
&gt; are a good people. Something that you shall never learn with this approach
&gt; to the tematics and life generally.
">

I'm not scared of you, homeboy. I'm just saying that students can't
judge teachers. If they are not learning or don't have the tools to
learn, the people they need to speak to are the administrators and
wealthy alumni of their school.

My first CS teacher could not as I have said even provide us with a
working Fortran compiler; a year later, working as a programmer, I
discovered and fixed the problem in machine language. But we were at
the time busy challenging not easy targets such as teachers. We were
asking our university administration to take a stand against the
United States when it illegally expanded an illegal war into
Cambodia.

If we flunked out, we were headed for the combat zone. This may have
been the case in 1994 for your elder brothers but it isn't the case
now. Nonetheless, we didn't attack teachers.

It didn't occur to us to complain about &quot;teaching style&quot; because what
mattered to us was getting the substance of whatever it was we were
learning. The teacher in my CS class started us out on machine
language and then built us up to assembler, but was stopped when the
computer centre was unable to provide working Fortran.

In
...
read more »
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-05T05:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
&gt; On Feb 5, 1:01 am, &quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote:
&gt;&gt; spinoza1111 wrote:
&gt;&gt;&gt; On Feb 4, 2:28 am, &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote:
&gt;&gt;&gt;&gt; I am looking at switch case usage and bubblesort?

&gt;&gt;&gt; If you use the bubble sort, your application may be too slow to
&gt;&gt;&gt; manage realistic amounts of news, and it appears you ganged up on
&gt;&gt;&gt; your

&gt;&gt; &lt;snip sort code&gt;

&gt;&gt; Yes that's pretty fast, although up to N=1000, I could not detect mu

&gt; Hint: draw the curve for x=y**2 or draw the curve for x=log(y) and
&gt; rotate it 90 degrees.
">

Well, increasing N by x10 will I guess increase the Time by x100. But at
what levels of N could it still be useful?

I'd made a claim in this thread that bubble sort's speed might be acceptable
for N in the hundreds. My test (on simple memory-based data and on my
machine) showed this could well be true.

I'd also suggested sorting the data in-place (we don't know how the data is
stored, it could be read-only, or too big to move around), introducing a
slight twist which in the dozen lines of a bubble sort could be easier to
appreciate before attempting a quicksort solution.

--
Bart
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2008-02-05T07:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote in message
&gt; I'd made a claim in this thread that bubble sort's speed might be
&gt; acceptable
&gt; for N in the hundreds. My test (on simple memory-based data and on my
&gt; machine) showed this could well be true.
">

Generally if the number of operations is trivial, you'll start to notice an
N^2 algorithm at N = 1000. It means 1 million operations, or say 100 million
machine instructions, which is a fraction of a second on a 3GHz machine.
You'll just notice the screen flicker as it updates.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-05T10:56:00 </POSTDATE>
On Feb 5, 8:01 pm, &quot;Malcolm McLean&quot; &lt;regniz ... @btinternet.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote in message
&gt; &gt; I'd made a claim in this thread that bubble sort's speed might be
&gt; &gt; acceptable
&gt; &gt; for N in the hundreds. My test (on simple memory-based data and on my
&gt; &gt; machine) showed this could well be true.

&gt; Generally if the number of operations is trivial, you'll start to notice an
&gt; N^2 algorithm at N = 1000. It means 1 million operations, or say 100 million
&gt; machine instructions, which is a fraction of a second on a 3GHz machine.
&gt; You'll just notice the screen flicker as it updates.
">

What you won't notice is the way the module using bubble sort is an
invisible time sink. Sure, when you measure the time, it seems
trivial. But when the code exists in a multiprocessing system, it may
very well cause such irritating phenomena such as apparently frozen
progress reports in completely &quot;unrelated&quot; applications...that are
waiting for the Bubble Sort Kid's code to release the single CPU.

What's interesting is how excited people have gotten about truly de
minimis performance issues while claiming, in practice, that an N^2
algorithm such as tbe bubble sort should be given a free pass because
it seems, oh, so very simple. Sure, it's simple, so simple that in
implementing it you learn nothing of value.

&quot;Above all, do no harm&quot; would seem to indicate that you avoid the
bubble sort since in practice the number of elements could exceed
1000, and the bubble sort would affect overall performance without
ever being detected, as the culprit.

I've used order N^2 sorts, but I've used the interchange sort which is
closer to N^2/2. Not much of an improvement.

In modern, which is to say object oriented systems, sorts can be
provided once and for all for any array of any type by using generic
parameters. Which would seem to imply that sort should be taught
starting with quick sort, because in implementing it you do a
recursive call.

Guys like Ivica's teacher are thrown in secondary schools and
technical colleges to the wolves to teach useless techniques to
students who might never need to sort at all. Nobody, not the
administration and assuredly not the students, seem to have a handle
on what exactly should be taught. The teacher is given some
&quot;materials&quot; prepared by some former gnome and the students sense their
uselessness.

<QUOTE PREVIOUSPOST="
&gt; --
&gt; Free games and programming goodies. http://www.personal.leeds.ac.uk/~bgy1mm
">
</POST>
<POST>
<POSTER> Julienne Walker &lt;happyfro...@hotmail.com&gt; </POSTER>
<POSTDATE> 2008-02-05T11:20:00 </POSTDATE>
On Feb 5, 10:56 am, spinoza1111 &lt;spinoza1 ... @yahoo.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; What's interesting is how excited people have gotten about truly de
&gt; minimis performance issues while claiming, in practice, that an N^2
&gt; algorithm such as tbe bubble sort should be given a free pass because
&gt; it seems, oh, so very simple. Sure, it's simple, so simple that in
&gt; implementing it you learn nothing of value.
">

Learning bubble sort can teach you a lot about algorithms. For
example, you can use bubble sort as a simple implementation for adding
step-based execution and performance analysis. It's a simple algorithm
for introducing asymptotic notation and time complexity. It's also an
immediately useful exercise that covers non-trivial loop and array
logic, modularization, and comparison based sorting. I'd hardly call
that &quot;nothing of value&quot;.

Keep in mind that those learning bubble sort are likely to be very new
to programming, so while implementing the algorithm won't teach *you*
anything, it's very instructive to a less experienced programmer.
Naturally this is rather dependent on the teacher understanding these
lessons and guiding his or her students into learning them.

<QUOTE PREVIOUSPOST="
&gt; In modern, which is to say object oriented systems, sorts can be
&gt; provided once and for all for any array of any type by using generic
&gt; parameters. Which would seem to imply that sort should be taught
&gt; starting with quick sort, because in implementing it you do a
&gt; recursive call.
">

I'm not sure I understand how you used &quot;object oriented systems&quot; and
&quot;using generic parameters&quot; to reach the conclusion of quicksort should
be taught because it uses a recursive call. I also disagree that
quicksort should be the first sort taught to a student. You'd have to
wait until after recursion was introduced (quicksort is too
complicated to be an introduction to recursion), and even then it's an
extremely subtle algorithm that's better suited to students who have
had experience with simpler sorting algorithms.

In an ideal situation I (as the teacher) would give each student a
list of numbers and ask them to put it in order. That would give me an
idea of what sorting algorithm they think in and introduce them to the
simplest algorithm that implements that technique.

For example, I think in selections, so I would find selection sort to
be the easiest to learn as my first sort. I remember bubble sort
confused the hell out of me because I think in selection and not
exchange. I had similar difficulties with insertion sort, shell sort,
and quicksort, but I picked up heap sort without any effort at all. So
in my experience, the best sort to teach first is the one that the
student is most likely to identify with.

I'd wager that the two algorithms born of that trick would be
selection sort and insertion sort, both of which are very simple and a
good stepping stone for moving into more efficient techniques.

-Jul
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2008-02-05T11:44:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;spinoza1111&quot; &lt;spinoza1 ... @yahoo.com&gt; wrote in message
&gt;In modern, which is to say object oriented systems, sorts can be
&gt;provided once and for all for any array of any type by using generic
&gt;parameters. Which would seem to imply that sort should be taught
&gt;starting with quick sort, because in implementing it you do a
&gt;recursive call.
">

Oddly enough, sorting is where many object-oriented languages fall down. The
sort demands some sort of &quot;comparison&quot; interface. This may be achieved by
overloading the &gt; and = (==) operators, or by providing a special interface.

The problem is we often want to sort with different comparators. For
instnace, in a dictionary I want to sort string alpahabetically, or to be
strict, by character coding, because I want comparisons to be fast. However
if I'm sorting a list of filenames for user disply, I want foo1.01 to be
immediately after foo1.00, similarly for foo10.01 and foo100.3 to be in
number rank.

C's qsort() interface means that all is required is a custom comparator
function. It's far more flexible than trying to code up comparator
interfaces.

<QUOTE PREVIOUSPOST="
&gt;Guys like Ivica's teacher are thrown in secondary schools and
&gt;technical colleges to the wolves to teach useless techniques to
&gt;students who might never need to sort at all. Nobody, not the
&gt;administration and assuredly not the students, seem to have a handle
&gt;on what exactly should be taught. The teacher is given some
&gt;&quot;materials&quot; prepared by some former gnome and the students sense their
&gt;uselessness/
">

There's a huge problem about what exactly should go in computer science
classes, even whether it shold be a school or university subject at all. I
think most people would agree that sorting is sufficiently fundamental to
require that all students are familiar with it. That's not quite the same
thing as saying that sorting should be taught.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> Willem &lt;wil...@stack.nl&gt; </POSTER>
<POSTDATE> 2008-02-05T12:21:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
">

) On Feb 5, 1:49 am, Willem &lt;wil ... @stack.nl&gt; wrote:
)&gt; spinoza1111wrote:
)&gt;
)&gt; ) ..., there is a morally significant difference between what you,
)&gt; ) Heathfield, Howard et al. do on the one hand, and what people like
)&gt; ) McLean, Bacarisse, and Andy do.
)&gt;
)&gt; They weren't there the last time you vandalized this newsgroup.
)
) Sure they were. If you mean McLean, Bacarisse and Andy, they all
) responded to the thread I started on Beautiful Code early last month.

I heaped your vandalizing these last months into one, and was actually
referring to the previous time when you mucked up this newsgroup for a
couple of months before suddenly disappearing again.

SaSW, Willem
--
Disclaimer: I am in no way responsible for any of the statements
made in the above text. For all I know I might be
drugged or something..
No I'm not paranoid. You all think I'm paranoid, don't you !
#EOT
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-05T14:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
spinoza1111 wrote:
&gt; On Feb 5, 8:01 pm, &quot;Malcolm McLean&quot; &lt;regniz ... @btinternet.com&gt; wrote:
&gt;&gt; &quot;Bartc&quot; &lt;b ... @freeuk.com&gt; wrote in message
&gt;&gt;&gt; I'd made a claim in this thread that bubble sort's speed might be
&gt;&gt;&gt; acceptable
&gt;&gt;&gt; for N in the hundreds. My test (on simple memory-based data and on
&gt;&gt;&gt; my machine) showed this could well be true.

&gt;&gt; Generally if the number of operations is trivial, you'll start to
&gt;&gt; notice an N^2 algorithm at N = 1000. It means 1 million operations,
&gt;&gt; or say 100 million machine instructions, which is a fraction of a
&gt;&gt; second on a 3GHz machine. You'll just notice the screen flicker as
&gt;&gt; it updates.

&gt; What you won't notice is the way the module using bubble sort is an
&gt; invisible time sink. Sure, when you measure the time, it seems
&gt; trivial. But when the code exists in a multiprocessing system, it may
&gt; very well cause such irritating phenomena such as apparently frozen
&gt; progress reports in completely &quot;unrelated&quot; applications...
">

You can say the same about lots of programming practices, like the use of
interpreted languages (Python, Ruby,...). However you can argue one benefit
of a modern fast machine is the luxury of using such a language, or
occasionally spending 7ms on a bubble sort instead of 300us.

--
Bart
</POST>
<POST>
<POSTER> &quot;Ivica&quot; &lt;prljavi_blu...@hi.t-com.hr&gt; </POSTER>
<POSTDATE> 2008-02-05T15:28:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
">

news:fo514c$li8$1@ss408.t-com.hr ...

<QUOTE PREVIOUSPOST="
&gt;  cut
">

Here is some nasty code, I've translated it from Croatian. Hope it makes
sense.

However, sorting looks pretty nasty and it's written badly. Any suggestions
in changing?
I am stuck with the deadline, only tomorrow is left for me for having fun
with this code.

Thanks in advance. (even to the &quot;now filtered spinoza moron&quot;)

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAXLENGTH 20
#define elementtype News
#define N 9                //number of news

typedef struct {
int ID;
char name[60];
char text[500];      //structure
int read;
} News;

typedef struct {
int last;
elementtype elements[MAXLENGTH];

<QUOTE PREVIOUSPOST="
} LIST;
">

void bubblesort(int *array){
int i,j,k;
for (i=0; i&lt;N; i++){
for (j=N-1; j&gt;i; j--){
if (array[j-1]&lt;array[j]){     //Bubble sort
k=array[j];
array[j]=array[j-1];
array[j-1]=k;
}
}
}

<QUOTE PREVIOUSPOST="
}
">

int main()
{
int n;                  // how many times we will allow analysis before
reading
int decision;

News new1 = {1,&quot;heading 1.&quot;, &quot;body 1&quot;};

News new2 = {2,&quot;heading 2.&quot;, &quot;body 2&quot;};

News new3 = {3,&quot;Heading 3.&quot;, &quot;body 3&quot;};

News new4 = {4,&quot;heading 4.&quot;, &quot;body 4&quot;};

News new5 = {5,&quot;heading 5.&quot;, &quot;body 5&quot;};

News new6 = {6,&quot;heading 6.&quot;, &quot;body 6&quot;};

News new7 = {7,&quot;Heading 7.&quot;, &quot;body 7&quot;};

News new8 = {8,&quot;Heading 8.&quot;, &quot;body 8&quot;};

News new9 = {9,&quot;heading 9.&quot;, &quot;body 9&quot;};

printf(&quot;\t\t\tWelcome to the news sorting!\n\n\n\n&quot;);

for (n=0;n&lt;15;n++){
printf(&quot;%d--&gt;  %s\n&quot;, new1.ID, new1.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new2.ID, new2.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new3.ID, new3.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new4.ID, new4.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new5.ID, new5.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new6.ID, new6.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new7.ID, new7.name,0);
printf(&quot;%d--&gt;  %s\n&quot;, new8.ID, new8.name,0);
printf(&quot;%d--&gt;  %s\n\n&quot;, new9.ID, new9.name,0);
printf(&quot;Enter number + ENTER for reading: &quot;);
scanf(&quot;%d&quot;,&amp;decision);
if (decision==1){
printf(&quot;---------------------------------------\n%s\n&quot;,
new1.text);
new1.read++;}
if (decision==2){
printf(&quot;---------------------------------------\n%s\n&quot;,
new2.text);
new2.read++;}
if (decision==3){
printf(&quot;---------------------------------------\n%s\n&quot;,
new3.text);
new3.read++;}
if (decision==4){
printf(&quot;---------------------------------------\n%s\n&quot;,
new4.text);
new4.read++;}
if (decision==5){
printf(&quot;---------------------------------------\n%s\n&quot;,
new5.text);
new5.read++;}
if (decision==6){
printf(&quot;---------------------------------------\n%s\n&quot;,
new6.text);
new6.read++;}
if (decision==7){
printf(&quot;---------------------------------------\n%s\n&quot;,
new7.text);
new7.read++;}
if (decision==8){
printf(&quot;---------------------------------------\n%s\n&quot;,
new8.text);
new8.read++;}
if (decision==9){
printf(&quot;---------------------------------------\n%s\n&quot;,
new9.text);
new9.read++;}

system(&quot;pause&quot;);
system(&quot;cls&quot;);              }

int array[N]={new1.read, new2.read, new3.read, new4.read, new5.read,
new6.read, new7.read, new8.read, new8.read};

bubblesort(array); // call bubblesort

//Most read news-------------------------------
if (new1.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new1.name);}
if (new2.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new2.name);}
if (new3.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new3.name);}
if (new4.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new4.name);}
if (new5.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new5.name);}
if (new6.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new5.name);}
if (new7.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new7.name);}
if (new8.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new8.name);}
if (new9.read==array[0]){
printf(&quot;Most read news is:\t%s&quot;, new9.name);}
//-------------------------------------------------

printf(&quot;\n&quot;);

//2. Second most read news-------------------------------
if (new1.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new1.name);}
if (new2.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new2.name);}
if (new3.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new3.name);}
if (new4.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new4.name);}
if (new5.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new5.name);}
if (new6.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new6.name);}
if (new7.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new7.name);}
if (new8.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new8.name);}
if (new9.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new9.name);}
//-------------------------------------------------

printf(&quot;\n&quot;);

//3. most read news-------------------------------
if (new1.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new1.name);}
if (new2.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new2.name);}
if (new3.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new3.name);}
if (new4.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new4.name);}
if (new5.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new5.name);}
if (new6.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new6.name);}
if (new7.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new7.name);}
if (new8.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new8.name);}
if (new9.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new9.name);}
//-------------------------------------------------

printf(&quot;\n\nDiffernce between the TOP news and one in the middle is:
%d - %d = %d&quot;, array[0], array[4], array[0] - array[4]);

printf(&quot;\n\n&quot;);
system(&quot;pause&quot;);
return 0;

<QUOTE PREVIOUSPOST="
}
">
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-05T16:23:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
">

news:foagu1$pkc$1@ss408.t-com.hr ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
&gt; news:fo514c$li8$1@ss408.t-com.hr ...
&gt;&gt;  cut

&gt; Here is some nasty code, I've translated it from Croatian. Hope it makes
&gt; sense.

&gt; However, sorting looks pretty nasty and it's written badly. Any
&gt; suggestions in changing?
&gt; I am stuck with the deadline, only tomorrow is left for me for having fun
&gt; with this code.

&gt; Thanks in advance. (even to the &quot;now filtered spinoza moron&quot;)
">

(Suggest you also submit it to comp.lang.c where the C language experts
live, with
some background as to what this is meant to do.)

I'm no C expert but I have these comments:

* You're listing each item of data separately. I'm sure you are supposed to
group these into an array (array of structs).

* You are using N=9 and duplicating code in several places by N times.
Clearly this is not scaleable (imagine N=900). I think you need to use loops
and arrays more.

* You are extracting the .read values into an array and sorting that. Fine.
But the sorted array then loses it's link with that item of news (so
array[0] contains the most read, but which news item is that?). Maybe sort
the actual sort items, or sort an index array instead, based on the values
of .read.

* This is clearly not finished but there was no way to break out of the loop
asking me for 1 to 9.

* Also initialisation of array[N] didn't work on my C compiler (but it
presumably works on yours so maybe not a problem). But, better to set up
array[N] with a loop.

--
Bart
</POST>
<POST>
<POSTER> &quot;Stephen Howe&quot; &lt;sjhoweATdialDOTpipexDOTcom&gt; </POSTER>
<POSTDATE> 2008-02-05T17:37:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt;&gt; &gt; I am looking at switch case usage and bubblesort?
&gt;&gt; If you use the bubble sort, your application may be too slow to manage
&gt;&gt; realistic amounts of news, and it appears you ganged up on your
&gt;&gt; instructor and got rid of him before you could learn about the
&gt;&gt; relative efficiency of sorting algorithms. Bubble sorting is how not
&gt;&gt; to sort.
">

But it is instructive to look at despite being O(N * N)
1) If you start making passes over N - 1  elements each time round until
sorted
2) You can decrease each pass by 1 on realising the nextmost maximum element
will be in the correct position.
3) You can note where the last interchange was and sort up to that.

4) And then you can do the cocktail variation on puts the nextmost minimum
element on a reverse pass.

5) Finally Bubble sort is not bad if only k maximum elements are out of
place.
k passes are required.

Stephen Howe
</POST>
<POST>
<POSTER> Ben Bacarisse &lt;ben.use...@bsb.me.uk&gt; </POSTER>
<POSTDATE> 2008-02-05T18:42:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
&gt; news:fo514c$li8$1@ss408.t-com.hr ...
&gt; Here is some nasty code, I've translated it from Croatian. Hope it makes
&gt; sense.

&gt; However, sorting looks pretty nasty and it's written badly. Any suggestions
&gt; in changing?
">

The sorting code is fine, it is the rest that needs work.  OK, I'd
choose another sort, but that is not really the problem.  Looking at
the code, I don't think you understand arrays yet.  The deadline means
that learning about arrays may have to wait, but don't put it off --
get a good book (do you have access to a good library?) and work
through some examples of using arrays.

<QUOTE PREVIOUSPOST="
&gt; I am stuck with the deadline, only tomorrow is left for me for having fun
&gt; with this code.

&gt; Thanks in advance. (even to the &quot;now filtered spinoza moron&quot;)

&gt; #include &lt;stdlib.h&gt;
&gt; #include &lt;stdio.h&gt;

&gt; #define MAXLENGTH 20
&gt; #define elementtype News
">

Macros should have BIG_NAMES so everyone knows.

<QUOTE PREVIOUSPOST="
&gt; #define N 9                //number of news

&gt; typedef struct {
&gt;        int ID;
&gt;        char name[60];
&gt;        char text[500];      //structure
&gt;        int read;
&gt;        } News;

&gt; typedef struct {
&gt; int last;
&gt; elementtype elements[MAXLENGTH];
&gt; } LIST;
">

This is confusing: elementype is a macro defined to be News with is
typedef for a struct.  It is almost like you want to hide the type.
I'd just give the struct a tag and use that so everyone knows what is
going on:

struct news { ... };

struct list {
int last;
struct news elements[MAXLENGTH];

<QUOTE PREVIOUSPOST="
} LIST;
">

You don't get extra marks (in my class) for using more language
features -- especially if they obscure things.  Anyway, it turns out
you don't use this type at all, so you should get rid of it.

<QUOTE PREVIOUSPOST="
&gt; void bubblesort(int *array){
&gt;     int i,j,k;
&gt;     for (i=0; i&lt;N; i++){
&gt;         for (j=N-1; j&gt;i; j--){
&gt;             if (array[j-1]&lt;array[j]){     //Bubble sort
&gt;               k=array[j];
&gt;               array[j]=array[j-1];
&gt;               array[j-1]=k;
&gt;               }
&gt;         }
&gt;     }
&gt; }
">

OK, but this looks like it is right out of a book (or web site).  Why?
Because if you could have written it, why not do the simpler array
manipulations required by the code below?  I am not getting at you,
just giving you a teacher's-eye view of your work.

Another give-away is that the function is not properly parametrised --
you have written a function (good) that can sort any array of ints
(good) provided it has N == 9 elements (bad).  You should pass in the
size of the array.

<QUOTE PREVIOUSPOST="
&gt; int main()
&gt; {
&gt;     int n;                  // how many times we will allow analysis before
&gt; reading
&gt;     int decision;
&gt;     News new1 = {1,&quot;heading 1.&quot;, &quot;body 1&quot;};
&gt;     News new2 = {2,&quot;heading 2.&quot;, &quot;body 2&quot;};
&gt;     News new3 = {3,&quot;Heading 3.&quot;, &quot;body 3&quot;};
&gt;     News new4 = {4,&quot;heading 4.&quot;, &quot;body 4&quot;};
&gt;     News new5 = {5,&quot;heading 5.&quot;, &quot;body 5&quot;};
&gt;     News new6 = {6,&quot;heading 6.&quot;, &quot;body 6&quot;};
&gt;     News new7 = {7,&quot;Heading 7.&quot;, &quot;body 7&quot;};
&gt;     News new8 = {8,&quot;Heading 8.&quot;, &quot;body 8&quot;};
&gt;     News new9 = {9,&quot;heading 9.&quot;, &quot;body 9&quot;};
">

We have computers so we don't have to write this kind of thing!  Every
time you find your self writing repetitive code you should put it in a
function (or at least wrap it up as the body of a loop).  I won't
repeat myself, but there a lots of example below.

<QUOTE PREVIOUSPOST="
&gt;     printf(&quot;\t\t\tWelcome to the news sorting!\n\n\n\n&quot;);

&gt;     for (n=0;n&lt;15;n++){
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new1.ID, new1.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new2.ID, new2.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new3.ID, new3.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new4.ID, new4.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new5.ID, new5.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new6.ID, new6.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new7.ID, new7.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n&quot;, new8.ID, new8.name,0);
&gt;        printf(&quot;%d--&gt;  %s\n\n&quot;, new9.ID, new9.name,0);
">

What is the extra 0 there for?

<QUOTE PREVIOUSPOST="
&gt;        printf(&quot;Enter number + ENTER for reading: &quot;);
&gt;        scanf(&quot;%d&quot;,&amp;decision);
&gt;         if (decision==1){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new1.text);
&gt;             new1.read++;}
&gt;         if (decision==2){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new2.text);
&gt;             new2.read++;}
&gt;         if (decision==3){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new3.text);
&gt;             new3.read++;}
&gt;         if (decision==4){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new4.text);
&gt;             new4.read++;}
&gt;         if (decision==5){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new5.text);
&gt;             new5.read++;}
&gt;         if (decision==6){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new6.text);
&gt;             new6.read++;}
&gt;         if (decision==7){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new7.text);
&gt;             new7.read++;}
&gt;         if (decision==8){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new8.text);
&gt;             new8.read++;}
&gt;         if (decision==9){
&gt;             printf(&quot;---------------------------------------\n%s\n&quot;,
&gt; new9.text);
&gt;             new9.read++;}

&gt;             system(&quot;pause&quot;);
&gt;             system(&quot;cls&quot;);              }
">

At this point I am thinking...  So the student can

<QUOTE PREVIOUSPOST="
&gt;     int array[N]={new1.read, new2.read, new3.read, new4.read, new5.read,
&gt; new6.read, new7.read, new8.read, new8.read};

&gt;     bubblesort(array); // call bubblesort
">

Classic redundant comment.  Comments should explain things for people
who know the language but not your mind.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;     //Most read news-------------------------------
&gt;     if (new1.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new1.name);}
&gt;     if (new2.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new2.name);}
&gt;     if (new3.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new3.name);}
&gt;     if (new4.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new4.name);}
&gt;     if (new5.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new5.name);}
&gt;     if (new6.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new5.name);}
&gt;     if (new7.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new7.name);}
&gt;     if (new8.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new8.name);}
&gt;     if (new9.read==array[0]){
&gt;          printf(&quot;Most read news is:\t%s&quot;, new9.name);}
&gt;     //-------------------------------------------------
">

This is repetitive again, but the real problem is a logical one.
Having sorted the list of number of times the news has been read you
have lost the linkage between that number and the news item itself so
you have to search the list again for the matching item (or items).

Ideally you should sort the list of news items themselves, or at least
something the references the news items.  A C programmer would choose
to sort an array of &quot;struct news *&quot; (pointers to news structures).
You then would have access to every part of the most-read as
news[0]-&gt;name, news[0]-&gt;read and so on.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;     printf(&quot;\n&quot;);

&gt;     //2. Second most read news-------------------------------
&gt;     if (new1.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new1.name);}
&gt;     if (new2.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new2.name);}
&gt;     if (new3.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new3.name);}
&gt;     if (new4.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new4.name);}
&gt;     if (new5.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new5.name);}
&gt;     if (new6.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new6.name);}
&gt;     if (new7.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new7.name);}
&gt;     if (new8.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new8.name);}
&gt;     if (new9.read==array[1]){
&gt;          printf(&quot;2. Most read news is:\t%s&quot;, new9.name);}
&gt;     //-------------------------------------------------

&gt;     printf(&quot;\n&quot;);

&gt;     //3. most read news-------------------------------
&gt;     if (new1.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new1.name);}
&gt;     if (new2.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new2.name);}
&gt;     if (new3.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new3.name);}
&gt;     if (new4.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new4.name);}
&gt;     if (new5.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new5.name);}
&gt;     if (new6.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new6.name);}
&gt;     if (new7.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new7.name);}
&gt;     if (new8.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new8.name);}
&gt;     if (new9.read==array[2]){
&gt;          printf(&quot;3. Most read news is:\t%s&quot;, new9.name);}
&gt;     //-------------------------------------------------

&gt;     printf(&quot;\n\nDiffernce between the TOP news and one in the middle is:
&gt; %d - %d = %d&quot;, array[0], array[4], array[0] - array[4]);

&gt;     printf(&quot;\n\n&quot;);
&gt;     system(&quot;pause&quot;);
">

Is there some real programming system that requires this sort of
thing?  When I run a program, I get to see the output and it stays
there!

<QUOTE PREVIOUSPOST="
&gt;     return 0;
&gt; }
">

--
Ben.
</POST>
<POST>
<POSTER> &quot;Ivica&quot; &lt;prljavi_blu...@hi.t-com.hr&gt; </POSTER>
<POSTDATE> 2008-02-05T19:32:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ben Bacarisse&quot; &lt;ben.use ... @bsb.me.uk&gt; wrote in message
">

news:87y79zynqs.fsf@bsb.me.uk ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt;&gt;     printf(&quot;\n\n&quot;);
&gt;&gt;     system(&quot;pause&quot;);

&gt; Is there some real programming system that requires this sort of
&gt; thing?  When I run a program, I get to see the output and it stays
&gt; there!
">

Since I'm in hurry right now I'll stick only to this part now.

Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing. I really dislike
that program but we must write in it.

When you start program it should give you the list of the news, then you
randomly choose news and it will give you output what news is the most read,
second most read and third most read.

Well, it looks bad. And to be honest, I simply don't know better. If you are
able to rewrite some stuff(even that bad repetitive stuff),  I'll send you
beer to your home address. :-)
</POST>
<POST>
<POSTER> Ben Bacarisse &lt;ben.use...@bsb.me.uk&gt; </POSTER>
<POSTDATE> 2008-02-05T20:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt; &quot;Ben Bacarisse&quot; &lt;ben.use ... @bsb.me.uk&gt; wrote in message
&gt; news:87y79zynqs.fsf@bsb.me.uk ...
&gt;&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt;&gt;&gt;     printf(&quot;\n\n&quot;);
&gt;&gt;&gt;     system(&quot;pause&quot;);

&gt;&gt; Is there some real programming system that requires this sort of
&gt;&gt; thing?  When I run a program, I get to see the output and it stays
&gt;&gt; there!

&gt; Since I'm in hurry right now I'll stick only to this part now.

&gt; Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing. I really dislike
&gt; that program but we must write in it.
">

So be it.  I am ashamed for my fellow programmers.

<QUOTE PREVIOUSPOST="
&gt; Well, it looks bad.
">

No, don't worry.  Most learning is slow.  If you want something fast
to learn, programming is not a good choice.

<QUOTE PREVIOUSPOST="
&gt; If you are
&gt; able to rewrite some stuff(even that bad repetitive stuff),  I'll send you
&gt; beer to your home address. :-)
">

That would just make us both feel bad.

--
Ben.
</POST>
<POST>
<POSTER> pete &lt;pfil...@mindspring.com&gt; </POSTER>
<POSTDATE> 2008-02-05T21:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ivica wrote:

&gt; &quot;Ben Bacarisse&quot; &lt;ben.use ... @bsb.me.uk&gt; wrote in message
&gt; news:87y79zynqs.fsf@bsb.me.uk ...
&gt; &gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt; &gt;&gt;     printf(&quot;\n\n&quot;);
&gt; &gt;&gt;     system(&quot;pause&quot;);

&gt; &gt; Is there some real programming system that requires this sort of
&gt; &gt; thing?  When I run a program, I get to see the output and it stays
&gt; &gt; there!

&gt; Since I'm in hurry right now I'll stick only to this part now.

&gt; Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing.
&gt; I really dislike that program but we must write in it.
">

If Bloodshed Dev C++ produces executable files,
then don't run your programs through your IDE.
Open another window or a console in the place
where your linker output goes to, and run them from there.
Then you won't have to use system pause.

--
pete
</POST>
<POST>
<POSTER> pete &lt;pfil...@mindspring.com&gt; </POSTER>
<POSTDATE> 2008-02-05T22:23:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Stephen Howe wrote:
&gt; But it is instructive to look at despite being O(N * N)
&gt; 1) If you start making passes over N - 1
&gt; elements each time round until sorted
&gt; 2) You can decrease each pass by 1
&gt; on realising the nextmost maximum element
&gt; will be in the correct position.
&gt; 3) You can note where the last interchange was and sort up to that.

&gt; 4) And then you can do the cocktail variation
&gt; on puts the nextmost minimum
&gt; element on a reverse pass.

&gt; 5) Finally Bubble sort is not bad
&gt; if only k maximum elements are out of place.
&gt; k passes are required.
">

It can do better depending on the order.
Bubble sort can sort this: {1,0,3,2,5,4,7,6,9,8}
where all of the elements are out of place,
into ascending order in one pass.

6) Bubble sort is a stable sort.

--
pete
</POST>
<POST>
<POSTER> CBFalconer &lt;cbfalco...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-05T23:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
pete wrote:
&gt; Ivica wrote:

... snip ...

&gt;&gt; Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing.
&gt;&gt; I really dislike that program but we must write in it.

&gt; If Bloodshed Dev C++ produces executable files, then don't run
&gt; your programs through your IDE.  Open another window or a
&gt; console in the place where your linker output goes to, and run
&gt; them from there.  Then you won't have to use system pause.
">

The problem is that most people today no longer have any idea of
how to use the command line.  I force a console window open on
start-up, and just leave it there for general access.  It takes
very few added resources.

--
[mail]: Chuck F (cbfalconer at maineline dot net)
[page]: &lt; http://cbfalconer.home.att.net &gt;
Try the download section.

--
Posted via a free Usenet account from http://www.teranews.com
</POST>
<POST>
<POSTER> CBFalconer &lt;cbfalco...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-05T23:28:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
pete wrote:

... snip ...

&gt; It can do better depending on the order.  Bubble sort can sort
&gt; this: {1,0,3,2,5,4,7,6,9,8} where all of the elements are out of
&gt; place, into ascending order in one pass.

&gt; 6) Bubble sort is a stable sort.
">

It is also O(n * n).  However mergesort is also stable, and is
always O(n Log n).  Bubble sort is to all practical purposes the
worst possible general sort.

--
[mail]: Chuck F (cbfalconer at maineline dot net)
[page]: &lt; http://cbfalconer.home.att.net &gt;
Try the download section.

--
Posted via a free Usenet account from http://www.teranews.com
</POST>
<POST>
<POSTER> Richard Heathfield &lt;r...@see.sig.invalid&gt; </POSTER>
<POSTDATE> 2008-02-06T02:42:00 </POSTDATE>
Ben Bacarisse said:

<QUOTE PREVIOUSPOST="
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
">

&lt;snip&gt;

<QUOTE PREVIOUSPOST="
&gt;&gt; Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing. I really
&gt;&gt; dislike that program but we must write in it.

&gt; So be it.  I am ashamed for my fellow programmers.
">

But it's not true! No C compiler *needs* you to have a system(&quot;pause&quot;)
thing in there. It sounds like the OP is simply running the program from
his IDE or from Windows Explorer, rather than from a console. In other
words, nobody has yet showed him how to run programs properly. Let's not
blame his implementation for that.

--
Richard Heathfield &lt; http://www.cpax.org.uk &gt;
Email: - http://www . +rjh@
Google users: &lt; http://www.cpax.org.uk/prg/writings/googly.php &gt;
&quot;Usenet is a strange place&quot; - dmr 29 July 1999
</POST>
<POST>
<POSTER> &quot;Clive D. W. Feather&quot; &lt;cl...@on-the-train.demon.co.uk&gt; </POSTER>
<POSTDATE> 2008-02-06T04:15:00 </POSTDATE>
In article
&lt;99cf437b-e8d3-4d3c-92cc-909fb9d85 ... @i12g2000prf.googlegroups.com&gt;,
spinoza1111 &lt;spinoza1 ... @yahoo.com&gt; writes

<QUOTE PREVIOUSPOST="
&gt;Bubble sorting is how not
&gt;to sort.

&gt;Here is a C example of a simple program that sorts a list of random
&gt;numbers using the method of exchanging between two bins (partition
&gt;exchange) that I mentioned in my first post.
">

An algorithm which most people know as &quot;quicksort&quot;, of course.

<QUOTE PREVIOUSPOST="
&gt;As I said, this algorithm grabs an arbitrary member and then compares
&gt;it to every other member, throwing each compared member into bin A or
&gt;bin B depending on whether it is greater than, or less than (or equal
&gt;to) the arbitrary member (called the pivot).
">

Actually, it doesn't. It grabs the member at the left end of the array
to be sorted. If the array is already sorted, this means that you end up
with an N^2 algorithm instead of an N log N one. About the only worse
choice you could have made is to use the one at the right end, since the
way you've coded it means that you'd also swap every single member of
the array with itself.

It is more usual to pick the middle of the array as the pivot, or even
to pick an element at random.

It is usual to point out that quicksort has this pathological behaviour
for certain inputs.

<QUOTE PREVIOUSPOST="
&gt;But when A and B are one cell, this means that A &lt;= pivot &lt; B for all
&gt;members because the two recursive calls you see in the code cover all
&gt;the values.
">

This makes no sense to me. If A or B are one cell, your code doesn't
attempt to sort them (since there's nothing to do).

<QUOTE PREVIOUSPOST="
&gt;But that means that the entire array is sorted in rather
&gt;less time than a bubble sort,
">

Actually, if the array is sorted before you start, your code will be
rather slower than a bubble sort. If it's in reverse order, it will be
much slower.

<QUOTE PREVIOUSPOST="
&gt;which maximizes the number of times an
&gt;entry must travel to get to its final position.
">

In some circumstances. There are others - as we'll see - where bubble
sort is actually a sensible thing to use.

<QUOTE PREVIOUSPOST="
&gt;For any arbitrary
&gt;entry, the probability of its having to move reduces each time the
&gt;quicksort is recursively called.
">

If the array is initially random, the probability that an entry has to
move is almost exactly 0.5 *at every stage*. This is because each entry
has a 50% chance of being greater than the pivot each time.

<QUOTE PREVIOUSPOST="
&gt;This is what intelligent workers might do on a farm when sorting
&gt;apples.
">

You are a patronising git at times.

<QUOTE PREVIOUSPOST="
&gt;They wouldn't use bubble sort. I think a programmer invented
&gt;that time sink.

&gt;Here is the code. Examine it in a monospace font such as Courier New.

&gt;// ***** Quicksort (partition exchange) example *****

&gt;#include &lt;stdio.h&gt;
&gt;#include &lt;stdlib.h&gt;

&gt;const int SIZE = 27;

&gt;int quicksortPartition
&gt;    (int intArray[],
&gt;     int intLeft,
&gt;     int intRight,
&gt;     int intPivotIndex)
">

I find this style difficult to read. The type of a variable is often the
least important thing about it. I know you love Hungarian notation, but
many of us find it merely hides the essentials in a morass of
unimportant detail. For example, &quot;intArray&quot; tells me *NOTHING* about the
parameter that I can't already tell from its declaration (no matter what
it is called, it's an int and it's an array). I feel that it would be
far better to name that parameter on the basis of what it *does*, such
as &quot;values&quot; or even (though I wouldn't do it myself) &quot;to_be_sorted&quot;.

Given your advocacy of object-oriented programming in the past, I am
extremely surprised that you force the data to be integers. It would be
far more sensible to abstract the type away. That is, at the top of the
program have &quot;typedef int datatype&quot; and declare the first parameter as
&quot;datatype values []&quot;.

Furthermore, the correct type to use for an index into an array is
size_t rather than int. Of course, since you blithely subtract 1 from
the index, you'll need to trap that special case. But you won't mind
doing that - after all, you were complaining the other day that (I
think) Brian Kernigan didn't do that but relied on his data being
zero-terminated.

What is the justification for making the index of the pivot a parameter
to this function? If you were choosing the pivot via separate code it
*might* be justified, but you don't - you pivot on the left hand value.
It would make the code far clearer if the choice of pivot was done
within the partition function. It would also make it easier for the
student to experiment with different choices, or for you to do mid-array
or random selection.

<QUOTE PREVIOUSPOST="
&gt;{
&gt;    int intPivotValue = intArray[intPivotIndex];
">

If this is meant to be educational code, then a comment of the form:

/* Move the pivot value out of the way at the right hand end */

would have been helpful. Comments further along would also be helpful;
for example, in the main loop you could point out how intStoreIndex and
intIndex1 partition the array into bin A, bin B, and unchecked data.

<QUOTE PREVIOUSPOST="
&gt;    intArray[intPivotIndex] = intArray[intRight];
&gt;    intArray[intRight] = intPivotValue;
">

I don't criticise your use of arrays and indices rather than pointers,
though many people would. In practice it's a matter of what you feel
comfortable with.

<QUOTE PREVIOUSPOST="
&gt;    int intStoreIndex = intLeft;
">

You can't do that! Declaring variables after the first line of
executable code is an invention of the evil corporation-controlled
standards bodies and is not part of True C before the
military-industrial complex perverted it.

To be precise, *I* added it to the 1999 C Standard. That is, I did all
the donkey work of writing the wording to allow it to be included,
including working out some nasty boundary cases (such as the interaction
with variable length arrays).

<QUOTE PREVIOUSPOST="
&gt;    int intIndex1;
&gt;    int intExchange;
&gt;    for (intIndex1 = intLeft;
&gt;         intIndex1 &lt; intRight;
&gt;         intIndex1++)
">

If you're going to surrender and use C99 features, then why not:

for (int intIndex1 = intLeft; intIndex1 &lt; intRight; intIndex1++)

? And just what information does the &quot;1&quot; provide? In fact, how does it
hurt to just call this &quot;idx&quot;? Or even, given the small size of the body,
&quot;i&quot;?

<QUOTE PREVIOUSPOST="
&gt;    {
&gt;        if (intArray[intIndex1] &lt;= intPivotValue)
&gt;        {
&gt;            intExchange = intArray[intIndex1];
">

Why don't you declare intExchange at this scope? Doing so reduces the
chance of it being misused by accident later.

<QUOTE PREVIOUSPOST="
&gt;            intArray[intIndex1] = intArray[intStoreIndex];
&gt;            intArray[intStoreIndex] = intExchange;
">

If your data type is anything bigger than a machine word, it is worth
bracketing this swap with &quot;if (intIndex1 != intStoreIndex)&quot;.

<QUOTE PREVIOUSPOST="
&gt;            intStoreIndex += 1;
">

Suddenly scared of the ++ operator?

<QUOTE PREVIOUSPOST="
&gt;        }
&gt;    }
">

This partitioning algorithm will work and suffices for teaching.
However, in practice it's far too inefficient. For example, if the left
element of the array is the second largest (e.g. array contents 9 1 2 3
4 5 6 7 8 10), then it does a bubble pass on the array (excluding the
last element), moving every single element down by one and shifting the
10 from left to right one cell at a time.

The standard way to implement the partition phase is:
* Swap the pivot item out of the way.
* Initialize pointer pL to the left element and pR to the right element.
* While pL is left of pR:
* Move pL right until it finds an element greater than the pivot.
* Move pR left until it finds an element less than the pivot.
* Swap the elements at pL and pR.
This does require careful coding, especially to deal with the boundary
cases.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;    intPivotValue = intArray[intStoreIndex];
&gt;    intArray[intStoreIndex] = intArray[intRight];
&gt;    intArray[intRight] = intPivotValue;
&gt;    return intStoreIndex;
&gt;}

&gt;void quicksort(int intArray[],
&gt;                  int intLeft,
&gt;               int intRight)
&gt;{
&gt;    if (intRight &gt; intLeft)
&gt;    {
&gt;        int intPivotNewIndex = quicksortPartition
&gt;                               (intArray,
&gt;                                intLeft,
&gt;                                intRight,
&gt;                                intLeft);
&gt;        quicksort(intArray,
&gt;                  intLeft,
&gt;                  intPivotNewIndex - 1);
&gt;        quicksort(intArray,
&gt;                  intPivotNewIndex + 1,
&gt;                  intRight);
&gt;    }
&gt;}
">

Again, if this is meant to be teaching code, it suffices. If it's meant
to be production code, it doesn't.

Firstly, you should determine which of the two partitions is the
smaller. That should be sorted using a recursive call, while the larger
one should be sorted in a loop.

void quicksort(int intArray[],
int intLeft,
int intRight)
{
while (intRight &gt; intLeft)
{
int intPivotNewIndex = quicksortPartition
(intArray,
intLeft,
intRight,
intLeft);
int leftwidth = intPivotNewIndex - 1 - intLeft;
int rightwidth = intRight - (intPivotNewIndex + 1);

if (leftwidth &lt; rightwidth)
{
quicksort(intArray,
intLeft,
intPivotNewIndex - 1);
intLeft = intPivotNewIndex + 1;
}
else
{
quicksort(intArray,
intPivotNewIndex + 1,
intRight);
intRight = intPivotNewIndex - 1;
}
}

<QUOTE PREVIOUSPOST="
}
">

Doing this guarantees that, no matter how bad things get, the depth of
recursion is never more than log N.

Secondly, when the bins get small the effort of partitioning and
recursion overwhelm the benefits of the technique. So it is common to
stop when the bin size gets down to around 5 (the exact size needs to be
found by experimentation on the platform in use). That is, the outer
test in the above code becomes:

if (intRight &gt; intLeft + 5)
or
while (intRight &gt; intLeft + 5)

Then, after the quicksort completely finishes, do a *BUBBLE SORT* on the
entire array. Since every element is within 5 places of where it
belongs, this will never need more than 5
...
read more »
</POST>
<POST>
<POSTER> &quot;Ivica&quot; &lt;prljavi_blu...@hi.t-com.hr&gt; </POSTER>
<POSTDATE> 2008-02-06T04:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ben Bacarisse&quot; &lt;ben.use ... @bsb.me.uk&gt; wrote in message
">

news:87lk5yzxwf.fsf@bsb.me.uk ...

<QUOTE PREVIOUSPOST="
&gt; That would just make us both feel bad.
">

Yes, I understand what are you getting at and what's the main reason for
this newsgroup but now, I have less than 24 hours to finish this or I'll be
in problems. That couldn't be so bad if I don't have to do some other stuff
too in this &quot;unhappy 24 hours&quot;.
</POST>
<POST>
<POSTER> spinoza1111 &lt;spinoza1...@yahoo.com&gt; </POSTER>
<POSTDATE> 2008-02-06T05:04:00 </POSTDATE>
On Feb 6, 5:15 pm, &quot;Clive D. W. Feather&quot; &lt;cl...@on-the-

<QUOTE PREVIOUSPOST="
train.demon.co.uk&gt; wrote:
&gt; In article
&gt; &lt;99cf437b-e8d3-4d3c-92cc-909fb9d85 ... @i12g2000prf.googlegroups.com&gt;,spinoza1111&lt;spinoza1 ... @yahoo.com&gt; writes

&gt; &gt;Bubble sorting is how not
&gt; &gt;to sort.

&gt; &gt;Here is a C example of a simple program that sorts a list of random
&gt; &gt;numbers using the method of exchanging between two bins (partition
&gt; &gt;exchange) that I mentioned in my first post.

&gt; An algorithm which most people know as &quot;quicksort&quot;, of course.
">

And many others prefer to call partition exchange because &quot;quicksort&quot;
sounds too commercial.

<QUOTE PREVIOUSPOST="
&gt; &gt;As I said, this algorithm grabs an arbitrary member and then compares
&gt; &gt;it to every other member, throwing each compared member into bin A or
&gt; &gt;bin B depending on whether it is greater than, or less than (or equal
&gt; &gt;to) the arbitrary member (called the pivot).

&gt; Actually, it doesn't. It grabs the member at the left end of the array
&gt; to be sorted. If the array is already sorted, this means that you end up
&gt; with an N^2 algorithm instead of an N log N one. About the only worse
&gt; choice you could have made is to use the one at the right end, since the
&gt; way you've coded it means that you'd also swap every single member of
&gt; the array with itself.

&gt; It is more usual to pick the middle of the array as the pivot, or even
&gt; to pick an element at random.
">

News flash. The array is unsorted. This means that choosing the left
end IS picking an element at random.

<QUOTE PREVIOUSPOST="
&gt; It is usual to point out that quicksort has this pathological behaviour
&gt; for certain inputs.
">

Thanks for saving me the trouble. It do.

<QUOTE PREVIOUSPOST="
&gt; &gt;But when A and B are one cell, this means that A &lt;= pivot &lt; B for all
&gt; &gt;members because the two recursive calls you see in the code cover all
&gt; &gt;the values.

&gt; This makes no sense to me. If A or B are one cell, your code doesn't
&gt; attempt to sort them (since there's nothing to do).
">

It makes no sense to you because you don't understand it. Yet. You
will. I am in the text giving a little peroration to show that that
the recursion gets down to one.

<QUOTE PREVIOUSPOST="
&gt; &gt;But that means that the entire array is sorted in rather
&gt; &gt;less time than a bubble sort,

&gt; Actually, if the array is sorted before you start, your code will be
&gt; rather slower than a bubble sort. If it's in reverse order, it will be
&gt; much slower.
">

True. This can however be checked.

<QUOTE PREVIOUSPOST="
&gt; &gt;which maximizes the number of times an
&gt; &gt;entry must travel to get to its final position.

&gt; In some circumstances. There are others - as we'll see - where bubble
&gt; sort is actually a sensible thing to use.

&gt; &gt;For any arbitrary
&gt; &gt;entry, the probability of its having to move reduces each time the
&gt; &gt;quicksort is recursively called.

&gt; If the array is initially random, the probability that an entry has to
&gt; move is almost exactly 0.5 *at every stage*. This is because each entry
&gt; has a 50% chance of being greater than the pivot each time.

&gt; &gt;This is what intelligent workers might do on a farm when sorting
&gt; &gt;apples.

&gt; You are a patronising git at times.
">

And so are you. Wiglaf was a Geat, wasn't he?

I remain by my contention that algorithms aren't invented by
mathematicians.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; &gt;They wouldn't use bubble sort. I think a programmer invented
&gt; &gt;that time sink.

&gt; &gt;Here is the code. Examine it in a monospace font such as Courier New.

&gt; &gt;// ***** Quicksort (partition exchange) example *****

&gt; &gt;#include &lt;stdio.h&gt;
&gt; &gt;#include &lt;stdlib.h&gt;

&gt; &gt;const int SIZE = 27;

&gt; &gt;int quicksortPartition
&gt; &gt;    (int intArray[],
&gt; &gt;     int intLeft,
&gt; &gt;     int intRight,
&gt; &gt;     int intPivotIndex)

&gt; I find this style difficult to read. The type of a variable is often the
&gt; least important thing about it. I know you love Hungarian notation, but
&gt; many of us find it merely hides the essentials in a morass of
&gt; unimportant detail. For example, &quot;intArray&quot; tells me *NOTHING* about the
&gt; parameter that I can't already tell from its declaration (no matter what
&gt; it is called, it's an int and it's an array). I feel that it would be
&gt; far better to name that parameter on the basis of what it *does*, such
&gt; as &quot;values&quot; or even (though I wouldn't do it myself) &quot;to_be_sorted&quot;.
">

&quot;The type of a variable is often the least important thing about it&quot;?
I should say that the type of a variable is the MOST important thing
about it.

<QUOTE PREVIOUSPOST="
&gt; Given your advocacy of object-oriented programming in the past, I am
&gt; extremely surprised that you force the data to be integers. It would be
&gt; far more sensible to abstract the type away. That is, at the top of the
&gt; program have &quot;typedef int datatype&quot; and declare the first parameter as
&gt; &quot;datatype values []&quot;.
">

That would be the version I am working on for my own further use. This
uses C Sharp. I don't think typedef is OO programming.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; Furthermore, the correct type to use for an index into an array is
&gt; size_t rather than int. Of course, since you blithely subtract 1 from
&gt; the index, you'll need to trap that special case. But you won't mind
&gt; doing that - after all, you were complaining the other day that (I
&gt; think) Brian Kernigan didn't do that but relied on his data being
&gt; zero-terminated.

&gt; What is the justification for making the index of the pivot a parameter
&gt; to this function? If you were choosing the pivot via separate code it
&gt; *might* be justified, but you don't - you pivot on the left hand value.
&gt; It would make the code far clearer if the choice of pivot was done
&gt; within the partition function. It would also make it easier for the
&gt; student to experiment with different choices, or for you to do mid-array
&gt; or random selection.

&gt; &gt;{
&gt; &gt;    int intPivotValue = intArray[intPivotIndex];

&gt; If this is meant to be educational code, then a comment of the form:

&gt;     /* Move the pivot value out of the way at the right hand end */

&gt; would have been helpful. Comments further along would also be helpful;
&gt; for example, in the main loop you could point out how intStoreIndex and
&gt; intIndex1 partition the array into bin A, bin B, and unchecked data.

&gt; &gt;    intArray[intPivotIndex] = intArray[intRight];
&gt; &gt;    intArray[intRight] = intPivotValue;

&gt; I don't criticise your use of arrays and indices rather than pointers,
&gt; though many people would. In practice it's a matter of what you feel
&gt; comfortable with.

&gt; &gt;    int intStoreIndex = intLeft;

&gt; You can't do that! Declaring variables after the first line of
&gt; executable code is an invention of the evil corporation-controlled
&gt; standards bodies and is not part of True C before the
&gt; military-industrial complex perverted it.
">

Git. Wiglaf was a Geat, wasn't he?

<QUOTE PREVIOUSPOST="
&gt; To be precise, *I* added it to the 1999 C Standard. That is, I did all
&gt; the donkey work of writing the wording to allow it to be included,
&gt; including working out some nasty boundary cases (such as the interaction
&gt; with variable length arrays).
">

Nice going (seriously).

<QUOTE PREVIOUSPOST="
&gt; &gt;    int intIndex1;
&gt; &gt;    int intExchange;
&gt; &gt;    for (intIndex1 = intLeft;
&gt; &gt;         intIndex1 &lt; intRight;
&gt; &gt;         intIndex1++)

&gt; If you're going to surrender and use C99 features, then why not:

&gt;     for (int intIndex1 = intLeft; intIndex1 &lt; intRight; intIndex1++)
">

I thought about doing this but was uncertain about the scope of
intIndex1.

<QUOTE PREVIOUSPOST="
&gt; ? And just what information does the &quot;1&quot; provide? In fact, how does it
&gt; hurt to just call this &quot;idx&quot;? Or even, given the small size of the body,
&gt; &quot;i&quot;?
">

Because some of us like to be able to read code aloud to the dog.
Seriously, I think Richard Harter's style, used on a memory allocation
package posted here a while back, was elegant. It used algebraically
short identifiers but conscientiously commented every line.

I prefer code that looks like English because this reassures me that
someone was programming on purpose. The comments in Harter's code
performed this function. In my own code, I would like it to be
possible for the code to be spoken or sung in mead-hall like Wiglaf
the Geat.

Seriously, every try talking about code over a long distance hookup
with a chap from India? If you can say the code and it uses simple
international words, the process tends to go smoother.

The &quot;1&quot; means it is the first index and more may be needed.

<QUOTE PREVIOUSPOST="
&gt; &gt;    {
&gt; &gt;        if (intArray[intIndex1] &lt;= intPivotValue)
&gt; &gt;        {
&gt; &gt;            intExchange = intArray[intIndex1];

&gt; Why don't you declare intExchange at this scope? Doing so reduces the
&gt; chance of it being misused by accident later.
">

I don't declare anything inside of a loop is why.

<QUOTE PREVIOUSPOST="
&gt; &gt;            intArray[intIndex1] = intArray[intStoreIndex];
&gt; &gt;            intArray[intStoreIndex] = intExchange;

&gt; If your data type is anything bigger than a machine word, it is worth
&gt; bracketing this swap with &quot;if (intIndex1 != intStoreIndex)&quot;.
">

Agreed.

<QUOTE PREVIOUSPOST="
&gt; &gt;            intStoreIndex += 1;

&gt; Suddenly scared of the ++ operator?
">

After learning about sync points, I'm terrified.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; &gt;        }
&gt; &gt;    }

&gt; This partitioning algorithm will work and suffices for teaching.
&gt; However, in practice it's far too inefficient. For example, if the left
&gt; element of the array is the second largest (e.g. array contents 9 1 2 3
&gt; 4 5 6 7 8 10), then it does a bubble pass on the array (excluding the
&gt; last element), moving every single element down by one and shifting the
&gt; 10 from left to right one cell at a time.

&gt; The standard way to implement the partition phase is:
&gt; * Swap the pivot item out of the way.
&gt; * Initialize pointer pL to the left element and pR to the right element.
&gt; * While pL is left of pR:
&gt;   * Move pL right until it finds an element greater than the pivot.
&gt;   * Move pR left until it finds an element less than the pivot.
&gt;   * Swap the elements at pL and pR.
&gt; This does require careful coding, especially to deal with the boundary
&gt; cases.
">

Thanks for your comments. They are illuminating. My copy of Sorting
and Searching was left in the United States when I left for Asia, and
...
read more »
</POST>
<POST>
<POSTER> &quot;Bartc&quot; &lt;b...@freeuk.com&gt; </POSTER>
<POSTDATE> 2008-02-06T06:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
">

news:foagu1$pkc$1@ss408.t-com.hr ...

<QUOTE PREVIOUSPOST="
&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; wrote in message
&gt; news:fo514c$li8$1@ss408.t-com.hr ...
&gt;&gt;  cut

&gt; Here is some nasty code, I've translated it from Croatian. Hope it makes
&gt; sense.

&gt; However, sorting looks pretty nasty and it's written badly. Any
&gt; suggestions in changing?
&gt; I am stuck with the deadline, only tomorrow is left for me for having fun
">

Sorry I thought the guys in comp.lang.c would be more helpful, but sometimes
they like to bicker amongst themselves.

I've changed the duplicated stuff in your code, and given the revised code
below. The new1...new9 are replaced by a single array newsarray[].

For finding out the 1st, 2nd, 3rd most read news, I've only changed the
first block, the rest are similar (the approach used is not ideal, but if
you are going to use it, might as well use a double nested loop, for
array[0], array[1], etc. Then you can show the top news 1000 if needed
without any extra code!).

Bart

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAXLENGTH 20
#define elementtype News
#define N 9                //number of news

typedef struct {
int ID;
char name[60];
char text[500];      //structure
int read;
} News;

typedef struct {
int last;
elementtype elements[MAXLENGTH];

<QUOTE PREVIOUSPOST="
} LIST;
">

void bubblesort(int *array){
int i,j,k;
for (i=0; i&lt;N; i++){
for (j=N-1; j&gt;i; j--){
if (array[j-1]&lt;array[j]){     //Bubble sort
k=array[j];
array[j]=array[j-1];
array[j-1]=k;
}
}
}

<QUOTE PREVIOUSPOST="
}
">

int main()
{
int n;                  /* how many times we will allow analysis before
reading */
int decision;
int i;

News newsarray[N] = {{1,&quot;heading 1.&quot;, &quot;body 1&quot;},
{2,&quot;heading 2.&quot;, &quot;body 2&quot;},
{3,&quot;Heading 3.&quot;, &quot;body 3&quot;},
{4,&quot;heading 4.&quot;, &quot;body 4&quot;},
{5,&quot;heading 5.&quot;, &quot;body 5&quot;},
{6,&quot;heading 6.&quot;, &quot;body 6&quot;},
{7,&quot;Heading 7.&quot;, &quot;body 7&quot;},
{8,&quot;Heading 8.&quot;, &quot;body 8&quot;},
{9,&quot;heading 9.&quot;, &quot;body 9&quot;}};

printf(&quot;\t\t\tWelcome to the news sorting!\n\n\n\n&quot;);

for (n=0;n&lt;15;n++){

for (i=0; i&lt;N; ++i)
printf(&quot;%d--&gt;  %s\n&quot;, newsarray[i].ID, newsarray[i].name,0);

printf(&quot;\n&quot;);
printf(&quot;Enter number + ENTER for reading: &quot;);
scanf(&quot;%d&quot;,&amp;decision);
if (decision==0) break; /* early exit */

--decision; /* change to 0-based */

printf(&quot;---------------------------------------\n%s\n&quot;,
newsarray[decision].text);
newsarray[decision].read++;

};
system(&quot;pause&quot;);
system(&quot;cls&quot;);

int array[N];
/*={new1.read, new2.read, new3.read, new4.read, new5.read, new6.read,
new7.read, new8.read, new8.read}; */

for (i=0; i&lt;N; ++i)
array[i]=newsarray[i].read;

bubblesort(array); // call bubblesort

//Most read news-------------------------------
for (i=0; i&lt;N; ++i);
if (newsarray[i].read==array[0])
{  printf(&quot;Most read news is:\t%s\n&quot;, newsarray[i].name);
//        break;
i=N; /* break not allowed for some reason */
};

/*
//2. Second most read news-------------------------------
if (new1.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new1.name);}
if (new2.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new2.name);}
if (new3.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new3.name);}
if (new4.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new4.name);}
if (new5.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new5.name);}
if (new6.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new6.name);}
if (new7.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new7.name);}
if (new8.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new8.name);}
if (new9.read==array[1]){
printf(&quot;2. Most read news is:\t%s&quot;, new9.name);}
//-------------------------------------------------

printf(&quot;\n&quot;);

//3. most read news-------------------------------
if (new1.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new1.name);}
if (new2.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new2.name);}
if (new3.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new3.name);}
if (new4.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new4.name);}
if (new5.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new5.name);}
if (new6.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new6.name);}
if (new7.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new7.name);}
if (new8.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new8.name);}
if (new9.read==array[2]){
printf(&quot;3. Most read news is:\t%s&quot;, new9.name);}
//-------------------------------------------------
*/

printf(&quot;\n\nDiffernce between the TOP news and one in the middle is:
%d - %d = %d&quot;, array[0], array[4], array[0] - array[4]);

printf(&quot;\n\n&quot;);

system(&quot;pause&quot;);
return 0;

<QUOTE PREVIOUSPOST="
}
">
</POST>
<POST>
<POSTER> Ben Bacarisse &lt;ben.use...@bsb.me.uk&gt; </POSTER>
<POSTDATE> 2008-02-06T06:13:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Richard Heathfield &lt;r ... @see.sig.invalid&gt; writes:
&gt; Ben Bacarisse said:

&gt;&gt; &quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:

&gt; &lt;snip&gt;

&gt;&gt;&gt; Yes, Bloodshed Dev C++ needs that &quot;system(&quot;pause&quot;);&quot; thing. I really
&gt;&gt;&gt; dislike that program but we must write in it.

&gt;&gt; So be it.  I am ashamed for my fellow programmers.

&gt; But it's not true! No C compiler *needs* you to have a system(&quot;pause&quot;)
&gt; thing in there.
">

I was (as I am sure you can tell) only half serious.  I was sure it is
not _required_ but had no way to check and thus could not argue the
point.  Thanks for making it clear.

--
Ben.
</POST>
<POST>
<POSTER> Ben Bacarisse &lt;ben.use...@bsb.me.uk&gt; </POSTER>
<POSTDATE> 2008-02-06T06:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ivica&quot; &lt;prljavi_blu ... @hi.t-com.hr&gt; writes:
&gt; &quot;Ben Bacarisse&quot; &lt;ben.use ... @bsb.me.uk&gt; wrote in message
&gt; news:87lk5yzxwf.fsf@bsb.me.uk ...
&gt;&gt; That would just make us both feel bad.

&gt; Yes, I understand what are you getting at and what's the main reason for
&gt; this newsgroup but now, I have less than 24 hours to finish this or I'll be
&gt; in problems.
">

Go to your the teacher/tutor/teaching assistant for help.  If there is
no system in place that enables you to help finishing off assignments,
make representation to the school that there should be.

If I was the lab teaching assistant on this assignment, seeing what
you had so far and the time left, I would suggest that you:

(1) Declare an array of N News items rather than declaring nine of
them.

(2) Initialise them just like you do at the moment (in other words
don't try at this late stage to set the text in them in a loop).

(3) Re-write the sort routine to take two integer arrays.  The new
array, lets call it 'index', start off with 0, 1, 2... N in it.  It is
this list of indexes that we sort (not the data in the other array).
*But* when we compare two items in the sort, rather than asking:

if (A[i] &lt; A[j])

we ask

if (A[index[i]] &lt; A[index[j]])

This used to be called &quot;sorting by detached keys&quot; (search for that).
Do you see what the effect is?

(4) You can then answer your &quot;top-five&quot; question much more easily
because after the sort, index[0] will hold the index of the most read
news item.

(5) If you have time, re-write the sort so you pass it the index array
and the array of news items directly (rather than the copied list of
number of times read).

(6) If you have time, initialise the news items in a more realistic
way, say be reading from a file.

--
Ben.
</POST>
<POST>
<POSTER> &quot;Malcolm McLean&quot; &lt;regniz...@btinternet.com&gt; </POSTER>
<POSTDATE> 2008-02-06T15:27:00 </POSTDATE>
&quot;Clive D. W. Feather&quot; &lt;cl ... @on-the-train.demon.co.uk&gt; wrote

<QUOTE PREVIOUSPOST="
&gt; Furthermore, the correct type to use for an index into an array is
&gt; size_t rather than int. Of course, since you blithely subtract 1 from
&gt; the index, you'll need to trap that special case.
">

I am campaigning for int to be 64 bit on 64 bit platforms, so this bit of
awkwardness will go away, at least until memory sizes start pushing the 2^63
byte barrier.

--
Free games and programming goodies.
http://www.personal.leeds.ac.uk/~bgy1mm
</POST>
<POST>
<POSTER> Richard Heathfield &lt;r...@see.sig.invalid&gt; </POSTER>
<POSTDATE> 2008-02-06T15:41:00 </POSTDATE>
Malcolm McLean said:

<QUOTE PREVIOUSPOST="
&gt; &quot;Clive D. W. Feather&quot; &lt;cl ... @on-the-train.demon.co.uk&gt; wrote
&gt;&gt; Furthermore, the correct type to use for an index into an array is
&gt;&gt; size_t rather than int. Of course, since you blithely subtract 1 from
&gt;&gt; the index, you'll need to trap that special case.

&gt; I am campaigning for int to be 64 bit on 64 bit platforms,
">

Where it makes sense for int to be 64 bit on 64 bit platforms, sensible
implementors will make that choice anyway, even if they've never heard of
your campaign. Where it doesn't, they won't, despite your campaign.

<QUOTE PREVIOUSPOST="
&gt; so this bit of
&gt; awkwardness will go away,
">

(a) What awkwardness? You seem to be the only one who struggles with
size_t.
(b) The probability that your campaign will change anything is
infinitesimal.

<QUOTE PREVIOUSPOST="
&gt; at least until memory sizes start pushing the 2^63 byte barrier.
">

Hmmm.

--
Richard Heathfield &lt; http://www.cpax.org.uk &gt;
Email: - http://www . +rjh@
Google users: &lt; http://www.cpax.org.uk/prg/writings/googly.php &gt;
&quot;Usenet is a strange place&quot; - dmr 29 July 1999
</POST>
<POST>
<POSTER> user923005 &lt;dcor...@connx.com&gt; </POSTER>
<POSTDATE> 2008-02-06T15:48:00 </POSTDATE>
On Feb 6, 12:41 pm, Richard Heathfield &lt;r ... @see.sig.invalid&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Malcolm McLean said:
[snip]
&gt; &gt; at least until memory sizes start pushing the 2^63 byte barrier.

&gt; Hmmm.
">

Never say never.  Oops.  I just said it.
</POST>
<POST>
<POSTER> user923005 &lt;dcor...@connx.com&gt; </POSTER>
<POSTDATE> 2008-02-06T15:51:00 </POSTDATE>
On Feb 5, 8:28 pm, CBFalconer &lt;cbfalco ... @yahoo.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; pete wrote:

&gt; ... snip ...

&gt; &gt; It can do better depending on the order.  Bubble sort can sort
&gt; &gt; this: {1,0,3,2,5,4,7,6,9,8} where all of the elements are out of
&gt; &gt; place, into ascending order in one pass.

&gt; &gt; 6) Bubble sort is a stable sort.

&gt; It is also O(n * n).  However mergesort is also stable, and is
&gt; always O(n Log n).  Bubble sort is to all practical purposes the
&gt; worst possible general sort.
">

That is true for a general sort.  However, it is useful in rare
{special purpose} cases (e.g. when you know the data will almost
always be almost sorted).

This arises (for instance) in chess programming.  There is a list of
moves that will be nearly correctly ordered because of previous
searches.  For these searches, the lists will typically be small
(about 35 items on average) and at most one or two items will be out
of place.  For this type of thing, bubble sort is actually the fastest
solution.
</POST>
</TEXT>
</BODY>
</DOC>
