<DOC>
<DOCID> eng-NG-31-127467-9235878 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-11-16T21:15:00 </DATETIME>
<BODY>
<HEADLINE>
Linux's approaching Achilles' heal
</HEADLINE>
<TEXT>
<POST>
<POSTER> nbaker2...@charter.net </POSTER>
<POSTDATE> 2007-11-16T21:15:00 </POSTDATE>
Like a run-away freighttrain, the Open Source Community's &quot;standard
practice&quot; (_faux peer review_ plus shoddy coding standards and casual
dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
) is exactly the mind-set that will bring Linux tumbling down the hill
into the valley of the forgotten, non-important OSs that &quot;could have
been&quot;.

It is easy to understand that, given the pressure to maintain a
'presence' in the month headlines and the desire to outperform the
competition in the number of 'features', some amount of short-cuts
will be taken and code audits being skipped so that the next 'distro
release' can announce a new fancy gizmo under its wing.  *Some* degree
of this behavior is to be expected in an environment where any &quot;Joe
Six-pack&quot; can start a project and have his code used by and
encorporated into other software down the stream.  However, I am quite
shocked that the practice is tolerated to the point that it leads to
extremely unstable critical support systems as detailed in the
following forum threads.

http://ubuntuforums.org/showthread.php?t=612606
http://ubuntuforums.org/showthread.php?t=614962

Nathan.
</POST>
<POST>
<POSTER> Keith Kanios &lt;ke...@kanios.net&gt; </POSTER>
<POSTDATE> 2007-11-16T21:57:00 </POSTDATE>
On Nov 16, 8:15 pm, nbaker2 ... @charter.net wrote:

<QUOTE PREVIOUSPOST="
&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; been&quot;.

&gt; It is easy to understand that, given the pressure to maintain a
&gt; 'presence' in the month headlines and the desire to outperform the
&gt; competition in the number of 'features', some amount of short-cuts
&gt; will be taken and code audits being skipped so that the next 'distro
&gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; Six-pack&quot; can start a project and have his code used by and
&gt; encorporated into other software down the stream.  However, I am quite
&gt; shocked that the practice is tolerated to the point that it leads to
&gt; extremely unstable critical support systems as detailed in the
&gt; following forum threads.

&gt; http://ubuntuforums.org/showthread.php?t=612606http://ubuntuforums.or...

&gt; Nathan.
">

I wouldn't call audio a *critical* system. If you read the response to
the half-witted comment, you will see why such non-critical systems
would be sacrificed in favor of more critical systems. If you are in a
out-of-memory situation, you will be across the board. In those
situations, you do the very same thing the human body does...
sacrifice appendages first and keep warm blood pumping to the vital
organs above all else.

A better solution to such a problem would be in fronting an effort/
campaign to reduce the amount of bloat and unnecessary memory usage.
</POST>
<POST>
<POSTER> Dan Espen &lt;dan...@MORE.mk.SPAMtelcordia.com&gt; </POSTER>
<POSTDATE> 2007-11-16T22:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
nbaker2 ... @charter.net writes:
&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; been&quot;.

&gt; It is easy to understand that, given the pressure to maintain a
&gt; 'presence' in the month headlines and the desire to outperform the
&gt; competition in the number of 'features', some amount of short-cuts
&gt; will be taken and code audits being skipped so that the next 'distro
&gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; Six-pack&quot; can start a project and have his code used by and
&gt; encorporated into other software down the stream.  However, I am quite
&gt; shocked that the practice is tolerated to the point that it leads to
&gt; extremely unstable critical support systems as detailed in the
&gt; following forum threads.

&gt; http://ubuntuforums.org/showthread.php?t=612606
&gt; http://ubuntuforums.org/showthread.php?t=614962

&gt; Nathan.
">

Ah, my friend Nathan, I'm afraid it is you that is the idiot.
I assume these malloc wrappers print a message and then abort.
Do you have any idea what else they can do?

Do you really think a program can carry on and do anything reasonable
when it runs out of memory?

Don't you think it might require something for the program to continue
on?  Like maybe memory?

Never the less, most of the software I write is middleware and
it does try to return error indications to the caller on out
of memory.  I sometimes see dumps produced by
programs using my middleware as they try to report back to the user
that something went wrong.

If you think you are so smart, find out what the real power of open
source is.  Find a better way and submit a patch.

But lose the arrogant attitude.
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-16T22:34:00 </POSTDATE>
On Nov 16, 9:57 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 16, 8:15 pm, nbaker2 ... @charter.net wrote:

&gt; &gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; &gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; &gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt; &gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; &gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; &gt; been&quot;.

&gt; &gt; It is easy to understand that, given the pressure to maintain a
&gt; &gt; 'presence' in the month headlines and the desire to outperform the
&gt; &gt; competition in the number of 'features', some amount of short-cuts
&gt; &gt; will be taken and code audits being skipped so that the next 'distro
&gt; &gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; &gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; &gt; Six-pack&quot; can start a project and have his code used by and
&gt; &gt; encorporated into other software down the stream.  However, I am quite
&gt; &gt; shocked that the practice is tolerated to the point that it leads to
&gt; &gt; extremely unstable critical support systems as detailed in the
&gt; &gt; following forum threads.

&gt; &gt; http://ubuntuforums.org/showthread.php?t=612606http://ubuntuforums.or ...

&gt; &gt; Nathan.

&gt; I wouldn't call audio a *critical* system. If you read the response to
&gt; the half-witted comment, you will see why such non-critical systems
&gt; would be sacrificed in favor of more critical systems. If you are in a
&gt; out-of-memory situation, you will be across the board. In those
&gt; situations, you do the very same thing the human body does...
&gt; sacrifice appendages first and keep warm blood pumping to the vital
&gt; organs above all else.
">

Oh come-on, Keith, you know better than to use the same pithy staw-man
that the PulseAudio retard used.  We are talking about application
layers that deal primarily with multi-media data... this means the
'desired memory allotment' may run into the tens to the hundreds of
Gigs... so &quot;across the board&quot; is an extremely weak claim since it is
very unlikely for an other application requirement (and this goes for
the other apps currently running) to be anywhere near this size.

<QUOTE PREVIOUSPOST="
&gt; A better solution to such a problem would be in fronting an effort/
&gt; campaign to reduce the amount of bloat and unnecessary memory usage.
">

This can only be successful if it were &quot;drilled into their heads&quot; at
the start of the Freshman programming course and consistantly
continued throughout the CompSci regimen.

Nathan.
</POST>
<POST>
<POSTER> ray &lt;r...@zianet.com&gt; </POSTER>
<POSTDATE> 2007-11-16T22:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Fri, 16 Nov 2007 18:15:41 -0800, nbaker2328 wrote:
&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; been&quot;.

&gt; It is easy to understand that, given the pressure to maintain a
&gt; 'presence' in the month headlines and the desire to outperform the
&gt; competition in the number of 'features', some amount of short-cuts
&gt; will be taken and code audits being skipped so that the next 'distro
&gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; Six-pack&quot; can start a project and have his code used by and
&gt; encorporated into other software down the stream.  However, I am quite
&gt; shocked that the practice is tolerated to the point that it leads to
&gt; extremely unstable critical support systems as detailed in the
&gt; following forum threads.

&gt; http://ubuntuforums.org/showthread.php?t=612606
&gt; http://ubuntuforums.org/showthread.php?t=614962

&gt; Nathan.
">

The main problem with your argument being, of course, that Vista which was
delayed several times and had features thrown out so that it could finally
come to market, seems to have even more problems.
</POST>
<POST>
<POSTER> Keith Kanios &lt;ke...@kanios.net&gt; </POSTER>
<POSTDATE> 2007-11-16T23:00:00 </POSTDATE>
On Nov 16, 9:34 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 16, 9:57 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

&gt; &gt; On Nov 16, 8:15 pm, nbaker2 ... @charter.net wrote:

&gt; &gt; &gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; &gt; &gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; &gt; &gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt; &gt; &gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; &gt; &gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; &gt; &gt; been&quot;.

&gt; &gt; &gt; It is easy to understand that, given the pressure to maintain a
&gt; &gt; &gt; 'presence' in the month headlines and the desire to outperform the
&gt; &gt; &gt; competition in the number of 'features', some amount of short-cuts
&gt; &gt; &gt; will be taken and code audits being skipped so that the next 'distro
&gt; &gt; &gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; &gt; &gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; &gt; &gt; Six-pack&quot; can start a project and have his code used by and
&gt; &gt; &gt; encorporated into other software down the stream.  However, I am quite
&gt; &gt; &gt; shocked that the practice is tolerated to the point that it leads to
&gt; &gt; &gt; extremely unstable critical support systems as detailed in the
&gt; &gt; &gt; following forum threads.

&gt; &gt; &gt; http://ubuntuforums.org/showthread.php?t=612606http://ubuntuforums.or ...

&gt; &gt; &gt; Nathan.

&gt; &gt; I wouldn't call audio a *critical* system. If you read the response to
&gt; &gt; the half-witted comment, you will see why such non-critical systems
&gt; &gt; would be sacrificed in favor of more critical systems. If you are in a
&gt; &gt; out-of-memory situation, you will be across the board. In those
&gt; &gt; situations, you do the very same thing the human body does...
&gt; &gt; sacrifice appendages first and keep warm blood pumping to the vital
&gt; &gt; organs above all else.

&gt; Oh come-on, Keith, you know better than to use the same pithy staw-man
&gt; that the PulseAudio retard used.  We are talking about application
&gt; layers that deal primarily with multi-media data... this means the
&gt; 'desired memory allotment' may run into the tens to the hundreds of
&gt; Gigs... so &quot;across the board&quot; is an extremely weak claim since it is
&gt; very unlikely for an other application requirement (and this goes for
&gt; the other apps currently running) to be anywhere near this size.
">

I don't see how &quot;straw man&quot; applies here. I am simply commenting from
the appreciation of being a system-level programmer.

If one process is hogging all of the physical and swap memory, other
processes are being deprived of that memory. Ask Windows users how
appreciative it would be to lose one application's worth the data
instead of losing all of your data due to the entire system becoming
unresponsive.

If the problem is actually with running out of process (virtual)
memory, then I can think of more graceful ways to handle such out-of-
memory situations.

<QUOTE PREVIOUSPOST="
&gt; &gt; A better solution to such a problem would be in fronting an effort/
&gt; &gt; campaign to reduce the amount of bloat and unnecessary memory usage.

&gt; This can only be successful if it were &quot;drilled into their heads&quot; at
&gt; the start of the Freshman programming course and consistantly
&gt; continued throughout the CompSci regimen.

&gt; Nathan.
">

... instead of Java, C# and garbage collection wiping incompetent
asses? It would be appreciated, but highly unrealistic when software
is market driven. Quality is no longer a factor, it is just reduced
down to time and price.
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-16T23:06:00 </POSTDATE>
On Nov 16, 10:24 pm, Dan Espen &lt;dan ... @MORE.mk.SPAMtelcordia.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; Ah, my friend Nathan, I'm afraid it is you that is the idiot.
&gt; I assume these malloc wrappers print a message and then abort.
&gt; Do you have any idea what else they can do?
">

Well, my friend Dan, I really do wish your assumption were correct.
It would be extremely nice (and helpful) if an application would
report an &quot;error condition&quot; before terminating.  It would also, by
extension, be extremely nice (and helpful) if a support library would
report said error to the calling application so that the application
developer might have the opportunity to respond in a graceful manner
to environmental conditions.  Non-returning function calls certainly
are a bane during debugging sessions.

I am also thinking of the Windows users who are new to Linux.  When
programs like Firefox consistantly and suddenly &quot;disappears&quot; on them
(the way it does for me) without reporting the &quot;why&quot;, they are going
to migrate back to their Microsoft products.  At the very least, they
get the dreaded &quot;Blue Screen of Death&quot; which is a tonne more useful
information than something which terminates your application at will.
Now do you see the danger of PulseAudio and other shoddy libraries???

Nathan.
</POST>
<POST>
<POSTER> Dan Espen &lt;dan...@MORE.mk.SPAMtelcordia.com&gt; </POSTER>
<POSTDATE> 2007-11-16T23:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Evenbit &lt;nbaker2 ... @charter.net&gt; writes:
&gt; On Nov 16, 10:24 pm, Dan Espen &lt;dan ... @MORE.mk.SPAMtelcordia.com&gt;
&gt; wrote:

&gt;&gt; Ah, my friend Nathan, I'm afraid it is you that is the idiot.
&gt;&gt; I assume these malloc wrappers print a message and then abort.
&gt;&gt; Do you have any idea what else they can do?

&gt; Well, my friend Dan, I really do wish your assumption were correct.
&gt; It would be extremely nice (and helpful) if an application would
&gt; report an &quot;error condition&quot; before terminating.  It would also, by
&gt; extension, be extremely nice (and helpful) if a support library would
&gt; report said error to the calling application so that the application
&gt; developer might have the opportunity to respond in a graceful manner
&gt; to environmental conditions.  Non-returning function calls certainly
&gt; are a bane during debugging sessions.
">

You seem to have missed the point.
When an application is out of memory, almost anything you try to do to
report an error is going to fail.

It takes memory to invoke a function.

<QUOTE PREVIOUSPOST="
&gt; I am also thinking of the Windows users who are new to Linux.  When
&gt; programs like Firefox consistantly and suddenly &quot;disappears&quot; on them
&gt; (the way it does for me) without reporting the &quot;why&quot;, they are going
&gt; to migrate back to their Microsoft products.
">

Firefox disappearing, likely has nothing to do with this issue.

Install the Firefox bug reporting tool and a Firefox failure will
invoke a dialog that sends a bug report back to the developers.

<QUOTE PREVIOUSPOST="
&gt; At the very least, they
&gt; get the dreaded &quot;Blue Screen of Death&quot; which is a tonne more useful
&gt; information than something which terminates your application at will.
&gt; Now do you see the danger of PulseAudio and other shoddy libraries???
">

I don't see any danger.
It's an audio application.
It will stop and I'll look for the problem.
</POST>
<POST>
<POSTER> Frank Kotler &lt;fbkot...@verizon.net&gt; </POSTER>
<POSTDATE> 2007-11-17T06:12:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Dan Espen wrote:
">

...

<QUOTE PREVIOUSPOST="
&gt; When an application is out of memory, almost anything you try to do to
&gt; report an error is going to fail.
">

...

<QUOTE PREVIOUSPOST="
&gt; Install the Firefox bug reporting tool and a Firefox failure will
&gt; invoke a dialog that sends a bug report back to the developers.
">

Clever, these Firefox developers...

Best,
Frank
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-17T08:35:00 </POSTDATE>
On Nov 16, 9:57 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I wouldn't call audio a *critical* system.
">

Audio is certainly a critical system for those users who are not
blessed with the normal human attribute of being 'sighted'.  Blind
people do not depend on either screen graphics or text from a video
monitor -- they are able to use a PC solely via the audio feedback.
Why should library developers be granted exclusive permission to
determine which systems are *critical* and which are not?  Shouldn't
these decision be left for the application programmer to decide?

Nathan.
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-17T09:02:00 </POSTDATE>
On Nov 16, 11:00 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:
&lt;&lt;snipped&gt;&gt;

<QUOTE PREVIOUSPOST="
&gt; &gt; Oh come-on, Keith, you know better than to use the same pithy staw-man
&gt; &gt; that the PulseAudio retard used.  We are talking about application
&gt; &gt; layers that deal primarily with multi-media data... this means the
&gt; &gt; 'desired memory allotment' may run into the tens to the hundreds of
&gt; &gt; Gigs... so &quot;across the board&quot; is an extremely weak claim since it is
&gt; &gt; very unlikely for an other application requirement (and this goes for
&gt; &gt; the other apps currently running) to be anywhere near this size.

&gt; I don't see how &quot;straw man&quot; applies here. I am simply commenting from
&gt; the appreciation of being a system-level programmer.
">

It is obvious that if you are indeed a &quot;system-level programmer&quot; who
is worth his salt, then you would have _some_ understanding about
modern memory management issues (it is clear from your responses that
you do not).  When we issue a call to an OS asking for a chunck of
memory, the OS responds by looking for an area of _contiguous_ free
memory space of the size that we request.  So, you see, it is
perfectly possible that an attempt to allocate 50Gigs will fail, while
subsequent calls to the same OS function asking for 10 instances of
10Gigs each will succeed.

<QUOTE PREVIOUSPOST="
&gt; If one process is hogging all of the physical and swap memory, other
&gt; processes are being deprived of that memory. Ask Windows users how
&gt; appreciative it would be to lose one application's worth the data
&gt; instead of losing all of your data due to the entire system becoming
&gt; unresponsive.
">

Wouldn't the better choice be to not lose ANY data???  Why do Linux
developers consistantly shoot for standards that are _below_ that of
Windows developers?  Why should end-users tolerate a less-stable
experience -- especially when Linux-fans consistantly &quot;bill&quot; Linux as
the better(TM) product??

<QUOTE PREVIOUSPOST="
&gt; If the problem is actually with running out of process (virtual)
&gt; memory, then I can think of more graceful ways to handle such out-of-
&gt; memory situations.
">

This is indeed the issue at hand -- being &quot;more graceful&quot; than killing
the calling application and preventing any error reports from being
issued.

<QUOTE PREVIOUSPOST="
&gt; &gt; &gt; A better solution to such a problem would be in fronting an effort/
&gt; &gt; &gt; campaign to reduce the amount of bloat and unnecessary memory usage.

&gt; &gt; This can only be successful if it were &quot;drilled into their heads&quot; at
&gt; &gt; the start of the Freshman programming course and consistantly
&gt; &gt; continued throughout the CompSci regimen.

&gt; ... instead of Java, C# and garbage collection wiping incompetent
&gt; asses? It would be appreciated, but highly unrealistic when software
&gt; is market driven. Quality is no longer a factor, it is just reduced
&gt; down to time and price.
">

This is the very mind-set and attitude which will get Linux labelled a
&quot;has been&quot; in the OS history books.

Nathan.
</POST>
<POST>
<POSTER> &quot;Rod Pemberton&quot; &lt;do_not_h...@nowhere.cmm&gt; </POSTER>
<POSTDATE> 2007-11-17T03:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Dan Espen&quot; &lt;dan ... @MORE.mk.SPAMtelcordia.com&gt; wrote in message
">

news:ic8x4xa708.fsf@mk.telcordia.com ...

<QUOTE PREVIOUSPOST="
&gt; nbaker2 ... @charter.net writes:
">

Sigh, had to go to Google to read the other six posts that didn't propagate
well...

<QUOTE PREVIOUSPOST="
&gt; &gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; &gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; &gt; dismissal of bug reports pointing out critical flaws
">

http://pulseaudio.org/ticket/158

<QUOTE PREVIOUSPOST="
&gt; &gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt; &gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt; &gt; been&quot;.
">

Although I strongly believe there are reasons to support the claim that
Linux is or will be &quot;tumbling down the hill into the valley of the
forgotten, non-important OSs that 'could have been',&quot; I don't believe the
issue is the mindset of Linux coders, their standards, their failure to fix
bugs, or even other issues such as reversion of prior bug fixes or
filesystem problems...

The real primary issue is money.  Can Linux survive long term against a
company with billions in financial and physical capital, licensed and
proprietary software patents, driven programmers who are _paid_ to program
for a living, and an endless supply of software drivers written for their
OS's API by hardware manufacturers.  Secondary issues include software
development time for new PC hardware or circuitry and the far above average
intellect of &quot;their&quot; large paid programmer base versus the average IQ,
skill, and time constraints of many unpaid &quot;Joe Six-pack&quot; 's.  I see Linux
running into a wall due to the rapid continuous changes and advances in PC
circuitry unless a huge infusion of cash is found.  A for profit Linux OS
corporation needs to be formed.  Getting Apple to dump OS X for paid copies
of Linux would be a good start.  If Linux can't compete with OS X for
profit, I really don't see a long term PC future.  Perhaps one might as well
dump Linux now and embrace OS X...

Personally, I also think some long term design changes are needed.  I'd
recommend a adopting a syscall only based version of Linux as it's primary
form, like UML.  If only a syscall interface had to be written to bootstrap
Linux, cross-compiling to other platforms would be faster and easier.
Unfortunately, even with a UML version available, Linux's syscall interface
has bloated from 40 implemented functions in v0.01 to 290 in v2.16.17.  The
number of syscalls needs to be drastically reduced or the syscall interface
needs to be built entirely on a small set of functions.  I'd also recommend
using some other highly popular interface that allows development of almost
OS applications, say the SDL library, instead of the current syscall
interface.  If SDL, this would allow numerous OS-like applications such as
DOSBox, Scummvm, etc. to run as the &quot;higher level&quot; OS.  Writing the low
level OS portions are a pain.  Nobody really wants to do that.  It's already
been done fairly well for Linux.  Much of the low level parts of Linux have
been extracted from Linux for the LinuxBIOS' FILO project anyway.  Allowing
different top-ends to the OS would encourage much more upper level OS
development and adaptation.  This adaptability might be a good long term
advantage against a corporate competitor that has become stagnant.

Rod Pemberton
</POST>
<POST>
<POSTER> Bruce Coryell &lt;bcory...@chesco.com&gt; </POSTER>
<POSTDATE> 2007-11-17T16:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Rod Pemberton wrote:
&gt; &quot;Dan Espen&quot; &lt;dan ... @MORE.mk.SPAMtelcordia.com&gt; wrote in message
&gt; news:ic8x4xa708.fsf@mk.telcordia.com ...

&gt;&gt;nbaker2 ... @charter.net writes:

&gt; Sigh, had to go to Google to read the other six posts that didn't propagate
&gt; well...

&gt;&gt;&gt;Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt;&gt;&gt;practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt;&gt;&gt;dismissal of bug reports pointing out critical flaws

&gt; http://pulseaudio.org/ticket/158

&gt;&gt;&gt;) is exactly the mind-set that will bring Linux tumbling down the hill
&gt;&gt;&gt;into the valley of the forgotten, non-important OSs that &quot;could have
&gt;&gt;&gt;been&quot;.

&gt; Although I strongly believe there are reasons to support the claim that
&gt; Linux is or will be &quot;tumbling down the hill into the valley of the
&gt; forgotten, non-important OSs that 'could have been',&quot; I don't believe the
&gt; issue is the mindset of Linux coders, their standards, their failure to fix
&gt; bugs, or even other issues such as reversion of prior bug fixes or
&gt; filesystem problems...

&gt; The real primary issue is money.  Can Linux survive long term against a
&gt; company with billions in financial and physical capital, licensed and
&gt; proprietary software patents, driven programmers who are _paid_ to program
&gt; for a living, and an endless supply of software drivers written for their
&gt; OS's API by hardware manufacturers.  Secondary issues include software
&gt; development time for new PC hardware or circuitry and the far above average
&gt; intellect of &quot;their&quot; large paid programmer base versus the average IQ,
&gt; skill, and time constraints of many unpaid &quot;Joe Six-pack&quot; 's.  I see Linux
&gt; running into a wall due to the rapid continuous changes and advances in PC
&gt; circuitry unless a huge infusion of cash is found.  A for profit Linux OS
&gt; corporation needs to be formed.  Getting Apple to dump OS X for paid copies
&gt; of Linux would be a good start.  If Linux can't compete with OS X for
&gt; profit, I really don't see a long term PC future.  Perhaps one might as well
&gt; dump Linux now and embrace OS X...

&gt; Personally, I also think some long term design changes are needed.  I'd
&gt; recommend a adopting a syscall only based version of Linux as it's primary
&gt; form, like UML.  If only a syscall interface had to be written to bootstrap
&gt; Linux, cross-compiling to other platforms would be faster and easier.
&gt; Unfortunately, even with a UML version available, Linux's syscall interface
&gt; has bloated from 40 implemented functions in v0.01 to 290 in v2.16.17.  The
&gt; number of syscalls needs to be drastically reduced or the syscall interface
&gt; needs to be built entirely on a small set of functions.  I'd also recommend
&gt; using some other highly popular interface that allows development of almost
&gt; OS applications, say the SDL library, instead of the current syscall
&gt; interface.  If SDL, this would allow numerous OS-like applications such as
&gt; DOSBox, Scummvm, etc. to run as the &quot;higher level&quot; OS.  Writing the low
&gt; level OS portions are a pain.  Nobody really wants to do that.  It's already
&gt; been done fairly well for Linux.  Much of the low level parts of Linux have
&gt; been extracted from Linux for the LinuxBIOS' FILO project anyway.  Allowing
&gt; different top-ends to the OS would encourage much more upper level OS
&gt; development and adaptation.  This adaptability might be a good long term
&gt; advantage against a corporate competitor that has become stagnant.

&gt; Rod Pemberton
">

Actually there are &quot;for profit OS Linux corporations&quot; around - such as
Red Hat, Novell (Suse), Caldera, and others of their ilk...

OS/2 is still around, though not owned or supported by IBM anymore:
http://www.ecomstation.com/ OS/2 was one sharp operating system about
15 years ago,  just never caught on.  But if this company is smart, they
could really position this as a viable alternative to Microsoft.

Another OS that could be a good alternative, if they positioned it a
little better, would be Sun's Solaris operating system.  I tried an
evaluation copy and my system really hummed with it, even at 800 MHz.
Just that the networking support with Linux and MS was a little rough.
</POST>
<POST>
<POSTER> Fredderic &lt;my-name-h...@excite.com&gt; </POSTER>
<POSTDATE> 2007-11-17T19:11:00 </POSTDATE>
On Sat, 17 Nov 2007 06:02:02 -0800 (PST),

<QUOTE PREVIOUSPOST="
Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:
&gt; On Nov 16, 11:00 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:
&gt; &lt;&lt;snipped&gt;&gt;
&gt;&gt; I don't see how &quot;straw man&quot; applies here. I am simply commenting
&gt;&gt; from the appreciation of being a system-level programmer.
&gt; It is obvious that if you are indeed a &quot;system-level programmer&quot; who
&gt; is worth his salt, then you would have _some_ understanding about
&gt; modern memory management issues (it is clear from your responses that
&gt; you do not).  When we issue a call to an OS asking for a chunck of
&gt; memory, the OS responds by looking for an area of _contiguous_ free
&gt; memory space of the size that we request.  So, you see, it is
&gt; perfectly possible that an attempt to allocate 50Gigs will fail, while
&gt; subsequent calls to the same OS function asking for 10 instances of
&gt; 10Gigs each will succeed.
">

That's odd...  I was under the impression we had this thing called
paging, on modern operating systems.  This has two effects; one,
applications are actually allocated memory in complete pages, and
secondly, those pages can reside anywhere in physical ram, and they'll
still appear contiguous to the application.

The only time this might be an issue, is with DMA, where a component
external to the processor (and hence without the benefit of the kernels
page tables) needs to access data across two or more pages.

Mind you, I'm not a systems level programmer either...

<QUOTE PREVIOUSPOST="
&gt;&gt; If one process is hogging all of the physical and swap memory, other
&gt;&gt; processes are being deprived of that memory. Ask Windows users how
&gt;&gt; appreciative it would be to lose one application's worth the data
&gt;&gt; instead of losing all of your data due to the entire system becoming
&gt;&gt; unresponsive.
&gt; Wouldn't the better choice be to not lose ANY data???  Why do Linux
&gt; developers consistantly shoot for standards that are _below_ that of
&gt; Windows developers?  Why should end-users tolerate a less-stable
&gt; experience -- especially when Linux-fans consistantly &quot;bill&quot; Linux as
&gt; the better(TM) product??
">

You, mate, are an ass.  Every time I have run out of memory on a
Windoze system, the entire system crashed.  My wife who still uses
Windoze will attest to that.  All current unsaved data, in all
applications, gets flushed down the drain when not even Ctrl-Alt-Del
will respond, and you have to reach for the power button (because
modern machines don't come with a reset button anymore).

Every time I run out of memory in a Linux system, one application gets
hosed, _usually_ the right one.  Though occasionally it's like my GUI
panel or something, which subsequently gets re-started, causing
something else to die instead, and occasionally it'll roll through two
or three unlucky minor apps before it hits the right one.  It can also
be a bitch when it's the X-server itself that it decides to kill, but
such is life.  I just sit back and watch for a few minutes, after which
I have a system that's at least stable enough to save down anything
that has survived, and either restart the X server myself, or give the
while system a thorough cleanout with a nice soft restart.

It's still a damn sight better than the Windoze way of just locking up
the entire frigging machine, and hosing everything indiscriminately.

<QUOTE PREVIOUSPOST="
&gt;&gt; If the problem is actually with running out of process (virtual)
&gt;&gt; memory, then I can think of more graceful ways to handle such
&gt;&gt; out-of- memory situations.
&gt; This is indeed the issue at hand -- being &quot;more graceful&quot; than killing
&gt; the calling application and preventing any error reports from being
&gt; issued.
">

The question, is how exactly do you do that, without allocating
additional memory?

Come to think of it, how do you figure out when enough memory is really
enough?  My system will quite happily (albeit a little slowly) run with
3-4 times the base memory allocated, as long as no single application
accounts for twice the base memory.  In Windoze, it starts to die well
before that.

<QUOTE PREVIOUSPOST="
&gt;&gt; ... instead of Java, C# and garbage collection wiping incompetent
&gt;&gt; asses? It would be appreciated, but highly unrealistic when software
&gt;&gt; is market driven. Quality is no longer a factor, it is just reduced
&gt;&gt; down to time and price.
&gt; This is the very mind-set and attitude which will get Linux labelled a
&gt; &quot;has been&quot; in the OS history books.
">

But that is the mind-set that exists industry-wide.  One only has to
look at Microsoft's business applications, most of which palm off HTTP
and XML as gods gift to software developers.  They've rammed their
stock-standard HTTP/XML libraries into places they simply don't fit,
and focused on making the application look pretty so end users will
like it, and not notice the utter shite under the hood.  I've seen it
time and time again.  Most of the good quality innovative developments
I've seen of late, have come from Linux, not Microsoft.

So I really think you've got your head on backwards, mate.  Linux's
achilles heal, if anything, is that fact that it's doing the job
right, rather than cutting corners and building lock-in boxes, in an
attempt to rule the world.

Fredderic
</POST>
<POST>
<POSTER> Fredderic &lt;my-name-h...@excite.com&gt; </POSTER>
<POSTDATE> 2007-11-17T19:16:00 </POSTDATE>
On Sat, 17 Nov 2007 05:35:24 -0800 (PST),

<QUOTE PREVIOUSPOST="
Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:
&gt; On Nov 16, 9:57 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:
&gt;&gt; I wouldn't call audio a *critical* system.
&gt; Audio is certainly a critical system for those users who are not
&gt; blessed with the normal human attribute of being 'sighted'.  Blind
&gt; people do not depend on either screen graphics or text from a video
&gt; monitor -- they are able to use a PC solely via the audio feedback.
&gt; Why should library developers be granted exclusive permission to
&gt; determine which systems are *critical* and which are not?  Shouldn't
&gt; these decision be left for the application programmer to decide?
">

They're not.  Both systems get pretty much the same regard, as far as I
can see.  But one would offer the suggested that without sight, there'd
likely be more memory for the audio system.  Plus audio generally has a
lower memory footprint, and so short of audio editors and other
high-end music creation software, a simple screen reader is far less
likely to draw the application killers gaze, and far more likely to be
automatically restarted even if it did.

You know, I may have missed part of the thread, but it seems to me that
tugging on the accessibility string really is another step down the
ladder for you.

Fredderic
</POST>
<POST>
<POSTER> Keith Kanios &lt;ke...@kanios.net&gt; </POSTER>
<POSTDATE> 2007-11-17T21:24:00 </POSTDATE>
On Nov 17, 8:02 am, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 16, 11:00 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:
&gt; &lt;&lt;snipped&gt;&gt;

&gt; &gt; &gt; Oh come-on, Keith, you know better than to use the same pithy staw-man
&gt; &gt; &gt; that the PulseAudio retard used.  We are talking about application
&gt; &gt; &gt; layers that deal primarily with multi-media data... this means the
&gt; &gt; &gt; 'desired memory allotment' may run into the tens to the hundreds of
&gt; &gt; &gt; Gigs... so &quot;across the board&quot; is an extremely weak claim since it is
&gt; &gt; &gt; very unlikely for an other application requirement (and this goes for
&gt; &gt; &gt; the other apps currently running) to be anywhere near this size.

&gt; &gt; I don't see how &quot;straw man&quot; applies here. I am simply commenting from
&gt; &gt; the appreciation of being a system-level programmer.

&gt; It is obvious that if you are indeed a &quot;system-level programmer&quot; who
&gt; is worth his salt, then you would have _some_ understanding about
&gt; modern memory management issues (it is clear from your responses that
&gt; you do not).  When we issue a call to an OS asking for a chunck of
&gt; memory, the OS responds by looking for an area of _contiguous_ free
&gt; memory space of the size that we request.  So, you see, it is
&gt; perfectly possible that an attempt to allocate 50Gigs will fail, while
&gt; subsequent calls to the same OS function asking for 10 instances of
&gt; 10Gigs each will succeed.
">

Yeah, I know. Like, sheesh... how would I know about paging and memory
management if I have only written my own memory managers (rolls eyes)

Even at 4KB page resolution, physical out-of-memory situations *can*
occur and you *need* your system to do some quick and efficient
triage... and amputations if needed.

Stability comes before usability, not the other way around. If you are
physically out of memory, you simply cannot assume that you have
enough memory to perform even the simplest of operations. You want a
prime example of such bad design??? Use up all of your hard drive
space on your Windows box and then run a memory-intensive application/
game... catch you on the flip-side of that reset button buddy... and
pray that your chkdsk runs clean. This may be OK to get away with on
your desktop, but this is absolutely intolerable for a server/
production environment.

It would be wise to catch yourself up on some of these concepts
instead of insisting that you know them because you *think* they
should be that way. It could quite possibly keep you from looking like
a complete newbie.

<QUOTE PREVIOUSPOST="
&gt; &gt; If one process is hogging all of the physical and swap memory, other
&gt; &gt; processes are being deprived of that memory. Ask Windows users how
&gt; &gt; appreciative it would be to lose one application's worth the data
&gt; &gt; instead of losing all of your data due to the entire system becoming
&gt; &gt; unresponsive.

&gt; Wouldn't the better choice be to not lose ANY data???  Why do Linux
&gt; developers consistantly shoot for standards that are _below_ that of
&gt; Windows developers?  Why should end-users tolerate a less-stable
&gt; experience -- especially when Linux-fans consistantly &quot;bill&quot; Linux as
&gt; the better(TM) product??
">

I am not going to get into a NT vs. Linux war, as I really don't like
either of their designs and I'll pick BSD over the two any day.
However, I have consistently noticed (i.e. from vast server/desktop
experience) that memory management on Linux is handled much better
than NT... and this is coming from someone who runs Windows XP
despite.

<QUOTE PREVIOUSPOST="
&gt; &gt; If the problem is actually with running out of process (virtual)
&gt; &gt; memory, then I can think of more graceful ways to handle such out-of-
&gt; &gt; memory situations.

&gt; This is indeed the issue at hand -- being &quot;more graceful&quot; than killing
&gt; the calling application and preventing any error reports from being
&gt; issued.
">

Is it really? Are you absolutely sure that the program is using up its
entire virtual memory space and not just choking on low RAM and HD
space situations??? Links that state this, exactly, would be
appreciated.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; &gt; &gt; &gt; A better solution to such a problem would be in fronting an effort/
&gt; &gt; &gt; &gt; campaign to reduce the amount of bloat and unnecessary memory usage.

&gt; &gt; &gt; This can only be successful if it were &quot;drilled into their heads&quot; at
&gt; &gt; &gt; the start of the Freshman programming course and consistantly
&gt; &gt; &gt; continued throughout the CompSci regimen.

&gt; &gt; ... instead of Java, C# and garbage collection wiping incompetent
&gt; &gt; asses? It would be appreciated, but highly unrealistic when software
&gt; &gt; is market driven. Quality is no longer a factor, it is just reduced
&gt; &gt; down to time and price.

&gt; This is the very mind-set and attitude which will get Linux labelled a
&gt; &quot;has been&quot; in the OS history books.

&gt; Nathan.
">

I think Linux suffers from the very thing that makes it popular. It
tries to be the one OS that can run everywhere and on everything. In
this respect, it suffers in terms of quality. Mostly everything is
dependent on gcc to make all of the optimizations. There are too many
redundant libraries, and even then most of them do relatively simple
things. However, you will rarely see a properly configured Linux-based
server have the need to be restarted short of upgrades, deep
configuration changes and those rare kernel panics. I wish I could say
the same for even the best NT server setups I have come across.

Toaster Linux FTW!!!
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-17T23:34:00 </POSTDATE>
On Nov 17, 9:24 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; It would be wise to catch yourself up on some of these concepts
&gt; instead of insisting that you know them because you *think* they
&gt; should be that way. It could quite possibly keep you from looking like
&gt; a complete newbie.
">

The only reason that I &quot;insist that [I] know them&quot; is because I *have*
been reading this type of material.  I haven't (knowingly) made any
claim about OS functionality that I didn't gain from reading a few
books on the subject.

Nathan.
</POST>
<POST>
<POSTER> Keith Kanios &lt;ke...@kanios.net&gt; </POSTER>
<POSTDATE> 2007-11-18T00:46:00 </POSTDATE>
On Nov 17, 10:34 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 17, 9:24 pm, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

&gt; &gt; It would be wise to catch yourself up on some of these concepts
&gt; &gt; instead of insisting that you know them because you *think* they
&gt; &gt; should be that way. It could quite possibly keep you from looking like
&gt; &gt; a complete newbie.

&gt; The only reason that I &quot;insist that [I] know them&quot; is because I *have*
&gt; been reading this type of material.  I haven't (knowingly) made any
&gt; claim about OS functionality that I didn't gain from reading a few
&gt; books on the subject.

&gt; Nathan.
">

Ah... theory. Leaves a nice warm feeling, doesn't it?

Three potential solutions to fix your unsound comments.

1) Re-read those books.
2) Get more modern/informative books.
3) Try a little practical implementation so you can see why it is so
foolish to back such inconsistent theories or potential
misunderstandings.

I am not trying to be too much of an a**hole here, but I have nearly 8
years of actual OS development experience and system-level programming
under my belt. It is not a lot, but I would be willing to pit it
against someone who seems to have just graduated from HLA. So, believe
me when I tell you: YOU ARE WRONG.

Now, adapt, overcome and enjoy the enlightenment that will follow ;)
</POST>
<POST>
<POSTER> Robert Redelmeier &lt;red...@ev1.net.invalid&gt; </POSTER>
<POSTDATE> 2007-11-18T10:56:00 </POSTDATE>
In alt.lang.asm ray &lt;r ... @zianet.com&gt; wrote in part:

<QUOTE PREVIOUSPOST="
&gt; On Fri, 16 Nov 2007 18:15:41 -0800, nbaker2328 wrote:
&gt;&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt;&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt;&gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt;&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt;&gt; into the valley of the forgotten, non-important OSs that &quot;could have been&quot;.

&gt;&gt; It is easy to understand that, given the pressure to maintain a
&gt;&gt; 'presence' in the month headlines and the desire to outperform the
&gt;&gt; competition in the number of 'features', some amount of short-cuts will
&gt;&gt; be taken and code audits being skipped so that the next 'distro release'
&gt;&gt; can announce a new fancy gizmo under its wing.  *Some* degree of this
&gt;&gt; behavior is to be expected in an environment where any &quot;Joe Six-pack&quot;
&gt;&gt; can start a project and have his code used by and encorporated into
&gt;&gt; other software down the stream.  However, I am quite shocked that the
&gt;&gt; practice is tolerated to the point that it leads to extremely unstable
&gt;&gt; critical support systems as detailed in the following forum threads.
&gt;&gt; http://ubuntuforums.org/showthread.php?t=612606
&gt;&gt; http://ubuntuforums.org/showthread.php?t=614962
&gt;&gt; Nathan.

&gt; The main problem with your argument being, of course, that Vista
&gt; which was delayed several times and had features thrown out so that
&gt; it could finally come to market, seems to have even more problems.
">

This is a valid high-level argument:  success is much more than
avoiding failure.  Even glaring failures can be immaterial.

However, I am reading in ALA where details are very relevant so
I feel compelled to offer some of the many:

1)  A Linux distro is _not_ the kernel.  distros come and go,
the kernel is eternal :)

2)  Much greater code review has been done for OpenBSD.  It has
not lead to run-away success outside of its' domain.

3)  Using a desktop/user distro for a &quot;critical support system&quot;
is unlikely to be successful except for &quot;non-traditional&quot;
definitions of &quot;critical&quot;

4)  audio might be one of those defininitions

5)  not understanding VM_overcommit and the OOM killer certainly
is &quot;non-traditional&quot; wrt &quot;critical&quot;.

6)  If Nathan or J-G dislike certainly library coding, they are
completely free to change it, forking the project.  This is one
of the great strengths of the GPL and Linux.  Whining is very
poor form and a waste of effort.  Projects propagate based on
user judgement.  Not critics and whiners.

-- Robert
</POST>
<POST>
<POSTER> Joe &lt;j...@jretrading.com&gt; </POSTER>
<POSTDATE> 2007-11-18T12:06:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Rod Pemberton wrote:
&gt; &quot;Dan Espen&quot; &lt;dan ... @MORE.mk.SPAMtelcordia.com&gt; wrote in message
&gt; news:ic8x4xa708.fsf@mk.telcordia.com ...
&gt;&gt; nbaker2 ... @charter.net writes:

&gt; Sigh, had to go to Google to read the other six posts that didn't propagate
&gt; well...

&gt;&gt;&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt;&gt;&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt;&gt;&gt; dismissal of bug reports pointing out critical flaws
&gt; http://pulseaudio.org/ticket/158
&gt;&gt;&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt;&gt;&gt; into the valley of the forgotten, non-important OSs that &quot;could have
&gt;&gt;&gt; been&quot;.

&gt; Although I strongly believe there are reasons to support the claim that
&gt; Linux is or will be &quot;tumbling down the hill into the valley of the
&gt; forgotten, non-important OSs that 'could have been',&quot; I don't believe the
&gt; issue is the mindset of Linux coders, their standards, their failure to fix
&gt; bugs, or even other issues such as reversion of prior bug fixes or
&gt; filesystem problems...

&gt; The real primary issue is money.  Can Linux survive long term against a
&gt; company with billions in financial and physical capital, licensed and
&gt; proprietary software patents, driven programmers who are _paid_ to program
&gt; for a living, and an endless supply of software drivers written for their
&gt; OS's API by hardware manufacturers.  Secondary issues include software
&gt; development time for new PC hardware or circuitry and the far above average
&gt; intellect of &quot;their&quot; large paid programmer base versus the average IQ,
&gt; skill, and time constraints of many unpaid &quot;Joe Six-pack&quot; 's.  I see Linux
&gt; running into a wall due to the rapid continuous changes and advances in PC
&gt; circuitry unless a huge infusion of cash is found.
">

This has been the situation for the last twenty years. Linux and GNU
were born into and grew up in exactly this environment. If they die now,
it won't be for this reason.

Microsoft certainly has good people working for it. But they are very
closely constrained by the requirement to keep re-selling what is
broadly the same software, and even more so by the importance of
maintaining the near-monopoly. What innovation does occur is almost
entirely aimed at keeping and improving the incompatibility between
Windows and the rest of the IT world, and to some extent even with
earlier Microsoft software. GNU-Linux has no need or use for planned
obsolescence.

One particularly crippling constraint is that much-loved marketing word
'integration'. This means linking together relatively unrelated programs
so tightly that connection with non-Microsoft software is difficult or
impossible. This is the exact opposite of what is probably the single
strongest programming imperative, to isolate sub-programs as much as
possible and to use only well-defined interfaces between them.

A simple example: the Windows Small Business Server contains a POP3
downloader which drops mail straight into Exchange mailboxes, because it
can, and because the suits can then use the 'i' word. The competitive
POP3 download products all deliver to localhost:25 by SMTP, keeping the
interface clean and simple. The result is that the competitors can
utilise a number of Exchange features which the built-in POP3 connector
bypasses. While Microsoft is not a company to be underestimated, it
should not be overestimated either.
</POST>
<POST>
<POSTER> Jerry McBride &lt;jmcbr...@mail-on.us&gt; </POSTER>
<POSTDATE> 2007-11-18T15:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
nbaker2 ... @charter.net wrote:
&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt; dismissal of bug reports pointing out critical flaws
&gt; http://pulseaudio.org/ticket/158 ) is exactly the mind-set that will bring
&gt; Linux tumbling down the hill into the valley of the forgotten,
&gt; non-important OSs that &quot;could have been&quot;.

&gt; It is easy to understand that, given the pressure to maintain a
&gt; 'presence' in the month headlines and the desire to outperform the
&gt; competition in the number of 'features', some amount of short-cuts
&gt; will be taken and code audits being skipped so that the next 'distro
&gt; release' can announce a new fancy gizmo under its wing.  *Some* degree
&gt; of this behavior is to be expected in an environment where any &quot;Joe
&gt; Six-pack&quot; can start a project and have his code used by and
&gt; encorporated into other software down the stream.  However, I am quite
&gt; shocked that the practice is tolerated to the point that it leads to
&gt; extremely unstable critical support systems as detailed in the
&gt; following forum threads.

&gt; http://ubuntuforums.org/showthread.php?t=612606
&gt; http://ubuntuforums.org/showthread.php?t=614962

&gt; Nathan.
">

FUD... FUD... Go away... Come again... Some other day.

If it smells like a troll, looks like a troll and writes like a troll...

IT MUST BE A TROLL.

--

Jerry McBride (jmcbr ... @mail-on.us)
</POST>
<POST>
<POSTER> ray &lt;r...@zianet.com&gt; </POSTER>
<POSTDATE> 2007-11-18T18:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sun, 18 Nov 2007 15:56:34 +0000, Robert Redelmeier wrote:
&gt; In alt.lang.asm ray &lt;r ... @zianet.com&gt; wrote in part:
&gt;&gt; On Fri, 16 Nov 2007 18:15:41 -0800, nbaker2328 wrote:
&gt;&gt;&gt; Like a run-away freighttrain, the Open Source Community's &quot;standard
&gt;&gt;&gt; practice&quot; (_faux peer review_ plus shoddy coding standards and casual
&gt;&gt;&gt; dismissal of bug reports pointing out critical flaws http://pulseaudio.org/ticket/158
&gt;&gt;&gt; ) is exactly the mind-set that will bring Linux tumbling down the hill
&gt;&gt;&gt; into the valley of the forgotten, non-important OSs that &quot;could have been&quot;.

&gt;&gt;&gt; It is easy to understand that, given the pressure to maintain a
&gt;&gt;&gt; 'presence' in the month headlines and the desire to outperform the
&gt;&gt;&gt; competition in the number of 'features', some amount of short-cuts will
&gt;&gt;&gt; be taken and code audits being skipped so that the next 'distro release'
&gt;&gt;&gt; can announce a new fancy gizmo under its wing.  *Some* degree of this
&gt;&gt;&gt; behavior is to be expected in an environment where any &quot;Joe Six-pack&quot;
&gt;&gt;&gt; can start a project and have his code used by and encorporated into
&gt;&gt;&gt; other software down the stream.  However, I am quite shocked that the
&gt;&gt;&gt; practice is tolerated to the point that it leads to extremely unstable
&gt;&gt;&gt; critical support systems as detailed in the following forum threads.
&gt;&gt;&gt; http://ubuntuforums.org/showthread.php?t=612606
&gt;&gt;&gt; http://ubuntuforums.org/showthread.php?t=614962
&gt;&gt;&gt; Nathan.

&gt;&gt; The main problem with your argument being, of course, that Vista
&gt;&gt; which was delayed several times and had features thrown out so that
&gt;&gt; it could finally come to market, seems to have even more problems.

&gt; This is a valid high-level argument:  success is much more than
&gt; avoiding failure.  Even glaring failures can be immaterial.

&gt; However, I am reading in ALA where details are very relevant so
&gt; I feel compelled to offer some of the many:

&gt; 1)  A Linux distro is _not_ the kernel.  distros come and go,
&gt;     the kernel is eternal :)

&gt; 2)  Much greater code review has been done for OpenBSD.  It has
&gt;     not lead to run-away success outside of its' domain.

&gt; 3)  Using a desktop/user distro for a &quot;critical support system&quot;
&gt;     is unlikely to be successful except for &quot;non-traditional&quot;
&gt;     definitions of &quot;critical&quot;
">

Would a real time monitoring system in a major DOD test and evaluation
environment qualify? I think so. And the ones I was familiar with before I
retired three years ago relied on Unix and Linux.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; 4)  audio might be one of those defininitions

&gt; 5)  not understanding VM_overcommit and the OOM killer certainly
&gt;     is &quot;non-traditional&quot; wrt &quot;critical&quot;.

&gt; 6)  If Nathan or J-G dislike certainly library coding, they are
&gt;     completely free to change it, forking the project.  This is one
&gt;     of the great strengths of the GPL and Linux.  Whining is very
&gt;     poor form and a waste of effort.  Projects propagate based on
&gt;     user judgement.  Not critics and whiners.

&gt; -- Robert
">
</POST>
<POST>
<POSTER> Robert Redelmeier &lt;red...@ev1.net.invalid&gt; </POSTER>
<POSTDATE> 2007-11-18T18:50:00 </POSTDATE>
In alt.lang.asm ray &lt;r ... @zianet.com&gt; wrote in part:

<QUOTE PREVIOUSPOST="
&gt; On Sun, 18 Nov 2007 15:56:34 +0000, Robert Redelmeier wrote:
&gt;&gt; 3)  Using a desktop/user distro for a &quot;critical support system&quot;
&gt;&gt;     is unlikely to be successful except for &quot;non-traditional&quot;
&gt;&gt;     definitions of &quot;critical&quot;

&gt; Would a real time monitoring system in a major DOD test and evaluation
&gt; environment qualify? I think so. And the ones I was familiar with
&gt; before I retired three years ago relied on Unix and Linux.
">

Certainly it would qualify as &quot;critical&quot;.  And I don't doubt
Unix and other Linux-like systems could pass.

All I'm trying to say is that I doubt an out-of-the-box,
install everything _user_ distro like Ubuntu would pass.  Just
think of all the kernel modules.  Redhat, Debian, Slackware or
even a correctly stripped Ubuntu would be necessary, preferably
with a kernel customized for the hardware.  No X-server, XDM or
other eye candy will necessarily be reliable on all hardware.

-- Robert
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-11-19T16:34:00 </POSTDATE>
On Nov 18, 12:46 am, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Ah... theory. Leaves a nice warm feeling, doesn't it?
">

... and leads to my trade-mark trait of &quot;going off half-cocked!&quot;  ;)

<QUOTE PREVIOUSPOST="
&gt; Three potential solutions to fix your unsound comments.

&gt; 1) Re-read those books.
&gt; 2) Get more modern/informative books.
&gt; 3) Try a little practical implementation so you can see why it is so
&gt; foolish to back such inconsistent theories or potential
&gt; misunderstandings.
">

Luckily, just re-reading them was enough to convince me of my error.
My confusion was due to putting too much emphasis on the fact that
blocks always contain pages that are assigned to contiguous regions of
a process' address space.  It is true that it is possible to fragment
(make a mess of) the process' address space, but this should only
happen due to extremely bad code or via intentional effort on the part
of the programmer.  Even then, I suspect that any &quot;fragmentation wall&quot;
is purely theoretical because your process would be stopped long
before it could be hit.

Also, if you write an application that is extremely memory-hungry, you
need to scrap everything and go back to the flow-charts for an
entirely different design.

Nathan.
</POST>
<POST>
<POSTER> Keith Kanios &lt;ke...@kanios.net&gt; </POSTER>
<POSTDATE> 2007-11-20T09:05:00 </POSTDATE>
On Nov 19, 3:34 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 18, 12:46 am, Keith Kanios &lt;ke ... @kanios.net&gt; wrote:

&gt; &gt; Ah... theory. Leaves a nice warm feeling, doesn't it?

&gt; ... and leads to my trade-mark trait of &quot;going off half-cocked!&quot;  ;)
">

There's nothing to prove around here, only knowledge to gain and
eventually give back.

<QUOTE PREVIOUSPOST="
&gt; &gt; Three potential solutions to fix your unsound comments.

&gt; &gt; 1) Re-read those books.
&gt; &gt; 2) Get more modern/informative books.
&gt; &gt; 3) Try a little practical implementation so you can see why it is so
&gt; &gt; foolish to back such inconsistent theories or potential
&gt; &gt; misunderstandings.

&gt; Luckily, just re-reading them was enough to convince me of my error.
&gt; My confusion was due to putting too much emphasis on the fact that
&gt; blocks always contain pages that are assigned to contiguous regions of
&gt; a process' address space.  It is true that it is possible to fragment
&gt; (make a mess of) the process' address space, but this should only
&gt; happen due to extremely bad code or via intentional effort on the part
&gt; of the programmer.  Even then, I suspect that any &quot;fragmentation wall&quot;
&gt; is purely theoretical because your process would be stopped long
&gt; before it could be hit.

&gt; Also, if you write an application that is extremely memory-hungry, you
&gt; need to scrap everything and go back to the flow-charts for an
&gt; entirely different design.

&gt; Nathan.
">

There you go ;)
</POST>
</TEXT>
</BODY>
</DOC>
