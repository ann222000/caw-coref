<DOC>
<DOCID> eng-NG-31-135593-8598145 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-09-06T13:02:00 </DATETIME>
<BODY>
<HEADLINE>
Is this valid code?
</HEADLINE>
<TEXT>
<POST>
<POSTER> Nicola Musatti &lt;nicola.musa...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-06T13:02:00 </POSTDATE>
Hallo,
The following program is supposed to use SFINAE to identify whether a
specific template specialization is defined:

#include &lt;iostream&gt;
#include &lt;ostream&gt;

class A {};
class B {};

template &lt;typename T&gt; class X;

template &lt;&gt; class X&lt;A&gt; {};

template &lt;template &lt;typename&gt; class C, typename T&gt; class is_defined {
typedef char no;
typedef char (&amp;yes)[2];

static no fn( ... );
static yes fn(C&lt;T&gt;);

static C&lt;T&gt; const&amp; make();

public:
static const bool value = sizeof( fn( make() ) ) == sizeof(yes);

<QUOTE PREVIOUSPOST="
};
">

int main() {
std::cout &lt;&lt; is_defined&lt;X, A&gt;::value &lt;&lt; '\n';
std::cout &lt;&lt; is_defined&lt;X, B&gt;::value &lt;&lt; '\n';

<QUOTE PREVIOUSPOST="
}
">

Is this valid? Am I invoking undefined behaviour? I'm asking because
just about every compiler I have access to treats it differently.
Comeau 4.3.8 Beta complains that the return value of make() cannot be
converted to X&lt;B&gt;, because it is incomplete;
Microsoft VC++ 2005 outputs
1
0
as I expected;
g++ 4.2.1 outputs
1
1
to my surprise;
g++ 3.4.5 and CodeGear (Borland) C++Builder 2007 U2 fail to compile
it. Who is right?

Thank you,
Nicola Musatti

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Gianni Mariani &lt;gi3nos...@mariani.ws&gt; </POSTER>
<POSTDATE> 2007-09-07T10:45:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Nicola Musatti wrote:

&gt; Is this valid?
">

I don't think it is valid.  However I think the code below is valid but
it does not work on any of the compilers I tried. I must be missing
something.

#include &lt;iostream&gt;
#include &lt;ostream&gt;

class A {};
class B {};

template &lt;typename T&gt; class X;

template &lt;&gt; class X&lt;A&gt; { };

template &lt;template &lt;typename&gt; class C, typename T&gt; class is_defined {
typedef char no;
typedef char (&amp;yes)[2];

struct Az {};
struct Bz : Az {};
static Bz &amp; bfn();

static C&lt;T&gt;&amp; make();

template &lt;int V&gt;
struct H;

template &lt;typename Z&gt;
static no fn( Z &amp;, Az &amp; );

template &lt;typename Z&gt;
static yes fn( Z &amp;, Bz &amp;, H&lt;sizeof(Z)&gt; * = 0 );

public:
static const bool value = sizeof( fn( make(), bfn() ) ) ==
sizeof(yes);

<QUOTE PREVIOUSPOST="
};
">

int main() {
std::cout &lt;&lt; is_defined&lt;X, A&gt;::value &lt;&lt; '\n';
std::cout &lt;&lt; is_defined&lt;X, B&gt;::value &lt;&lt; '\n';

<QUOTE PREVIOUSPOST="
}
&gt; ... Am I invoking undefined behaviour?
">

Undefined behaviour is usually constrained to code that compiles.  This
does not compile on any of the compilers I tried.

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Marian Ciobanu &lt;ci...@inbox.com&gt; </POSTER>
<POSTDATE> 2007-09-07T19:03:00 </POSTDATE>
Hi,

<QUOTE PREVIOUSPOST="
&gt; Hallo,
&gt; The following program is supposed to use SFINAE to identify whether a
&gt; specific template specialization is defined:
">

I think the code is invalid. I'm surprised that GCC 4.2.1 compiles this,
because GCC 4.1.0 gives, and I believe rightly so, this message:
&quot;invalid use of undefined type 'struct X&lt;B1&gt;'&quot;.

As far as I know, once you have &quot;template &lt;typename T&gt; class X;&quot;,
any attempt to use X&lt;Something&gt; should give an error if X&lt;Something&gt;
isn't defined at the point of usage. SFINEA is about classes that are
defined but don't have some members. I don't think you can do
something with SFINEA for classes that are not defined (but I'll have
to think more about this).

So if it's acceptable to you, my suggestion would be to include some
&quot;dummy&quot;, default implementation of X, with a typedef that's not going
to be used in any class.

It's been a while since the last time I did this kind of things, but
here's what I came up with in a few minutes:

#include &lt;iostream&gt;

class A {};
class B {};

template &lt;typename T&gt; struct X { typedef int DefaultImpl; };

template &lt;template &lt;typename&gt; class C, typename T&gt; class is_defined {
typedef char defined_ret;
typedef char (&amp;default_ret)[2];

template&lt;typename U&gt; static defined_ret fn( ... );
template&lt;typename U&gt; static default_ret
fn(C&lt;U&gt;, typename C&lt;U&gt;::DefaultImpl = 0);

static C&lt;T&gt; const&amp; make();

public:
static const bool value = sizeof( fn&lt;T&gt;( make() ) ) ==
sizeof(defined_ret);

<QUOTE PREVIOUSPOST="
};
">

template &lt;&gt; class X&lt;A&gt; {};

int main() {
std::cout &lt;&lt; is_defined&lt;X, A&gt;::value &lt;&lt; '\n';
std::cout &lt;&lt; is_defined&lt;X, B&gt;::value &lt;&lt; '\n';

<QUOTE PREVIOUSPOST="
}
">

I think it's possible to make this simpler, but I'd have to think
more about it, as my SFINAE is a bit rusty.

If I can come up with a version that doesn't use the &quot;dummy&quot;
implementation, I'll post it later (provided somebody else doesn't
do it first).

<QUOTE PREVIOUSPOST="
&gt; to my surprise;
&gt; g++ 3.4.5 and CodeGear (Borland) C++Builder 2007 U2 fail to compile
&gt; it. Who is right?
">

GCC 3.4 is pretty old, so I wouldn't rely much on what it does.
As for Borland, I don't know about the 2007 version, but previous
versions had serious standard compliance issues.

Ciobi

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Marian Ciobanu &lt;ci...@inbox.com&gt; </POSTER>
<POSTDATE> 2007-09-08T05:47:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Fri, 07 Sep 2007 17:03:17 -0600, Marian Ciobanu wrote:
&gt; I think it's possible to make this simpler, but I'd have to think
&gt; more about it, as my SFINAE is a bit rusty.
">

OK, I guess this is quite simple (but it still requires the &quot;default&quot;
implementation). I reordered the lines to emphasize that what matters
is definition at the point of usage.

#include &lt;iostream&gt;

template &lt;template &lt;typename&gt; class C, typename T&gt; class is_defined {
typedef char (&amp;no)[2];

template&lt;typename U&gt; static char fn( ... );
template&lt;typename U&gt; static no fn(typename C&lt;U&gt;::DefaultImpl);

public:
static const bool value = sizeof( fn&lt;T&gt;(0) ) == sizeof( char );

<QUOTE PREVIOUSPOST="
};
">

template &lt;typename T&gt; struct X { typedef int DefaultImpl; };

class A {};
class B {};

template &lt;&gt; class X&lt;A&gt; {};

int main() {
std::cout &lt;&lt; is_defined&lt;X, A&gt;::value &lt;&lt; '\n';
std::cout &lt;&lt; is_defined&lt;X, B&gt;::value &lt;&lt; '\n';

<QUOTE PREVIOUSPOST="
}
">

Ciobi

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Greg Herlihy &lt;gre...@pacbell.net&gt; </POSTER>
<POSTDATE> 2007-09-08T05:47:00 </POSTDATE>
On 9/6/07 10:02 AM, in article
1189084995.544996.241 ... @k79g2000hse.googlegroups.com, &quot;Nicola Musatti&quot;

<QUOTE PREVIOUSPOST="
&lt;nicola.musa ... @gmail.com&gt; wrote:
&gt; The following program is supposed to use SFINAE to identify whether a
&gt; specific template specialization is defined:
">

In other words, the program is attempting to test whether a particular
template specialization is a complete type - at the point in the translation
unit where the test is applied.

<QUOTE PREVIOUSPOST="
&gt; #include &lt;iostream&gt;

&gt; class A {};
&gt; class B {};

&gt; template &lt;typename T&gt; class X;

&gt; template &lt;&gt; class X&lt;A&gt; {};

&gt; template &lt;template &lt;typename&gt; class C, typename T&gt; class is_defined {
&gt;      typedef char no;
&gt;      typedef char (&amp;yes)[2];

&gt;      static no fn( ... );
&gt;      static yes fn(C&lt;T&gt;);

&gt;      static C&lt;T&gt; const&amp; make();

&gt;    public:
&gt;      static const bool value = sizeof( fn( make() ) ) == sizeof(yes);
&gt; };

&gt; int main() {
&gt;      std::cout &lt;&lt; is_defined&lt;X, A&gt;::value &lt;&lt; '\n';
&gt;      std::cout &lt;&lt; is_defined&lt;X, B&gt;::value &lt;&lt; '\n';
&gt; }

&gt; Is this valid? Am I invoking undefined behaviour? I'm asking because
&gt; just about every compiler I have access to treats it differently.
&gt; Comeau 4.3.8 Beta complains that the return value of make() cannot be
&gt; converted to X&lt;B&gt;, because it is incomplete;
">

The program is valid - it manages to avoid instantiating X&lt;B&gt; (which would
be a compile-time error) but only because the sizeof() expression does not
evaluate its argument. But otherwise the program does not accomplish
anything useful - nor could it ever be made to work as intended. Logically,
it is not possible to write a type trait class (like &quot;is_defined&quot; above) to
test a type for &quot;completeness&quot; - because the completeness of a type is not
an inherent property of that type - nor is it even likely to be a constant.
After all, a type may be incomplete at one point in a source file and be
completed later on in that same source file.

So even if is_defined worked, the fact that the static bool constant,
is_defined&lt;&gt;::value, can be initialized to both &quot;true&quot; and &quot;false&quot;- would
run afoul of C++'s One Definition Rule - as well as other requirements in
the Standard that do not permit the completeness of a type to affect the
semantics of the program.

Moreover, there is nothing useful that a program could do with a working
&quot;is_defined&quot; test in the first place. There are only two possibilities to
consider: either a program uses a particular type only in ways that do not
require that type to be complete (so whether the type is actually complete
or not is utterly irrelevant to the program's behavior); or, the program
uses a particular type in a way that requires a complete type - and in which
case the programmer (to prevent a compile-time error) has no choice but to
make sure that the type in question is complete.

Greg

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Nicola Musatti &lt;nicola.musa...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-10T11:31:00 </POSTDATE>
On Sep 8, 1:03 am, Marian Ciobanu &lt;ci ... @inbox.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi,

&gt; &gt; Hallo,
&gt; &gt; The following program is supposed to use SFINAE to identify whether a
&gt; &gt; specific template specialization is defined:

&gt; I think the code is invalid. I'm surprised that GCC 4.2.1 compiles this,
&gt; because GCC 4.1.0 gives, and I believe rightly so, this message:
&gt; &quot;invalid use of undefined type 'struct X&lt;B1&gt;'&quot;.

&gt; As far as I know, once you have &quot;template &lt;typename T&gt; class X;&quot;,
&gt; any attempt to use X&lt;Something&gt; should give an error if X&lt;Something&gt;
&gt; isn't defined at the point of usage. SFINEA is about classes that are
&gt; defined but don't have some members. I don't think you can do
&gt; something with SFINEA for classes that are not defined (but I'll have
&gt; to think more about this).
">

First of all, there are acceptable uses for incomplete classes, like
declaring pointer or reference values to them, so your first statement
above is not correct. Second, SFINAE is about removing from an
overload set any specialization whose instantiation would cause an
error, regardless what the error is. What makes it difficult to use is
the fact that the error must take place in the instantiation of the
candidate specialization, not in any instantiation that is required by
it.

Thus I believe that simply declaring a member function of a template
that takes an incomplete class as argument not to be a problem.

<QUOTE PREVIOUSPOST="
&gt; So if it's acceptable to you, my suggestion would be to include some
&gt; &quot;dummy&quot;, default implementation of X, with a typedef that's not going
&gt; to be used in any class.
">

This is not acceptable because I cannot modify the one class for which
&quot;is_defined&quot; is needed.

Thanks all the same.

Cheers,
Nicola Musatti

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> &quot;Hendrik Schober&quot; &lt;SpamT...@gmx.de&gt; </POSTER>
<POSTDATE> 2007-09-10T11:31:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Greg Herlihy &lt;gre ... @pacbell.net&gt; wrote:
&gt; On 9/6/07 10:02 AM, in article
&gt; 1189084995.544996.241 ... @k79g2000hse.googlegroups.com, &quot;Nicola Musatti&quot;
&gt; &lt;nicola.musa ... @gmail.com&gt; wrote:

&gt; &gt; The following program is supposed to use SFINAE to identify whether a
&gt; &gt; specific template specialization is defined:
">

In this I recognize a problem I recently asked about in
comp.lang.c++ ( news:46dbfa6b$0$90262$14726298@news.sunsite.dk
starts the thread) where Barry Ding came up with a
might-be solution that looks like what Nicola posted)
and in borland.public.cppbuilder.language.c++ (see

http://groups.google.de/group/borland.public.cppbuilder.language.cpp/...
for the start of that thread) where Sergiy Kanilo came
up with the same idea.

<QUOTE PREVIOUSPOST="
&gt; In other words, the program is attempting to test whether a particular
&gt; template specialization is a complete type - at the point in the translation
&gt; unit where the test is applied.
">

Yep. That was the original problem the code attempted to
be a solution for. :)

<QUOTE PREVIOUSPOST="
&gt; [code snipped]
&gt; The program is valid [...]
">

If so, then it uncovers a bug in Comeau (which it most
likely inherits from its EDG front end) and several
recent GCC versions.

<QUOTE PREVIOUSPOST="
&gt; So even if is_defined worked, the fact that the static bool constant,
&gt; is_defined&lt;&gt;::value, can be initialized to both &quot;true&quot; and &quot;false&quot;- would
&gt; run afoul of C++'s One Definition Rule - as well as other requirements in
&gt; the Standard that do not permit the completeness of a type to affect the
&gt; semantics of the program.
">

I see. Chris Uzdavinis already said something similar.
(To this, Sergiy suggested using an unnamed namespace,
BTW.) However, in the cases I would be interested in
(see below), this wouldn't matter, as the meta function
would only ever be applied in the same context (i.e.,
the template always either is a complete type or not).

<QUOTE PREVIOUSPOST="
&gt; Moreover, there is nothing useful that a program could do with a working
&gt; &quot;is_defined&quot; test in the first place.
">

This depends upon your definition of &quot;usefulness&quot;. :)

<QUOTE PREVIOUSPOST="
&gt;                                       There are only two possibilities to
&gt; consider: either a program uses a particular type only in ways that do not
&gt; require that type to be complete (so whether the type is actually complete
&gt; or not is utterly irrelevant to the program's behavior); or, the program
&gt; uses a particular type in a way that requires a complete type - and in which
&gt; case the programmer (to prevent a compile-time error) has no choice but to
&gt; make sure that the type in question is complete.
">

In b.p.c.l.c++ I gave example where I'd consider this a
useful meta function [the following slightly edited to
fix typos and to somewhat condense it]:
&quot;The standard requires a std lib implementation to
provide (in namespace 'std'):
template&lt; typename T &gt; struct char_traits;
template&lt;&gt; struct char_traits&lt;char&gt; { /* ... */ };
template&lt;&gt; struct char_traits&lt;wchar_t&gt; { /* ... */ };
Many std lib implementations provide this and no more.
Some (e.g., Dinkumware) also provide an implementation
for the primary template.
Now, if you need 'std::char_traits&lt;unsigned char&gt;',
according to the standard you need to write your own.
This isn't hard, but given what I do and what the guys
at DW do for a living, it's likely their version is
better than mine. So if I'm on a platform where there
is an implementation for traits for 'unsigned char', I
want to use this. If not, I want to use mine. This is
a decision that needs to be done at compile-time, as I
need to define types with either of the traits.
Of course, I could do this with a lot of '#if's. But
given that we herd a whole bunch of compilers and std
lib implementations (and versions and combinations
thereof), I'd rather not do this. (It's just another
thing you have to fiddle with when you port to a new
platform/compiler/std lib/version.)&quot;
Incidently, in the same message I re-phrased the original
question as:
&quot;Given that I know what's supposed in such a template
(which is true for 'std::char_traits'), isn't there a
way to determine (again, at compile-time) whether a
template has a specific member that yields no if the
template isn't defined?&quot;
ISTR having heard about some 'has_member&lt;&gt;' meta fucntion.

<QUOTE PREVIOUSPOST="
&gt; Greg
">

Schobi

--
SpamT ... @gmx.de is never read
I'm HSchober at gmx dot de
&quot;A patched buffer overflow doesn't mean that there's one less way attackers
can get into your system; it means that your design process was so lousy
that it permitted buffer overflows, and there are probably thousands more
lurking in your code.&quot;
Bruce Schneier

[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Nicola Musatti &lt;nicola.musa...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-10T11:32:00 </POSTDATE>
On Sep 8, 11:47 am, Greg Herlihy &lt;gre ... @pacbell.net&gt; wrote:
[...]

<QUOTE PREVIOUSPOST="
&gt; The program is valid - it manages to avoid instantiating X&lt;B&gt; (which would
&gt; be a compile-time error) but only because the sizeof() expression does not
&gt; evaluate its argument. But otherwise the program does not accomplish
&gt; anything useful - nor could it ever be made to work as intended. Logically,
&gt; it is not possible to write a type trait class (like &quot;is_defined&quot; above) to
&gt; test a type for &quot;completeness&quot; - because the completeness of a type is not
&gt; an inherent property of that type - nor is it even likely to be a constant.
&gt; After all, a type may be incomplete at one point in a source file and be
&gt; completed later on in that same source file.
">

[...]

<QUOTE PREVIOUSPOST="
&gt; Moreover, there is nothing useful that a program could do with a working
&gt; &quot;is_defined&quot; test in the first place. There are only two possibilities to
&gt; consider: either a program uses a particular type only in ways that do not
&gt; require that type to be complete (so whether the type is actually complete
&gt; or not is utterly irrelevant to the program's behavior); or, the program
&gt; uses a particular type in a way that requires a complete type - and in which
&gt; case the programmer (to prevent a compile-time error) has no choice but to
&gt; make sure that the type in question is complete.
">

Actually my program is an attempt to solve a problem pointed out by a
friend in a different newsgroup, namely the lack of an is_specialized
static data member in std::char_traits.

As not all available standard library implementations provide
specializations for all standard character variants he wrote his own
specializations, but would rather use the original ones when
available.

Cheers,
Nicola Musatti

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Marian Ciobanu &lt;ci...@inbox.com&gt; </POSTER>
<POSTDATE> 2007-09-11T10:55:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Mon, 10 Sep 2007 09:31:51 -0600, Nicola Musatti wrote:
&gt; First of all, there are acceptable uses for incomplete classes, like
&gt; declaring pointer or reference values to them, so your first statement
&gt; above is not correct. Second, SFINAE is about removing from an
&gt; overload set any specialization whose instantiation would cause an
&gt; error, regardless what the error is.
">

I guess my wording wasn't right. Of course pointers and references
to an undefined class can be used. I use them all the time. I was
talking about classes, not pointers to classes. You can use &quot;C&lt;T&gt;*&quot;
all you want. The troubles start the moment you use just &quot;C&lt;T&gt;&quot; and
it's not defined but the compiler wants to instantiate it. And the
question here is whether the compiler should instantiate X&lt;B&gt; or
not. I believe it should (and later remove it at link time, because
it's not actually used), but a &quot;language lawyer&quot; is better prepared
to answer this.

As for the SFINAE I would make 2 statements:
1) SFINAE does care about what errors you get. On page 107 of &quot;C++
Templates&quot; by D. Vandevoorde &amp; N. Josuttis you'll find this:

&quot;The SFINAE principle protects only against attempts to create
invalid types but not against attempts to evaluate invalid
expressions. The following example is therefore invalid C++:

template&lt;int I&gt; void f(int (&amp;)[24/(4-I)]);
template&lt;int I&gt; void f(int (&amp;)[24/(4+I)]);

int main()
{
&amp;f&lt;4&gt;;   // ERROR: division by zero (SFINAE doesn't apply)

<QUOTE PREVIOUSPOST="
}&quot;
">

(GCC 4.1.0 seems seriously broken when dealing with this example.
Hopefully that's fixed in 4.2; I'm quite sure that the example
is correct.)

2) All the code that I've seen (and that I've wrote) that used
SFINAE involved a template function (global or member). Your &quot;fn&quot;
functions are not template functions. They are regular functions,
members of a template class. Here's a little piece of code that
fails to compile on GCC 4.1.0 and on MSVC 2005 SP1 (and I guess
on other systems too), because &quot;f&quot; are regular functions and so
SFINAE doesn't apply to them. It doesn't matter that they are
never called. The mere existence of the second one causes an error
if T doesn't have a Q.

template &lt;class T&gt;
struct X
{
int f(...) { return 0; }
int f(typename T::Q) { return 1; }

<QUOTE PREVIOUSPOST="
};
">

struct A { typedef int Q; };
struct B {};

int main()
{
X&lt;A&gt; xa;
X&lt;B&gt; xb;

<QUOTE PREVIOUSPOST="
}
">

So if SFINAE removed all overloads that would create errors, it
should have removed the second &quot;f&quot; in X&lt;B&gt; to make the code
compilable. But it didn't, because only template overloads are
removed, and they are removed if there's a missing type in their
signature, not if they have some other errors in their signatures
or their body.

Regards,
Ciobi

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Nicola Musatti &lt;nicola.musa...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-12T13:04:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Marian Ciobanu wrote:
&gt; On Mon, 10 Sep 2007 09:31:51 -0600, Nicola Musatti wrote:
[...]
&gt; As for the SFINAE I would make 2 statements:
&gt; 1) SFINAE does care about what errors you get. On page 107 of &quot;C++
&gt; Templates&quot; by D. Vandevoorde &amp; N. Josuttis you'll find this:

&gt; &quot;The SFINAE principle protects only against attempts to create
&gt; invalid types but not against attempts to evaluate invalid
&gt; expressions.
">

Of course.

<QUOTE PREVIOUSPOST="
&gt; 2) All the code that I've seen (and that I've wrote) that used
&gt; SFINAE involved a template function (global or member). Your &quot;fn&quot;
&gt; functions are not template functions. They are regular functions,
&gt; members of a template class.
">

As far as I know this only implies that their *declarations* are
instantiated whenever their class definition is instantiated, but as
declaring a function to take an incomplete type as argument is not an
error, this shouldn't cause any problem.

<QUOTE PREVIOUSPOST="
&gt; Here's a little piece of code that
&gt; fails to compile [...] because &quot;f&quot; are regular functions and so
&gt; SFINAE doesn't apply to them. It doesn't matter that they are
&gt; never called.

&gt; The mere existence of the second one causes an error
&gt; if T doesn't have a Q.

&gt; template &lt;class T&gt;
&gt; struct X
&gt; {
&gt;      int f(...) { return 0; }
&gt;      int f(typename T::Q) { return 1; }
&gt; };
">

The problem here is that if T doesn't have a Q the *declaration* of
the second f() overload is invalid and as this declaration is
instantiated whenever the corresponding class definition is, this is
always an error.

<QUOTE PREVIOUSPOST="
&gt; struct A { typedef int Q; };
&gt; struct B {};

&gt; int main()
&gt; {
&gt;      X&lt;A&gt; xa;
&gt;      X&lt;B&gt; xb;
&gt; }

&gt; So if SFINAE removed all overloads that would create errors, it
&gt; should have removed the second &quot;f&quot; in X&lt;B&gt; to make the code
&gt; compilable. But it didn't, because only template overloads are
&gt; removed, and they are removed if there's a missing type in their
&gt; signature, not if they have some other errors in their signatures
&gt; or their body.
">

You seem to be forgetting that SFINAE takes place only when the
construction of an overload candidate set requires some function
template to be instantiated. If such an instantiation would result in
an error the candidate is discarded, but the error is not reported. In
your case there's no call to f() so no overload candidate set is
built.

Let's go back to my example.

static no fn( ... );
static yes fn(C&lt;T&gt;);

Just declaring these should be no problem.

static C&lt;T&gt; const&amp; make();

This returns a reference, so no problem here too.

static const bool value = sizeof( fn( make() ) ) == sizeof(yes);

Here I'm now less sure. I'm convinced that the second overload should
be removed by SFINAE, but does the ellipsis cause a C&lt;T&gt; const&amp; to
C&lt;T&gt; conversion? If that was the case, this would be an error.

Cheers,
Nicola Musatti

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
<POST>
<POSTER> Marian Ciobanu &lt;ci...@inbox.com&gt; </POSTER>
<POSTDATE> 2007-09-13T12:49:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, 12 Sep 2007 11:04:35 -0600, Nicola Musatti wrote:
&gt;      static const bool value = sizeof( fn( make() ) ) == sizeof(yes);

&gt; Here I'm now less sure. I'm convinced that the second overload should
&gt; be removed by SFINAE, but does the ellipsis cause a C&lt;T&gt; const&amp; to
">

Right now I still believe what I stated in my prior posts: that SFINAE
only covers template functions, and becase your functions are
non-template, this is not a SFINAE issue. I'll try to start a new
thread to clarify this.

However, I have now a slightly more articulate view about why I think
the code is invalid. The issue is the second fn. When the compiler is
trying to evaluate &quot;value&quot;, it has to decide whether it should &quot;call&quot;
the first or the second fn. (Well, it doesn't really call it, it just
needs to know if it can be called, to know the size of the result;
I'll use the word &quot;call&quot; in the rest of the post, but I know that no
actual call is ever made).

GCC 4.2.1 says: &quot;well, classes usually have a public copy constructor,
so I'll just assume X&lt;B&gt; has one as well, so I'll consider the call to
the second fn valid; therefore &quot;value&quot; is always going to be true&quot;.

MSVC says: &quot;I don't know who this X&lt;B&gt; is, so I'm just going to ignore
it and consider only the call to the first &quot;fn&quot; as valid and I'll
ignore the second.&quot; This doesn't really test if a specialization
exist, though, even assuming the reasoning is correct. Just add this
line after the specialization for X&lt;A&gt;:

template &lt;&gt; class X&lt;B&gt; { X(const X&amp;); };

Now all the compilers will complain that the copy constructor is
private. So a specialization exists but you can't even compile, let
alone test if the specialization exists.

On the other hand, GCC 4.1.0 says: &quot;I don't know who this X&lt;B&gt; is, so
I won't have anything to do with it. I need to know its definition in
order to determine whether I should &quot;call&quot; the second fn or I should
generate a compiler error.&quot;

---------------------------------

I think GCC 4.1.0 is right and I find both the GCC 4.2.1 and MSVC 2005
ureasonable (although I'll admit that the standard might actually
state that one of them is correct). I think the second fn can never be
discarded, because it's not a template function. So there are these
options:
- A specialization with a public copy constructor exists, value=true
- A specialization with a non-public copy constructor exists,
compiler error
- A specialization doesn't exists, compiler error

(For replies about whether SFINAE can apply to non-template functions
please use the other thread that I'm going to create, to focus on this
issue alone and leave this thread for finding a solution to
determining whether a specialization of a class exists.)

Ciobi

--
[ See http://www.gotw.ca/resources/clcm.htm for info about ]
[ comp.lang.c++.moderated.    First time posters: Do this! ]
</POST>
</TEXT>
</BODY>
</DOC>
