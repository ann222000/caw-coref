<DOC>
<DOCID> eng-NG-31-127467-9235961 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-10-01T19:50:00 </DATETIME>
<BODY>
<HEADLINE>
HLA stdlib v2.3 is now available
</HEADLINE>
<TEXT>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-01T19:50:00 </POSTDATE>
Hi All,

The HLA Standard Library, v2.2 is now available on Webster.
You can download a copy from the stdlib v2.x support page:

http://webster.cs.ucr.edu/AsmTools/HLA/stdlib2/index.html

v2.3of the HLA stdlib includes rewritten code (from HLA stdlib v1.x)
and a complete test suite for all the functions.

This release fully supports Windows and Linux and is &quot;code complete&quot;
with respect to the functionality found the in original HLA stdlib
v1.x (obviously, there are lots of new functions coming down the pike,
including a bunch of user-contributed functions by Sevag). Indeed,
only the documentation needs to be brought up to date (that will be
v2.4) before the port to FreeBSD begins (which will be v3.0).

One of the principal benefits of the v2.x standard library over the
older 1.x library is the new automated regression test suite. This
code automatically checks the operation of just about every function
in the standard library using a wide range of input values (some
functions only a few checks, some functions get as many as a billion
checks -- it all depends on the semantics of the function).

The HLA stdlib v2.x has been completely refactored/rewritten from v1.x
over the past year. This refactoring has resulted in more efficient
(faster) code as well as code that is much more stable.  100s of
defects have been eradicated from the old code. Furthermore, the
semantics of the functions across multiple OSes has been *greatly*
enhanced. With this release, about the only difference you'll find
between applications written for Linux versus Windows is the end-of-
line character that is written to files.  The HLA stdlib version 2.3
eliminates many of the nagging inconsistencies that created problems
for some HLA programmers doing cross-platform work in the past.

The HLA stdlib v2.x also includes an automated build generator that
will automatically generate a set of make files for the library code
(including any new functions the user might want to add). This
&quot;mkmake&quot; program recursively determines all the dependencies in the
HLA and HHF files and creates appropriate make files for Windows or
Linux/*NIX. This eliminates a lot of maintenance headaches for someone
who is working on the library, especially for newcomers to the project
who might otherwise feel overwhelmed by the magnitude of the project.

Another advantage to the new code is that it is almost completely
written in &quot;pure&quot; assembly language, so it can serve as an advanced
assembly language educational tool (the code is not suitable for
beginners as much of it is a bit too advanced for them, but it's great
code for someone to look at as they begin to gain some experience with
assembly language).

The HLA standard library includes over 1,000 functions and macros
callable from assembly language programs.  Combined with the test
suite, the entire library represents nearly 400,000 lines of assembly
code.  Compressed, the library module consumes 4.6 MB, it expands to
over 23 MB of source code and test data (not including object and
library files).

The library itself is currently organized into the following modules:

args -- command-line argument manipulation.
arrays -- array manipulation
bits -- bit manipulation
chars  -- character routines and predicates
conv  -- conversion functions
cset -- character set operations
datetime -- date and time calculations
fileclass -- object-oriented file operations
fileio -- file operations.
lists -- object-oriented list operations
math -- extended precision integer operations and floating-point
functions
memory -- memory allocation and deallocation.
os_console -- console app display manipulation
os_coroutines -- coroutine support
os_dependent  -- miscellaneous OS dependent functions.
os_env -- environment variable support
os_excepts -- exception handling support
os_fileio -- file I/O functions (platform-dependent code)
os_filesys -- file system operations (platform-dependent code)
os_linux -- Linux support functions
os_memmap -- Memory-mapped file support code.
os_timer -- code timing support
os_windows -- Windows support functions
patterns -- pattern matching library
random -- random number generators
stderr -- output to the standard error device
stdin  -- input from the standard input device
stdout  -- output to the standard output device
strings -- character string functions
zstrings -- zstring functions.

Over the years, the HLA standard library has been, without question,
the favorite component of the HLA system by HLA users. This new
library will certainly carry on that tradition.

Ultimately, the goal is to get this project completely supported on
SourceForge (there's actually a page there already, but it only
contains the compressed files; eventually the plan is to use the
source-code control facilities of Source Forge for world-wide
developer access to individual functions).  The HLA standard library
is current maintained on the Subversion source code control system,
which will mesh quite well with SourceForge.

Enjoy!
Randy Hyde
</POST>
<POST>
<POSTER> &quot;Ratch&quot; &lt;watc...@comcast.net&gt; </POSTER>
<POSTDATE> 2007-10-01T22:06:00 </POSTDATE>
Betov,

Here's another release of the HLA Standard Library.  It's another
opportunity for you to restrain, contain, and retain any bad comments you
have about it.  Instead you can concentrate on answering the points made by
others who have answered your invective abusive ejecta with coherent cogent
commentary that refutes your odious ominous outbursts.  Especially
interesting to me would be your explanation of why it is ethical to be in
Iran.

Ratch

<QUOTE PREVIOUSPOST="
&lt;rh ... @cs.ucr.edu&gt; wrote in message
">

news:1191282607.634019.128220@y42g2000hsy.googlegroups.com ...

<QUOTE PREVIOUSPOST="
&gt; Hi All,

&gt; The HLA Standard Library, v2.2 is now available on Webster.
&gt; You can download a copy from the stdlib v2.x support page:

&gt; http://webster.cs.ucr.edu/AsmTools/HLA/stdlib2/index.html

&gt; v2.3of the HLA stdlib includes rewritten code (from HLA stdlib v1.x)
&gt; and a complete test suite for all the functions.

&gt; This release fully supports Windows and Linux and is &quot;code complete&quot;
&gt; with respect to the functionality found the in original HLA stdlib
&gt; v1.x (obviously, there are lots of new functions coming down the pike,
&gt; including a bunch of user-contributed functions by Sevag). Indeed,
&gt; only the documentation needs to be brought up to date (that will be
&gt; v2.4) before the port to FreeBSD begins (which will be v3.0).

&gt; One of the principal benefits of the v2.x standard library over the
&gt; older 1.x library is the new automated regression test suite. This
&gt; code automatically checks the operation of just about every function
&gt; in the standard library using a wide range of input values (some
&gt; functions only a few checks, some functions get as many as a billion
&gt; checks -- it all depends on the semantics of the function).

&gt; The HLA stdlib v2.x has been completely refactored/rewritten from v1.x
&gt; over the past year. This refactoring has resulted in more efficient
&gt; (faster) code as well as code that is much more stable.  100s of
&gt; defects have been eradicated from the old code. Furthermore, the
&gt; semantics of the functions across multiple OSes has been *greatly*
&gt; enhanced. With this release, about the only difference you'll find
&gt; between applications written for Linux versus Windows is the end-of-
&gt; line character that is written to files.  The HLA stdlib version 2.3
&gt; eliminates many of the nagging inconsistencies that created problems
&gt; for some HLA programmers doing cross-platform work in the past.

&gt; The HLA stdlib v2.x also includes an automated build generator that
&gt; will automatically generate a set of make files for the library code
&gt; (including any new functions the user might want to add). This
&gt; &quot;mkmake&quot; program recursively determines all the dependencies in the
&gt; HLA and HHF files and creates appropriate make files for Windows or
&gt; Linux/*NIX. This eliminates a lot of maintenance headaches for someone
&gt; who is working on the library, especially for newcomers to the project
&gt; who might otherwise feel overwhelmed by the magnitude of the project.

&gt; Another advantage to the new code is that it is almost completely
&gt; written in &quot;pure&quot; assembly language, so it can serve as an advanced
&gt; assembly language educational tool (the code is not suitable for
&gt; beginners as much of it is a bit too advanced for them, but it's great
&gt; code for someone to look at as they begin to gain some experience with
&gt; assembly language).

&gt; The HLA standard library includes over 1,000 functions and macros
&gt; callable from assembly language programs.  Combined with the test
&gt; suite, the entire library represents nearly 400,000 lines of assembly
&gt; code.  Compressed, the library module consumes 4.6 MB, it expands to
&gt; over 23 MB of source code and test data (not including object and
&gt; library files).

&gt; The library itself is currently organized into the following modules:

&gt; args -- command-line argument manipulation.
&gt; arrays -- array manipulation
&gt; bits -- bit manipulation
&gt; chars  -- character routines and predicates
&gt; conv  -- conversion functions
&gt; cset -- character set operations
&gt; datetime -- date and time calculations
&gt; fileclass -- object-oriented file operations
&gt; fileio -- file operations.
&gt; lists -- object-oriented list operations
&gt; math -- extended precision integer operations and floating-point
&gt; functions
&gt; memory -- memory allocation and deallocation.
&gt; os_console -- console app display manipulation
&gt; os_coroutines -- coroutine support
&gt; os_dependent  -- miscellaneous OS dependent functions.
&gt; os_env -- environment variable support
&gt; os_excepts -- exception handling support
&gt; os_fileio -- file I/O functions (platform-dependent code)
&gt; os_filesys -- file system operations (platform-dependent code)
&gt; os_linux -- Linux support functions
&gt; os_memmap -- Memory-mapped file support code.
&gt; os_timer -- code timing support
&gt; os_windows -- Windows support functions
&gt; patterns -- pattern matching library
&gt; random -- random number generators
&gt; stderr -- output to the standard error device
&gt; stdin  -- input from the standard input device
&gt; stdout  -- output to the standard output device
&gt; strings -- character string functions
&gt; zstrings -- zstring functions.

&gt; Over the years, the HLA standard library has been, without question,
&gt; the favorite component of the HLA system by HLA users. This new
&gt; library will certainly carry on that tradition.

&gt; Ultimately, the goal is to get this project completely supported on
&gt; SourceForge (there's actually a page there already, but it only
&gt; contains the compressed files; eventually the plan is to use the
&gt; source-code control facilities of Source Forge for world-wide
&gt; developer access to individual functions).  The HLA standard library
&gt; is current maintained on the Subversion source code control system,
&gt; which will mesh quite well with SourceForge.

&gt; Enjoy!
&gt; Randy Hyde
">
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-02T03:46:00 </POSTDATE>
&quot;Ratch&quot; &lt;watc ... @comcast.net&gt; écrivait
news:N8CdnUHwzZkuOpzanZ2dnUVZ_gidnZ2d@comcast.com:

<QUOTE PREVIOUSPOST="
&gt; Betov,

&gt;      Here's another release of the HLA Standard Library.  It's another
&gt; opportunity for you to restrain, contain, and retain any bad comments
&gt; you have about it.
">

Sorry, but i have no comment to do about an HLL Library.
HLLs need Libraries. So, it is normal for HLA to have one.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> hutch-- &lt;hu...@movsd.com&gt; </POSTER>
<POSTDATE> 2007-10-02T07:48:00 </POSTDATE>
Ho ho ho,

<QUOTE PREVIOUSPOST="
&gt; Sorry, but i have no comment to do about an HLL Library.
&gt; HLLs need Libraries. So, it is normal for HLA to have one.
">

Ony assemblers powerful enough can use libraries, whats wrong with
RotAsm ? Can't your crappy little compiler do something this simple
for almost every other assembler available ?
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-02T20:11:00 </POSTDATE>
On Oct 2, 3:46 am, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;Ratch&quot; &lt;watc ... @comcast.net&gt; écrivait news:N8CdnUHwzZkuOpzanZ2dnUVZ_gidnZ2d@comcast.com:

&gt; &gt; Betov,

&gt; &gt;      Here's another release of the HLA Standard Library.  It's another
&gt; &gt; opportunity for you to restrain, contain, and retain any bad comments
&gt; &gt; you have about it.

&gt; Sorry, but i have no comment to do about an HLL Library.
&gt; HLLs need Libraries.
">

No they don't.  It's more convenient to have them.

<QUOTE PREVIOUSPOST="
&gt; So, it is normal for HLA to have one.
">

It doesn't need one either.  It is convenient for it to have one.  A
very  useful bonus feature missing from Rotty.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T03:49:00 </POSTDATE>
&quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait
news:1191370271.343937.174870@50g2000hsm.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt; It is convenient for it to have one.  A
&gt; very  useful bonus feature missing from Rotty
">

Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> hutch-- &lt;hu...@movsd.com&gt; </POSTER>
<POSTDATE> 2007-10-03T05:29:00 </POSTDATE>
smile,

<QUOTE PREVIOUSPOST="
&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.
">

Not being capable of either is typical of RotAsm. Fortunately is has
very few victims, Betov and half wit.
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T06:10:00 </POSTDATE>
hutch-- &lt;hu ... @movsd.com&gt; écrivait news:1191403788.030288.99030
@g4g2000hsf.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt;&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

&gt; Not being capable of either is typical of RotAsm.
">

Keep sure that the RosAsm Code-Reuse does not match with
your Power-Basic programing habits, Dictionary-Ass.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T11:27:00 </POSTDATE>
On Oct 3, 3:49 am, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait news:1191370271.343937.174870@50g2000hsm.googlegroups.com:

&gt; &gt; It is convenient for it to have one.  A
&gt; &gt; very  useful bonus feature missing from Rotty

&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

&gt; Betov.

&gt; &lt; http://rosasm.org &gt;
">

Creating custom definitions for words and inventing new words with
constantly changing meanings is typical to Betov.

Apart from pointing out your stupidity, this has nothing to do with my
reply to your erroneous statement of:

&quot;Sorry, but i have no comment to do about an HLL Library.  HLLs need
Libraries.&quot;

I correctly pointed out your bullshit again.  I understand that you
are shamed and unable to make a coherent response to this.  Not to
worry though, people are already aware that you are clueless when it
comes to programming concepts.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T12:12:00 </POSTDATE>
&quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait
news:1191425241.354466.195660@19g2000hsx.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt;&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

&gt; Creating custom definitions for words and inventing new words with
&gt; constantly changing meanings is typical to Betov.
">

As you seem to be completely ignorant, Code-Reuse may include
Libraries for HLLs, but evidently not for Assembly, for which
better methods exist.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> Frank Kotler &lt;fbkot...@verizon.net&gt; </POSTER>
<POSTDATE> 2007-10-03T14:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Betov wrote:
&gt; &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait
&gt; news:1191425241.354466.195660@19g2000hsx.googlegroups.com:

&gt;&gt;&gt;Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

&gt;&gt;Creating custom definitions for words and inventing new words with
&gt;&gt;constantly changing meanings is typical to Betov.

&gt; As you seem to be completely ignorant, Code-Reuse may include
&gt; Libraries for HLLs, but evidently not for Assembly, for which
&gt; better methods exist.
">

I'll confess my ignorance (without Herbert having to prove it). I'm
unclear as to where the distinction between asm and HLL falls (by your
definition). If I do:

;------------------------
; this is module1.asm
; nasm -f elf module1.asm
; nasm -f elf module2.asm
; ld -o program module1.o module2.o

global _start

extern my_write

section .text
_start:
mov eax, msg
call my_write

mov ebx, eax
mov eax, 1
int 80h
msg db 'Hello from module one!', 10, 0
;--------------------------------

;------------------------
; this is module2.asm
; nasm -f elf module1.asm
; nasm -f elf module2.asm
; ld -o program module1.o module2.o

global my_write

section .text

my_write:
mov ecx, eax
or edx, byte -1
getlen:
cmp byte [ecx + edx + 1], 1
inc edx
jnc getlen
mov ebx, 1
mov eax, 4
int 80h
ret
;---------------------

If I assemble these two files and link 'em together as indicated, is
this asm or HLL?

Best,
Frank
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-03T15:03:00 </POSTDATE>
Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait news:g%QMi.4392$PV1.1294
@trndny08:

<QUOTE PREVIOUSPOST="
&gt; If I assemble these two files and link 'em together as indicated, is
&gt; this asm or HLL?
">

You give an example of an Assembly File using an HLL
programming *method*. Why do you think i always refused
to assume static libs, in RosAsm? Because i am unable to
implement this?

I knew, since day one, that refusing to implement that
shit, would dramaticaly limit the number of RosAsm users,
and that implementing it would turn RosAsm into an Assembler
like all of the other ones. That is: An Assembler for doing
nothing.

If the problem was really what it should be, that is, which
Code-Reuse *method* for Assembly, there would not be any
discussion about doing it with DLLs, Static Libs, or Asm
Snippets. This is *not* the real problem. The real problem
is that almost everybody *refuse* to even consider writing
Applications in Assembly, and want to do that in HLL.
Therefore, an Assembler not enabling .libs becomes useless
for all those blind people. If i had wanted to work for blind
people, i would have produced white canes. Not an Assembler.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-03T15:19:00 </POSTDATE>
On Oct 1, 7:50 pm, &quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi All,

&gt; The HLA Standard Library, v2.2 is now available on Webster.
&gt; You can download a copy from the stdlib v2.x support page:

&gt; http://webster.cs.ucr.edu/AsmTools/HLA/stdlib2/index.html

&gt; v2.3of the HLA stdlib includes rewritten code (from HLA stdlib v1.x)
&gt; and a complete test suite for all the functions.

&gt; This release fully supports Windows and Linux and is &quot;code complete&quot;
&gt; with respect to the functionality found the in original HLA stdlib
&gt; v1.x (obviously, there are lots of new functions coming down the pike,
&gt; including a bunch of user-contributed functions by Sevag). Indeed,
&gt; only the documentation needs to be brought up to date (that will be
&gt; v2.4) before the port to FreeBSD begins (which will be v3.0).
">

As one can read here...

http://board.flatassembler.net/topic.php?t=7639

...it is clear why 'vid' is particularly interested in the StdLib 2.x
code.  Now he is asking for an example of how to use the library from
Fasm code:

http://board.flatassembler.net/topic.php?t=7682

I guess I 'could' tell him that someone once wrote a wrapper around
Fasm.  In fact, that same someone also wrote a book called &quot;Art o'
FASM&quot; which can be found at the following URL:

http://www.artofasm.com

;-)

Nathan.
</POST>
<POST>
<POSTER> Frank Kotler &lt;fbkot...@verizon.net&gt; </POSTER>
<POSTDATE> 2007-10-03T15:34:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Evenbit wrote:
&gt; On Oct 1, 7:50 pm, &quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; wrote:

&gt;&gt;Hi All,

&gt;&gt;The HLA Standard Library, v2.2 is now available on Webster.
&gt;&gt;You can download a copy from the stdlib v2.x support page:

&gt;&gt; http://webster.cs.ucr.edu/AsmTools/HLA/stdlib2/index.html

&gt;&gt;v2.3of the HLA stdlib includes rewritten code (from HLA stdlib v1.x)
&gt;&gt;and a complete test suite for all the functions.

&gt;&gt;This release fully supports Windows and Linux and is &quot;code complete&quot;
&gt;&gt;with respect to the functionality found the in original HLA stdlib
&gt;&gt;v1.x (obviously, there are lots of new functions coming down the pike,
&gt;&gt;including a bunch of user-contributed functions by Sevag). Indeed,
&gt;&gt;only the documentation needs to be brought up to date (that will be
&gt;&gt;v2.4) before the port to FreeBSD begins (which will be v3.0).

&gt; As one can read here...

&gt; http://board.flatassembler.net/topic.php?t=7639

&gt; ...it is clear why 'vid' is particularly interested in the StdLib 2.x
&gt; code.  Now he is asking for an example of how to use the library from
&gt; Fasm code:
">

http://webster.cs.ucr.edu/AsmTools/FASM/HLA4FASM.html

Best,
Frank
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-03T15:36:00 </POSTDATE>
On Oct 3, 3:03 pm, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait news:g%QMi.4392$PV1.1294
&gt; @trndny08:

&gt; &gt; If I assemble these two files and link 'em together as indicated, is
&gt; &gt; this asm or HLL?

&gt; You give an example of an Assembly File using an HLL
&gt; programming *method*.
">

All of the instructional material that *I* have been reading give me
the impression that the issue is not a HLL vs. ASM one but instead is
a Modern OS vs. Obsolete OS issue.  Programmers are encouraged to use
dynamic linking on modern operating systems to save on resources.  The
fact that static linking still enjoys wide-spread use serves to
demonstrate that this older method still holds value within the
programming community.

Nathan.
</POST>
<POST>
<POSTER> &quot;Wolfgang Kern&quot; &lt;nowh...@never.at&gt; </POSTER>
<POSTDATE> 2007-10-03T17:58:00 </POSTDATE>
Frank Kotler replied to Betov:

<QUOTE PREVIOUSPOST="
&gt;&gt;&gt;&gt;Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical ....
">

I see this as either 'merging binaries' (my prefered method), or
merging text sources (regardless if 'include LIB' or 'copy-paste').

The latter seem to be the issue for all this discussion about,
for me it is all the same: insert prepared text into a text source.
So what was this discusion all about ?

Libraries often (always) contain things that aren't needed at all.
Code re-use (I think Rene meant source re-use here) can save on
many redundant lines.

The other known way with Oject-linking is the worst case scenario.

__
wolfgang
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T18:52:00 </POSTDATE>
On Oct 3, 12:12 pm, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait news:1191425241.354466.195660@19g2000hsx.googlegroups.com:

&gt; &gt;&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.

&gt; &gt; Creating custom definitions for words and inventing new words with
&gt; &gt; constantly changing meanings is typical to Betov.

&gt; As you seem to be completely ignorant, Code-Reuse may include
&gt; Libraries for HLLs, but evidently not for Assembly,
">

What evidence is that?

for which

<QUOTE PREVIOUSPOST="
&gt; better methods exist.

&gt; Betov.

&gt; &lt; http://rosasm.org &gt;
">

Cut-and-paste is NOT a better method of code reuse and there is much
evidence for this: the fact most programming tools support library
linking and most programmers use libraries.

The difference is obvious for anyone who is not a complete retard.
Include one line of text and have the linker selectively link in the
object code you need or...

Open a dialog, scroll through hundreds of &quot;sniplets&quot; to find the code
you want to cut and paste and repeat this for every function you
reuse.  Too bad for you if there are symbol conflicts.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-03T19:06:00 </POSTDATE>
On Oct 3, 3:36 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 3, 3:03 pm, Betov &lt;be ... @free.fr&gt; wrote:

&gt; &gt; Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait news:g%QMi.4392$PV1.1294
&gt; &gt; @trndny08:

&gt; &gt; &gt; If I assemble these two files and link 'em together as indicated, is
&gt; &gt; &gt; this asm or HLL?

&gt; &gt; You give an example of an Assembly File using an HLL
&gt; &gt; programming *method*.

&gt; All of the instructional material that *I* have been reading give me
&gt; the impression that the issue is not a HLL vs. ASM one but instead is
&gt; a Modern OS vs. Obsolete OS issue.  Programmers are encouraged to use
&gt; dynamic linking on modern operating systems to save on resources.  The
&gt; fact that static linking still enjoys wide-spread use serves to
&gt; demonstrate that this older method still holds value within the
&gt; programming community.

&gt; Nathan.
">

The first time I encountered shared libraries was on the Amiga.
Seemed like a nice idea at the time since space and memory were very
limited.  However, I've suffered grief due to them as well with
Windows.  You end up with hundreds of DLLs, you don't know what each
one does or what installed them.  They stay behind long after you've
uninstalled the programs that put them on your machine... then the OS
informs you that there are no more programs using a certain DLL, it's
safe to delete it... but when you do another program stops working!

Then you also have an invasion of poorly written software that put
everything in DLLs, even if no other programs will ever use them!

My idea of a good modern OS would be one that only the OS supplies
dynamic linked standard and OS/interface libraries, all other programs
must reside in their own folder and they can't write anything outside
without approval from the user (unless it's to a specific &quot;Documents&quot;
folder that the user tags as &quot;shared&quot; ).

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-04T06:10:00 </POSTDATE>
&quot;Wolfgang Kern&quot; &lt;nowh ... @never.at&gt; écrivait news:fe13bg$m5t$1
@newsreader2.utanet.at:

<QUOTE PREVIOUSPOST="
&gt; I see this as either 'merging binaries' (my prefered method), or
&gt; merging text sources (regardless if 'include LIB' or 'copy-paste').

&gt; The latter seem to be the issue for all this discussion about,
&gt; for me it is all the same: insert prepared text into a text source.
&gt; So what was this discusion all about ?
">

It is entirely about not being able to use RosAsm for HLL
Programming, like almost all others &quot;Assemblers for doing
nothing&quot; do.

Having a real Assembly Developement Environment, designed
*exclusively* for writing applications in Assembly, is
something way above their heads.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-04T06:11:00 </POSTDATE>
&quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait
news:1191451952.151769.177640@g4g2000hsf.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt; most programmers use libraries
">

Right. Most programmers would never consider programming
any Application in Assembly.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> hutch-- &lt;hu...@movsd.com&gt; </POSTER>
<POSTDATE> 2007-10-04T07:10:00 </POSTDATE>
smile,

<QUOTE PREVIOUSPOST="
&gt; It is entirely about not being able to use RosAsm for HLL
&gt; Programming, like almost all others &quot;Assemblers for doing
&gt; nothing&quot; do.
">

Yeah yeah we know RotAsm is crippleware.

<QUOTE PREVIOUSPOST="
&gt; Having a real Assembly Developement Environment, designed
&gt; *exclusively* for writing applications in Assembly, is
&gt; something way above their heads.
">

What a shame it works so badly that no-one bothers to use it.
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-04T12:20:00 </POSTDATE>
On Oct 4, 6:11 am, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait news:1191451952.151769.177640@g4g2000hsf.googlegroups.com:

&gt; &gt; most programmers use libraries

&gt; Right. Most programmers would never consider programming
&gt; any Application in Assembly.

&gt; Betov.

&gt; &lt; http://rosasm.org &gt;
">

Most programmers includes most assembly programmers nitwit.  And
before you get an embolism, know that all the assembly programmers are
not defined by who YOU say they are.  We already know your Rotty
victims have fallen into your traps and have the same demented views
that you hold true.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-04T17:05:00 </POSTDATE>
On Oct 3, 12:49 am, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; écrivait news:1191370271.343937.174870@50g2000hsm.googlegroups.com:

&gt; &gt; It is convenient for it to have one.  A
&gt; &gt; very  useful bonus feature missing from Rotty

&gt; Confusing &quot;Code-Re-Use&quot; and &quot;Library&quot; is typical from an HLA victim.
">

Thinking code reuse cannot be done with library code is typical of a
RosAsm victim.
hLater,
Randy Hyde
</POST>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-04T17:20:00 </POSTDATE>
On Oct 3, 12:03 pm, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait news:g%QMi.4392$PV1.1294
&gt; @trndny08:

&gt; &gt; If I assemble these two files and link 'em together as indicated, is
&gt; &gt; this asm or HLL?

&gt; You give an example of an Assembly File using an HLL
&gt; programming *method*. Why do you think i always refused
&gt; to assume static libs, in RosAsm? Because i am unable to
&gt; implement this?
">

Yes.
The design of your assembler makes it quite difficult to implement it.

<QUOTE PREVIOUSPOST="
&gt; I knew, since day one, that refusing to implement that
&gt; shit, would dramaticaly limit the number of RosAsm users,
">

If by &quot;day one&quot; you mean the first day that RosAsm was introduced, I
can believe this. You had already proven with SpAsm that people
weren't accepting this bizarre software engineering paradigm.

If by &quot;day one&quot; you mean when SpAsm was first introduced, well, go
back and re-read your posts from back then. Back then, you were
expecting the whole world to switch to RosAsm and leave all their
other assemblers behind. Indeed, the reason you attack HLA so much is
because it was introduced at roughly the same time and it went on to
gain some popularity, popularity you have always wanted for your own
project.  So quit feeding us this line about how you knew this all
along -- you obviously didn't. For if you had known this, you wouldn't
have bothered trying to push SpAsm/RosAsm on people around here.

<QUOTE PREVIOUSPOST="
&gt; and that implementing it would turn RosAsm into an Assembler
&gt; like all of the other ones. That is: An Assembler for doing
&gt; nothing.
">

Funny, all the work being done in assembly language these days is
being done with those other assemblers; given the tiny RosAsm user
base, it's really RosAsm that's not accomplishing much.

MASM: Has the MASM32 library
NASM: ASMLIB (under Linux) and now Keith's library.
FASM: FASMLIB (Windows and Linux)
HLA: The HLA Standard Library

Look around dude. Libraries are quite popular. You have to complain
about them because your assembler is incapable of properly supporting
them.

<QUOTE PREVIOUSPOST="
&gt; If the problem was really what it should be, that is, which
&gt; Code-Reuse *method* for Assembly, there would not be any
&gt; discussion about doing it with DLLs, Static Libs, or Asm
&gt; Snippets.
">

You seem to be the only one &quot;discussing&quot; this. You're the only one
with a product that can't support this kind of stuff. Just about every
other assembler out there supports linking of library code. You don't
see FASM users having arguments with NASM users about &quot;static linking
not being 'assembly'&quot; or MASM users arguing with TASM users about
this. Or HLA users arguing with NASM users, or....  In fact, the only
one arguing about this is you: and that's just because your product
doesn't support these absolutely essential feature so you have to make
it sound like it's not only unnecessary, but bad.  Good luck. To date,
you've had zero success with your argument. What makes you think that
after seven years of this nonsense, people are going to start
believing you any time soon?

<QUOTE PREVIOUSPOST="
&gt; This is *not* the real problem.
">

That's right. This is not a problem for users of all these other
assemblers. Their tools support all these facilities and they can use
whatever software engineering approach they prefer.

The only people for whom this is a problem are the RosAsm users.

<QUOTE PREVIOUSPOST="
&gt; The real problem
&gt; is that almost everybody *refuse* to even consider writing
&gt; Applications in Assembly,
">

Especially the way *you* define assembly language: specifically,
programming with RosAsm without library support. Yes, I can see why
people would refuse to program in assembly language under those
constraints.

<QUOTE PREVIOUSPOST="
&gt; and want to do that in HLL.
">

Not necessarily. But they do want to be able to use libraries.

<QUOTE PREVIOUSPOST="
&gt; Therefore, an Assembler not enabling .libs becomes useless
&gt; for all those blind people.
">

Ah, yes. Everyone else is blind but you. :-)

<QUOTE PREVIOUSPOST="
&gt; If i had wanted to work for blind
&gt; people, i would have produced white canes. Not an Assembler.
">

Well, as you say &quot;everyone is blind&quot;. So they don't use your product.
And your primary goal (getting people to write applications in
assembly language) is a non-starter.

So tell us, Rene, what's more important -- people writing in assembly
language and using libraries, or people not writing in assembly
language at all?  Because you've pretty much proven that if you don't
provide the ability in your assembler to support static linking,
people aren't going to use it. What's more important to you? Finally
figuring out how to produce and link in .obj files in RosAsm (despite
the hard work it's going to be)?  Or attracting an average of one new
person to assembly language per year?  If your answer is the latter,
why do you waste time around here? It's pretty clear that no one
around here is buying your story.

In the meantime, lots of people are taking advantage of library code
such as the HLA stdlib v2.3. And that just makes you madder and madded
because you can't seem to understand why they are ignoring you and
using that product you dislike so much.

hLater,
Randy Hyde
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-04T17:24:00 </POSTDATE>
&quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; écrivait
news:1191531906.503122.303440@g4g2000hsf.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt; Thinking code reuse cannot be done with library code is typical of a
&gt; RosAsm victim.
">

Right. How could the HLLers understand a thing about the
advantages of more sophisticated methods?

:)

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-04T23:13:00 </POSTDATE>
On Oct 3, 12:36 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; All of the instructional material that *I* have been reading give me
&gt; the impression that the issue is not a HLL vs. ASM one
">

Certainly this has little to do with languages.
You can statically link in code in most languages (assembly or HLL)
and, likewise, you can also link in DLLs (shared objects) in most
languages. Only a few (typically brain-dead) languages only allow
dynamic linking. Visual Basic and RosAsm come to mind. No doubt there
are others, but they are in the minority.

<QUOTE PREVIOUSPOST="
&gt; but instead is
&gt; a Modern OS vs. Obsolete OS issue.
">

This is independent of OS, other than the fact that the OS must
provide run-time linking facilities of some sort.

<QUOTE PREVIOUSPOST="
&gt; Programmers are encouraged to use
&gt; dynamic linking on modern operating systems to save on resources.  The
&gt; fact that static linking still enjoys wide-spread use serves to
&gt; demonstrate that this older method still holds value within the
&gt; programming community.
">

Static and dynamic linking serve two different purposes. Dynamic
linking works great if you have several applications (in particular,
concurrently running applications) that share a common code base. You
need only one copy of the code sitting in memory at one time, being
shared by all the applications that are (concurrently) using it.

One other benefit of dynamic linking is that you have only one copy of
the library sitting on the disk, rather than having separate copies
merged into each executable. However, as we're getting to the point
where terabyte disks cost less than the 143K floppy disk I had on my
Apple II computer, saving a few tens of kilobytes (or even megabytes)
on the disk is hardly an issue.

Dynamic linking, however, provides absolutely no benefit if only one
application  uses the library (indeed, it becomes wasteful at that
point). Let's take the HLA standard library as an example. I could put
the whole thing into a DLL and then *any* assembler (RosAsm included)
could link against it. But look at what happens when such an
application loads -- it loads the *entire* library into memory. Talk
about wasting space! With static linking you only load the actual
functions you use -- with dynamic linking you get *everything* in the
DLL.  This can pay off if several applications in memory are all using
the DLL at the same time (you get to amortize the cost of the DLL over
all the apps), but how many assembly apps does the average person run
at one time?

Now you could argue that you could break up the HLA stdlib into a set
of DLLs. But the bottom line is that the smallest you can make a DLL
is 4K (actually, it takes more space than this because of the indirect
pointers needed to do the linkage). Breaking the library down into
smaller pieces than 4K winds up wasting a lot of space, packing as
many functions into each 4K module winds up wasting space, again,
because it's unlikely you're calling all the functions in that module.

Then, of course, there is the application packaging issue. If you use
a DLL, the user needs to install that DLL in an appropriate location.
And God help the poor person that has one app that uses an older
version of the DLL and a new app that uses a later version of the DLL
(imagine an HLA stdlib v1.x DLL and an HLA stdlib v2.x DLL, for
example). Things start breaking real fast when this happens (this is
known as &quot;DLL Hell&quot;).  Most of the time, it's a lot better to
statically link in all the library code you use so your application is
completely self-contained. For the cost of a few extra bytes on the
disk drive, this elimiates a large number of headaches.

DLLs are great for things like glibc, where dozens of apps can share a
single copy in memory and those apps usually get upgraded at the same
time the library does.  They have not, however, been the panacea they
promised to be when they were popularized. Static linking is still the
most popular way to link library modules (especially user-written
library code, and library code not provided by the OS vendor) because
there are far less headaches associated with it.

And, lastly, don't forget the efficiency concerns. Dynamic linking
requires indirect jumps and calls (and often jumps to indirect jumps).
This is less efficient, and consumes a bit more space, than a direct
call (as you typically get with static linking).
hLater,
Randy Hyde
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-05T01:59:00 </POSTDATE>
On Oct 4, 11:13 pm, &quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 3, 12:36 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt; Static and dynamic linking serve two different purposes. Dynamic
&gt; linking works great if you have several applications (in particular,
&gt; concurrently running applications) that share a common code base. You
&gt; need only one copy of the code sitting in memory at one time, being
&gt; shared by all the applications that are (concurrently) using it.

&gt; One other benefit of dynamic linking is that you have only one copy of
&gt; the library sitting on the disk, rather than having separate copies
&gt; merged into each executable. However, as we're getting to the point
&gt; where terabyte disks cost less than the 143K floppy disk I had on my
&gt; Apple II computer, saving a few tens of kilobytes (or even megabytes)
&gt; on the disk is hardly an issue.

&gt; Dynamic linking, however, provides absolutely no benefit if only one
&gt; application  uses the library (indeed, it becomes wasteful at that
&gt; point).
">

That's nothing.  I've seen installations that make use of several DLLs
that nothing else will use.  At least this particular one stuck the
DLLs in its own folder instead of adding crap to my Windows folder.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-05T03:52:00 </POSTDATE>
&quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; écrivait
news:1191532839.437926.150280@d55g2000hsg.googlegroups.com:

<QUOTE PREVIOUSPOST="
&gt; So tell us, Rene, what's more important -- people writing in assembly
&gt; language and using libraries, or people not writing in assembly
&gt; language at all?
">

Personally, i would prefer having nobody using RosAsm, than
having thousand of users using it for libraries stuff.

For libraries stuff, they have the HLLs. For RosAsm Assembly
Code-Reuse, they have the Clip Files.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> JDavison &lt;j...@swoosh.net&gt; </POSTER>
<POSTDATE> 2007-10-05T03:55:00 </POSTDATE>
Betov scrawled:

<QUOTE PREVIOUSPOST="
&gt; Personally, i would prefer having nobody using RosAsm, than
&gt; having thousand of users using it for libraries stuff.
">

Believe me, you got your wish. ;)

--Joel Davison
</POST>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-05T11:57:00 </POSTDATE>
On Oct 5, 12:52 am, Betov &lt;be ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;rh ... @cs.ucr.edu&quot; &lt;rh ... @cs.ucr.edu&gt; écrivait news:1191532839.437926.150280@d55g2000hsg.googlegroups.com:

&gt; &gt; So tell us, Rene, what's more important -- people writing in assembly
&gt; &gt; language and using libraries, or people not writing in assembly
&gt; &gt; language at all?

&gt; Personally, i would prefer having nobody using RosAsm, than
&gt; having thousand of users using it for libraries stuff.
">

Well, you have your wish.

<QUOTE PREVIOUSPOST="
&gt; For libraries stuff, they have the HLLs. For RosAsm Assembly
&gt; Code-Reuse, they have the Clip Files.
">

So where are all these &quot;clip files&quot; you keep talking about?
You do realize, don't you, that the whole point of libraries is to
avoid writing code in the first place. If you require each and every
user to write their own libraries from scratch, you've lost 90% of the
benefit of code reuse.

So tell us, Rene, where's your RosAsm library (&quot;clip file&quot;)
collection?
hLater,
Randy Hyde
</POST>
<POST>
<POSTER> &quot;rh...@cs.ucr.edu&quot; &lt;rh...@cs.ucr.edu&gt; </POSTER>
<POSTDATE> 2007-10-05T11:57:00 </POSTDATE>
On Oct 5, 12:55 am, JDavison &lt;j ... @swoosh.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Betov scrawled:

&gt; &gt; Personally, i would prefer having nobody using RosAsm, than
&gt; &gt; having thousand of users using it for libraries stuff.

&gt; Believe me, you got your wish. ;)

&gt; --Joel Davison
">

Well, you beat me to that one. :-)
hLater,
Randy Hyde
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-05T21:22:00 </POSTDATE>
On Oct 3, 7:06 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 3, 3:36 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt; &gt; On Oct 3, 3:03 pm, Betov &lt;be ... @free.fr&gt; wrote:

&gt; &gt; &gt; Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait news:g%QMi.4392$PV1.1294
&gt; &gt; &gt; @trndny08:

&gt; &gt; &gt; &gt; If I assemble these two files and link 'em together as indicated, is
&gt; &gt; &gt; &gt; this asm or HLL?

&gt; &gt; &gt; You give an example of an Assembly File using an HLL
&gt; &gt; &gt; programming *method*.

&gt; &gt; All of the instructional material that *I* have been reading give me
&gt; &gt; the impression that the issue is not a HLL vs. ASM one but instead is
&gt; &gt; a Modern OS vs. Obsolete OS issue.  Programmers are encouraged to use
&gt; &gt; dynamic linking on modern operating systems to save on resources.  The
&gt; &gt; fact that static linking still enjoys wide-spread use serves to
&gt; &gt; demonstrate that this older method still holds value within the
&gt; &gt; programming community.

&gt; &gt; Nathan.

&gt; The first time I encountered shared libraries was on the Amiga.
&gt; Seemed like a nice idea at the time since space and memory were very
&gt; limited.  However, I've suffered grief due to them as well with
&gt; Windows.  You end up with hundreds of DLLs, you don't know what each
&gt; one does or what installed them.  They stay behind long after you've
&gt; uninstalled the programs that put them on your machine... then the OS
&gt; informs you that there are no more programs using a certain DLL, it's
&gt; safe to delete it... but when you do another program stops working!
">

If you spend enough time installing applications under Linux, you will
experience the same grief -- and you'll discover that this applies
equally to both static as well as dynamic libraries.  Hypothetically,
if we judge by these issues alone, the &quot;copy-and-paste&quot; method seems
to win.  :)

<QUOTE PREVIOUSPOST="
&gt; Then you also have an invasion of poorly written software that put
&gt; everything in DLLs, even if no other programs will ever use them!

&gt; My idea of a good modern OS would be one that only the OS supplies
&gt; dynamic linked standard and OS/interface libraries, all other programs
&gt; must reside in their own folder and they can't write anything outside
&gt; without approval from the user (unless it's to a specific &quot;Documents&quot;
&gt; folder that the user tags as &quot;shared&quot; ).

&gt; -sevag.k http://sevag.krikorian.googlepages.com
">

I have cc'ed this to 'folklore' for more on the historical and
architectural perspective.

Nathan.
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-05T21:40:00 </POSTDATE>
On Oct 5, 9:22 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; If you spend enough time installing applications under Linux, you will
&gt; experience the same grief -- and you'll discover that this applies
&gt; equally to both static as well as dynamic libraries.  Hypothetically,
&gt; if we judge by these issues alone, the &quot;copy-and-paste&quot; method seems
&gt; to win.  :)
">

How does it apply to static libraries?  They don't take up space as
individual files all over the user's computer.  Once the application
is gone, so are all the libraries statically attached to it.

<QUOTE PREVIOUSPOST="
&gt; &gt; Then you also have an invasion of poorly written software that put
&gt; &gt; everything in DLLs, even if no other programs will ever use them!

&gt; &gt; My idea of a good modern OS would be one that only the OS supplies
&gt; &gt; dynamic linked standard and OS/interface libraries, all other programs
&gt; &gt; must reside in their own folder and they can't write anything outside
&gt; &gt; without approval from the user (unless it's to a specific &quot;Documents&quot;
&gt; &gt; folder that the user tags as &quot;shared&quot; ).

&gt; &gt; -sevag.k http://sevag.krikorian.googlepages.com

&gt; I have cc'ed this to 'folklore' for more on the historical and
&gt; architectural perspective.

&gt; Nathan.
">
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-05T23:21:00 </POSTDATE>
On Oct 5, 9:40 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 5, 9:22 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt; &gt; If you spend enough time installing applications under Linux, you will
&gt; &gt; experience the same grief -- and you'll discover that this applies
&gt; &gt; equally to both static as well as dynamic libraries.  Hypothetically,
&gt; &gt; if we judge by these issues alone, the &quot;copy-and-paste&quot; method seems
&gt; &gt; to win.  :)

&gt; How does it apply to static libraries?  They don't take up space as
&gt; individual files all over the user's computer.
">

A static library that is a 0 byte-sized file?  Generates binary code
from thin air?  Just because you don't see any immediate visual cues
of its existence doesn't mean it isn't there.  Most package-managers
have a feature where it displays a list of the files within the
downloaded package -- including the path they were installed into and
the file sizes.

<QUOTE PREVIOUSPOST="
&gt; Once the application
&gt; is gone, so are all the libraries statically attached to it.
">

I have never had such an experience with a package manager.  Perhaps
the newer ones have this feature (automatically deleting build package-
dependancies as a default), but surely they do not do so without first
alerting the user?  The big question is how?  How does the PM know
that you have finished doing all of the &quot;./configure -- make -- make
install&quot; routines with all of the software you have decided to build?

Nathan.
</POST>
<POST>
<POSTER> //\\\\o//\\\\annabee &lt;w...@w.w.w&gt; </POSTER>
<POSTDATE> 2007-10-06T02:59:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sat, 06 Oct 2007 03:22:57 +0200, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:
&gt; On Oct 3, 7:06 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
&gt; wrote:
&gt;&gt; On Oct 3, 3:36 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt;&gt; &gt; On Oct 3, 3:03 pm, Betov &lt;be ... @free.fr&gt; wrote:

&gt;&gt; &gt; &gt; Frank Kotler &lt;fbkot ... @verizon.net&gt; écrivait
&gt;&gt; news:g%QMi.4392$PV1.1294
&gt;&gt; &gt; &gt; @trndny08:

&gt;&gt; &gt; &gt; &gt; If I assemble these two files and link 'em together as indicated,
&gt;&gt; is
&gt;&gt; &gt; &gt; &gt; this asm or HLL?

&gt;&gt; &gt; &gt; You give an example of an Assembly File using an HLL
&gt;&gt; &gt; &gt; programming *method*.

&gt;&gt; &gt; All of the instructional material that *I* have been reading give me
&gt;&gt; &gt; the impression that the issue is not a HLL vs. ASM one but instead is
&gt;&gt; &gt; a Modern OS vs. Obsolete OS issue.  Programmers are encouraged to use
&gt;&gt; &gt; dynamic linking on modern operating systems to save on resources.  The
&gt;&gt; &gt; fact that static linking still enjoys wide-spread use serves to
&gt;&gt; &gt; demonstrate that this older method still holds value within the
&gt;&gt; &gt; programming community.

&gt;&gt; &gt; Nathan.

&gt;&gt; The first time I encountered shared libraries was on the Amiga.
&gt;&gt; Seemed like a nice idea at the time since space and memory were very
&gt;&gt; limited.  However, I've suffered grief due to them as well with
&gt;&gt; Windows.  You end up with hundreds of DLLs, you don't know what each
&gt;&gt; one does or what installed them.  They stay behind long after you've
&gt;&gt; uninstalled the programs that put them on your machine... then the OS
&gt;&gt; informs you that there are no more programs using a certain DLL, it's
&gt;&gt; safe to delete it... but when you do another program stops working!

&gt; If you spend enough time installing applications under Linux, you will
&gt; experience the same grief -- and you'll discover that this applies
&gt; equally to both static as well as dynamic libraries.  Hypothetically,
&gt; if we judge by these issues alone, the &quot;copy-and-paste&quot; method seems
&gt; to win.  :)
">

Yes, words of wisdom from Evenbit.
If you think about it is is logical. Because both OS uses the exact same
design philosophy.
E.g They are both C creations, and thet both subscribe to the philosophy
that Randall Hyde preaches. The one of &quot;try to pick up a book on software
engineering&quot;.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;&gt; Then you also have an invasion of poorly written software that put
&gt;&gt; everything in DLLs, even if no other programs will ever use them!

&gt;&gt; My idea of a good modern OS would be one that only the OS supplies
&gt;&gt; dynamic linked standard and OS/interface libraries, all other programs
&gt;&gt; must reside in their own folder and they can't write anything outside
&gt;&gt; without approval from the user (unless it's to a specific &quot;Documents&quot;
&gt;&gt; folder that the user tags as &quot;shared&quot; ).

&gt;&gt; -sevag.k http://sevag.krikorian.googlepages.com

&gt; I have cc'ed this to 'folklore' for more on the historical and
&gt; architectural perspective.
&gt; Nathan.
">
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-06T03:06:00 </POSTDATE>
On Oct 5, 11:21 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; How does it apply to static libraries?  They don't take up space as
&gt; &gt; individual files all over the user's computer.

&gt; A static library that is a 0 byte-sized file?  Generates binary code
&gt; from thin air?  Just because you don't see any immediate visual cues
&gt; of its existence doesn't mean it isn't there.
">

That's irrelevant.  If it's statically linked, it's a part of the
executable and its size is contained within the executable size.

<QUOTE PREVIOUSPOST="
&gt;  Most package-managers
&gt; have a feature where it displays a list of the files within the
&gt; downloaded package -- including the path they were installed into and
&gt; the file sizes.
">

You're in Linux world now.  I have no idea what Linux does and if it
works at all it's a miracle.

<QUOTE PREVIOUSPOST="
&gt; &gt; Once the application
&gt; &gt; is gone, so are all the libraries statically attached to it.

&gt; I have never had such an experience with a package manager.  Perhaps
&gt; the newer ones have this feature (automatically deleting build package-
&gt; dependancies as a default), but surely they do not do so without first
&gt; alerting the user?
">

Ah, you speak of the projects in source form?  FYI, I'm not talking
about the sources of programs, just the final programs.

<QUOTE PREVIOUSPOST="
&gt;  The big question is how?  How does the PM know
&gt; that you have finished doing all of the &quot;./configure -- make -- make
&gt; install&quot; routines with all of the software you have decided to build?

&gt; Nathan.
">

For Linux, I tend to stay with the package manager that comes with
Ubuntu.  That seems to be stable enough not to self-destruct the
system.  Anything else, I usually look for binaries.

If compiling the software is not as easy as typing &quot;make&quot; and cleanup
not as easy as deleting the source folder, I pass.  My Linux system is
pretty much devoid of software because of this.

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Steve O&#39;Hara-Smith &lt;ste...@eircom.net&gt; </POSTER>
<POSTDATE> 2007-10-06T03:50:00 </POSTDATE>
On Sat, 06 Oct 2007 07:06:16 -0000

<QUOTE PREVIOUSPOST="
&quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt; wrote:
&gt; If compiling the software is not as easy as typing &quot;make&quot; and cleanup
&gt; not as easy as deleting the source folder, I pass.
">

For this you want the BSDs (or pkgsrc under linux, AIX, Solaris,
Interix ...) - although usually deleting the source folder is automated
under make clean.

In pkgsrc

cd /usr/pkgsrc/CATEGORY/PACKAGE
make install clean clean-depends

or in FreeBSD ports

cd /usr/ports/CATEGORY/PACKAGE
make install clean

--
C:&gt;WIN                                      |   Directable Mirror Arrays
The computer obeys and wins.                | A better way to focus the sun
You lose and Bill collects.                 |    licences available see
| http://www.sohara.org/
</POST>
<POST>
<POSTER> Peter Flass &lt;Peter_Fl...@Yahoo.com&gt; </POSTER>
<POSTDATE> 2007-10-06T14:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Evenbit wrote:
&gt; On Oct 5, 9:40 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
&gt; wrote:

&gt;&gt;On Oct 5, 9:22 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt;&gt;&gt;If you spend enough time installing applications under Linux, you will
&gt;&gt;&gt;experience the same grief -- and you'll discover that this applies
&gt;&gt;&gt;equally to both static as well as dynamic libraries.  Hypothetically,
&gt;&gt;&gt;if we judge by these issues alone, the &quot;copy-and-paste&quot; method seems
&gt;&gt;&gt;to win.  :)

&gt;&gt;How does it apply to static libraries?  They don't take up space as
&gt;&gt;individual files all over the user's computer.

&gt; A static library that is a 0 byte-sized file?  Generates binary code
&gt; from thin air?  Just because you don't see any immediate visual cues
&gt; of its existence doesn't mean it isn't there.  Most package-managers
&gt; have a feature where it displays a list of the files within the
&gt; downloaded package -- including the path they were installed into and
&gt; the file sizes.

&gt;&gt;Once the application
&gt;&gt;is gone, so are all the libraries statically attached to it.

&gt; I have never had such an experience with a package manager.  Perhaps
&gt; the newer ones have this feature (automatically deleting build package-
&gt; dependancies as a default), but surely they do not do so without first
&gt; alerting the user?  The big question is how?  How does the PM know
&gt; that you have finished doing all of the &quot;./configure -- make -- make
&gt; install&quot; routines with all of the software you have decided to build?
">

That's the good part of SMP/E.  You have a list of all &quot;parts&quot; of stuff
on your system, who &quot;owns&quot; it, and who uses it.  You can see at a glance
where something is used.
</POST>
<POST>
<POSTER> Peter Flass &lt;Peter_Fl...@Yahoo.com&gt; </POSTER>
<POSTDATE> 2007-10-06T14:42:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
sevag.krikorian wrote:

&gt;&gt; Most package-managers
&gt;&gt;have a feature where it displays a list of the files within the
&gt;&gt;downloaded package -- including the path they were installed into and
&gt;&gt;the file sizes.

&gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt; works at all it's a miracle.
">

The problem with Linux is not that it doesn't have wonderful package
managers, the problem is that it has so many of them.

Again, a unix problem.  Let 100,000 flowers bloom is a wonderful
philosophy for literature, not so much for an OS.  There should be *one*
way of doing something that everyone follows.
</POST>
<POST>
<POSTER> santosh &lt;santosh....@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-06T14:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Peter Flass wrote:
&gt; sevag.krikorian wrote:

&gt;&gt;&gt; Most package-managers
&gt;&gt;&gt;have a feature where it displays a list of the files within the
&gt;&gt;&gt;downloaded package -- including the path they were installed into and
&gt;&gt;&gt;the file sizes.

&gt;&gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt;&gt; works at all it's a miracle.
">

Yea right. I'm sure the Windows source is a model of clarity and
simplicity and determinacy.

<QUOTE PREVIOUSPOST="
&gt; The problem with Linux is not that it doesn't have wonderful package
&gt; managers, the problem is that it has so many of them.
">

What's the problem in just using your system's default?

<QUOTE PREVIOUSPOST="
&gt; Again, a unix problem.  Let 100,000 flowers bloom is a wonderful
&gt; philosophy for literature, not so much for an OS.  There should be
&gt; *one* way of doing something that everyone follows.
">

What's stopping you from buying a gleaming copy of Microsoft(R)
Windows(R) Vista(R) Ultimate and getting baptised by Bill Gates?
</POST>
<POST>
<POSTER> Frank McCoy &lt;mcc...@millcomm.com&gt; </POSTER>
<POSTDATE> 2007-10-06T14:59:00 </POSTDATE>
In alt.folklore.computers Peter Flass &lt;Peter_Fl ... @Yahoo.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt;sevag.krikorian wrote:

&gt;&gt;&gt; Most package-managers
&gt;&gt;&gt;have a feature where it displays a list of the files within the
&gt;&gt;&gt;downloaded package -- including the path they were installed into and
&gt;&gt;&gt;the file sizes.

&gt;&gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt;&gt; works at all it's a miracle.

&gt;The problem with Linux is not that it doesn't have wonderful package
&gt;managers, the problem is that it has so many of them.

&gt;Again, a unix problem.  Let 100,000 flowers bloom is a wonderful
&gt;philosophy for literature, not so much for an OS.  There should be *one*
&gt;way of doing something that everyone follows.
">

Like Wind-holes?
;-{

--
_____
/  '               / ™
,-/-, __  __.  ____  /_
(_/   / (_(_/|_/ / &lt;_/ &lt;_
</POST>
<POST>
<POSTER> Betov &lt;be...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-06T15:07:00 </POSTDATE>
Peter Flass &lt;Peter_Fl ... @Yahoo.com&gt; écrivait news:4707d750$0$15372
$4c368 ... @roadrunner.com:

<QUOTE PREVIOUSPOST="
&gt; The problem with Linux is not that it doesn't have wonderful package
&gt; managers, the problem is that it has so many of them.

&gt; Again, a unix problem.  Let 100,000 flowers bloom is a wonderful
&gt; philosophy for literature, not so much for an OS.  There should be *one*
&gt; way of doing something that everyone follows.
">

Seconded. It is a pity to see that much efforts wasted for no reason
but stupidities like &quot;My-package-is-better-then-yours&quot;. Maybe, if
Ubuntu succeeds to take the lead seriously, there could be a hope,
but, even there, looking at what a Mandrake (Mandriva) Distro was,
several years ago, and at what Ubuntu is, to date, the difference
is rather not that much impressive.

Maybe the oncoming of the boss of Ubuntu, who introduces himself
as a &quot;dictator&quot; (with the required smile), will do something good
about this so sad situation.

Betov.

&lt; http://rosasm.org &gt;
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-06T17:20:00 </POSTDATE>
On Oct 6, 3:06 am, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 5, 11:21 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt; &gt; &gt; How does it apply to static libraries?  They don't take up space as
&gt; &gt; &gt; individual files all over the user's computer.

&gt; &gt; A static library that is a 0 byte-sized file?  Generates binary code
&gt; &gt; from thin air?  Just because you don't see any immediate visual cues
&gt; &gt; of its existence doesn't mean it isn't there.

&gt; That's irrelevant.  If it's statically linked, it's a part of the
&gt; executable and its size is contained within the executable size.
">

Unless one edits the 'makefile' to do so, building an app from the
source tarball does not automatically delete the downloaded
&quot;development&quot; packages the app depends on.

<QUOTE PREVIOUSPOST="
&gt; &gt;  Most package-managers
&gt; &gt; have a feature where it displays a list of the files within the
&gt; &gt; downloaded package -- including the path they were installed into and
&gt; &gt; the file sizes.

&gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt; works at all it's a miracle.
">

This looks like you are simply adding more smoke to Randy's Code Re-
use &quot;dog-and-pony show&quot; instead of helping to clear the view.  If we
are to be serious about the merits/faults when choosing between Static
versus Dynamic libraries, we must maintain operating system
neutrality.

<QUOTE PREVIOUSPOST="
&gt; &gt; &gt; Once the application
&gt; &gt; &gt; is gone, so are all the libraries statically attached to it.

&gt; &gt; I have never had such an experience with a package manager.  Perhaps
&gt; &gt; the newer ones have this feature (automatically deleting build package-
&gt; &gt; dependancies as a default), but surely they do not do so without first
&gt; &gt; alerting the user?

&gt; Ah, you speak of the projects in source form?  FYI, I'm not talking
&gt; about the sources of programs, just the final programs.
">

We must also not allow any discrimination of who qualifies as a &quot;user&quot;
to cloud our judgement about which code re-use method to employ.

With the phenomenon of Linux now being a mainstream operating system,
binary (mostly just for the x86 platform) distribution of common
applications assist the &quot;usability&quot; aspect for the layperson user.
For the many tech-savy users, like me, who tend to install non- &quot;Joe
Sixpack&quot; -oriented apps, binary packages are not always an option.
You have recently witnessed {here I assume you've been reading those
a.l.a threads} the number of teeth that had to be pulled to satisfy
Jim Carlock's earlier request for a Win32 binary of the beta builds
for the &quot;64-bit featured&quot; version of NASM.  You say that you have
Ubuntu running... have you located a Debian-style binary package [for
any nasm-0.99.xx] available on-line?  Have you tried to get Synaptic
to work with HPA's provided RPM?

Furthermore, these issues are just the &quot;tip of the iceburg&quot; to the
multi-facetted code re-use question.  Have you thought about multi-
threaded applications?  I can easily demonstrate a &quot;deadlock&quot;
situation (easily fixable) that can occur when using a DLL due to
Windows' design that it serializes calls to the DLLmain function.  And
'vid' is already questioning the &quot;thread safe&quot; characteristics of
early versions of Randy's 2.x/3.x HLA Standard Library:

http://board.flatassembler.net/topic.php?t=7682

Nathan.
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-06T18:21:00 </POSTDATE>
On Oct 6, 2:51 pm, santosh &lt;santosh. ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Peter Flass wrote:
&gt; &gt; sevag.krikorian wrote:

&gt; &gt;&gt;&gt; Most package-managers
&gt; &gt;&gt;&gt;have a feature where it displays a list of the files within the
&gt; &gt;&gt;&gt;downloaded package -- including the path they were installed into and
&gt; &gt;&gt;&gt;the file sizes.

&gt; &gt;&gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt; &gt;&gt; works at all it's a miracle.

&gt; Yea right. I'm sure the Windows source is a model of clarity and
&gt; simplicity and determinacy.
">

Well it it was, this discussion wouldn't exist :)
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-06T18:50:00 </POSTDATE>
On Oct 6, 5:20 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 6, 3:06 am, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
&gt; wrote:

&gt; &gt; On Oct 5, 11:21 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

&gt; &gt; &gt; &gt; How does it apply to static libraries?  They don't take up space as
&gt; &gt; &gt; &gt; individual files all over the user's computer.

&gt; &gt; &gt; A static library that is a 0 byte-sized file?  Generates binary code
&gt; &gt; &gt; from thin air?  Just because you don't see any immediate visual cues
&gt; &gt; &gt; of its existence doesn't mean it isn't there.

&gt; &gt; That's irrelevant.  If it's statically linked, it's a part of the
&gt; &gt; executable and its size is contained within the executable size.

&gt; Unless one edits the 'makefile' to do so, building an app from the
&gt; source tarball does not automatically delete the downloaded
&gt; &quot;development&quot; packages the app depends on.
">

If the app depends on them, they're not static linked libraries.  If
Linux installs leave app dependent objects hither and thither (these
items can't be called static linked libraries anymore), that's a
serious defect with Linux or the installation setup/package which is
as problematic as DLLs ending up hither and thither on Windows.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt; &gt; &gt;  Most package-managers
&gt; &gt; &gt; have a feature where it displays a list of the files within the
&gt; &gt; &gt; downloaded package -- including the path they were installed into and
&gt; &gt; &gt; the file sizes.

&gt; &gt; You're in Linux world now.  I have no idea what Linux does and if it
&gt; &gt; works at all it's a miracle.

&gt; This looks like you are simply adding more smoke to Randy's Code Re-
&gt; use &quot;dog-and-pony show&quot; instead of helping to clear the view.  If we
&gt; are to be serious about the merits/faults when choosing between Static
&gt; versus Dynamic libraries, we must maintain operating system
&gt; neutrality.
">

I still fail to see how leaving dependent objects around are
considered static linked libraries.  If package managers leave
dependent objects in the source folder, this is no fault of static-
linked libraries concept.

If I delete a source folder and the program stops working, the rest of
the app will soon follow it into the trash.

<QUOTE PREVIOUSPOST="
&gt; &gt; &gt; &gt; Once the application
&gt; &gt; &gt; &gt; is gone, so are all the libraries statically attached to it.

&gt; &gt; &gt; I have never had such an experience with a package manager.  Perhaps
&gt; &gt; &gt; the newer ones have this feature (automatically deleting build package-
&gt; &gt; &gt; dependancies as a default), but surely they do not do so without first
&gt; &gt; &gt; alerting the user?

&gt; &gt; Ah, you speak of the projects in source form?  FYI, I'm not talking
&gt; &gt; about the sources of programs, just the final programs.

&gt; We must also not allow any discrimination of who qualifies as a &quot;user&quot;
&gt; to cloud our judgement about which code re-use method to employ.
">

Why not?  The end user is the one who will be stuck with the decisions
made by the programmer/package manager.  Their computers are the ones
that will have garbage left around after the program is removed.

<QUOTE PREVIOUSPOST="
&gt; With the phenomenon of Linux now being a mainstream operating system,
&gt; binary (mostly just for the x86 platform) distribution of common
&gt; applications assist the &quot;usability&quot; aspect for the layperson user.
">

A discussion of the sources is beyond the scope of the question
between dynamic and static libraries in the final binary.

<QUOTE PREVIOUSPOST="
&gt; For the many tech-savy users, like me, who tend to install non- &quot;Joe
&gt; Sixpack&quot; -oriented apps, binary packages are not always an option.
">

Tech-savy users will know linux back to front and this kind of problem
won't exist for them.

<QUOTE PREVIOUSPOST="
&gt; You have recently witnessed {here I assume you've been reading those
&gt; a.l.a threads} the number of teeth that had to be pulled to satisfy
&gt; Jim Carlock's earlier request for a Win32 binary of the beta builds
&gt; for the &quot;64-bit featured&quot; version of NASM.  You say that you have
&gt; Ubuntu running... have you located a Debian-style binary package [for
&gt; any nasm-0.99.xx] available on-line?
">

Haven't looked.  Nasm is already in the usr folder and I have no need
for another version of NASM maintained by gods know who.

<QUOTE PREVIOUSPOST="
&gt;  Have you tried to get Synaptic
&gt; to work with HPA's provided RPM?
">

No idea what these are.  I assume RPM is some kind of package.  The
only packages I use in Ubuntu are the ones in the automated updater.
Works just like Windows.  A dialog comes up, asks me to select what to
download and done.  Simple, no headache.

If I have to go into bash, I'll do so only if I really need the app.
Haven't found an app I need that badly yet.

<QUOTE PREVIOUSPOST="
&gt; Furthermore, these issues are just the &quot;tip of the iceburg&quot; to the
&gt; multi-facetted code re-use question.  Have you thought about multi-
&gt; threaded applications?  I can easily demonstrate a &quot;deadlock&quot;
&gt; situation (easily fixable) that can occur when using a DLL due to
&gt; Windows' design that it serializes calls to the DLLmain function.  And
&gt; 'vid' is already questioning the &quot;thread safe&quot; characteristics of
&gt; early versions of Randy's 2.x/3.x HLA Standard Library:

&gt; http://board.flatassembler.net/topic.php?t=7682

&gt; Nathan.
">

Does this have anything to do with DLL vs SL or is it a quality of
code issue?

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Peter Flass &lt;Peter_Fl...@Yahoo.com&gt; </POSTER>
<POSTDATE> 2007-10-06T19:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Frank McCoy wrote:
&gt; In alt.folklore.computers Peter Flass &lt;Peter_Fl ... @Yahoo.com&gt; wrote:

&gt;&gt;sevag.krikorian wrote:

&gt;&gt;&gt;&gt;Most package-managers
&gt;&gt;&gt;&gt;have a feature where it displays a list of the files within the
&gt;&gt;&gt;&gt;downloaded package -- including the path they were installed into and
&gt;&gt;&gt;&gt;the file sizes.

&gt;&gt;&gt;You're in Linux world now.  I have no idea what Linux does and if it
&gt;&gt;&gt;works at all it's a miracle.

&gt;&gt;The problem with Linux is not that it doesn't have wonderful package
&gt;&gt;managers, the problem is that it has so many of them.

&gt;&gt;Again, a unix problem.  Let 100,000 flowers bloom is a wonderful
&gt;&gt;philosophy for literature, not so much for an OS.  There should be *one*
&gt;&gt;way of doing something that everyone follows.

&gt; Like Wind-holes?
&gt; ;-{
">

I was thinking more along the lines of IBM, where there isn't such a
variety of ways of doing something.
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-06T20:39:00 </POSTDATE>
On Oct 6, 6:50 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; Unless one edits the 'makefile' to do so, building an app from the
&gt; &gt; source tarball does not automatically delete the downloaded
&gt; &gt; &quot;development&quot; packages the app depends on.

&gt; If the app depends on them, they're not static linked libraries.  If
">

When you write an HLA app which uses any StdLib functions, you must
reference the header file with &quot;#include( &quot;stdlib.hhf&quot; )&quot; and you must
have either &quot;hlalib.exe&quot; or &quot;hlalib.a&quot; in an appropriate directory
before you can successfully build the said app.  Does this
automagically transform StdLib into a dynamic library???  If
&quot;hlalib.a&quot; is not a static linked library, then what is it?

<QUOTE PREVIOUSPOST="
&gt; Linux installs leave app dependent objects hither and thither (these
&gt; items can't be called static linked libraries anymore), that's a
&gt; serious defect with Linux or the installation setup/package which is
&gt; as problematic as DLLs ending up hither and thither on Windows.
">

This is not a defect at all.  This is simply common courtesy to not
dictate to the user what items he/she should retain on his/her
machine.  If a hypothetically presumptuous &quot;./configure... make...
make install&quot; procedure were to automagically delete any static
library dependencies at the conclusion of the build, the user will be
understandably &quot;pissed off&quot; when he/she proceeds to build yet another
application that depends on those same libraries.

<QUOTE PREVIOUSPOST="
&gt; &gt; We must also not allow any discrimination of who qualifies as a &quot;user&quot;
&gt; &gt; to cloud our judgement about which code re-use method to employ.

&gt; Why not?  The end user is the one who will be stuck with the decisions
&gt; made by the programmer/package manager.  Their computers are the ones
&gt; that will have garbage left around after the program is removed.

&gt; &gt; With the phenomenon of Linux now being a mainstream operating system,
&gt; &gt; binary (mostly just for the x86 platform) distribution of common
&gt; &gt; applications assist the &quot;usability&quot; aspect for the layperson user.

&gt; A discussion of the sources is beyond the scope of the question
&gt; between dynamic and static libraries in the final binary.
">

A 32-bit x86 binary does not satisfy every possible user of open-
source and *nix software.  This is why the &quot;traditional&quot; standard *nix
app distribution model is centered around the source tarball and the
autotools system.  Why must every vendor be required to provide two
dozen different binary builds?

<QUOTE PREVIOUSPOST="
&gt; &gt;  Have you tried to get Synaptic
&gt; &gt; to work with HPA's provided RPM?

&gt; No idea what these are.  I assume RPM is some kind of package.  The
&gt; only packages I use in Ubuntu are the ones in the automated updater.
&gt; Works just like Windows.  A dialog comes up, asks me to select what to
&gt; download and done.  Simple, no headache.
">

I believe this &quot;automated updater&quot; is a scripted front-end to the
Synaptic package manager (or something close to that effect).  If you
&quot;poke around&quot;, you should discover the &quot;libdevel-*&quot; and &quot;*-dev&quot;
packages that users must download to build applications from source.

<QUOTE PREVIOUSPOST="
&gt; &gt; Furthermore, these issues are just the &quot;tip of the iceburg&quot; to the
&gt; &gt; multi-facetted code re-use question.  Have you thought about multi-
&gt; &gt; threaded applications?  I can easily demonstrate a &quot;deadlock&quot;
&gt; &gt; situation (easily fixable) that can occur when using a DLL due to
&gt; &gt; Windows' design that it serializes calls to the DLLmain function.  And
&gt; &gt; 'vid' is already questioning the &quot;thread safe&quot; characteristics of
&gt; &gt; early versions of Randy's 2.x/3.x HLA Standard Library:

&gt; &gt; http://board.flatassembler.net/topic.php?t=7682

&gt; &gt; Nathan.

&gt; Does this have anything to do with DLL vs SL or is it a quality of
&gt; code issue?
">

I will have to say &quot;both&quot; -- because it all boils down to the
&quot;choices&quot; that a developer must make.

Nathan.
</POST>
<POST>
<POSTER> &quot;sevag.krikorian&quot; &lt;sevag.krikor...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-06T21:41:00 </POSTDATE>
On Oct 6, 8:39 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 6, 6:50 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;

&gt; When you write an HLA app which uses any StdLib functions, you must
&gt; reference the header file with &quot;#include( &quot;stdlib.hhf&quot; )&quot; and you must
&gt; have either &quot;hlalib.exe&quot; or &quot;hlalib.a&quot; in an appropriate directory
&gt; before you can successfully build the said app.  Does this
&gt; automagically transform StdLib into a dynamic library???  If
&gt; &quot;hlalib.a&quot; is not a static linked library, then what is it?
">

[snip]

Apples and oranges.  You're talking about source dependencies, I'm
talking about binaries.  We aren't even on the same boat here.  I can
see how this can morph into a source-level discussion when you
consider that many (if not most) Linux applications are distributed in
source form.

However, at the end of the day, once the app is installed and the user
decides what to do with the source, you still end up with an end-user
application that either has all its own functions statically linked or
using a dynamic library installed somewhere on the system.

Linux wins out on this one since (if my memory serves) if you play
around with LD, you can determine how to link in the objects and have
a choice of DLL or SL.  Correct me on this one.  If it is true, than
the user has full control here and the question of DLL vs. SL becomes
a non-issue with OS Linux apps (and even OS Windows apps to an
extent).

-sevag.k
http://sevag.krikorian.googlepages.com
</POST>
<POST>
<POSTER> Evenbit &lt;nbaker2...@charter.net&gt; </POSTER>
<POSTDATE> 2007-10-06T23:02:00 </POSTDATE>
On Oct 6, 9:41 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;
wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 6, 8:39 pm, Evenbit &lt;nbaker2 ... @charter.net&gt; wrote:&gt; On Oct 6, 6:50 pm, &quot;sevag.krikorian&quot; &lt;sevag.krikor ... @gmail.com&gt;

&gt; &gt; When you write an HLA app which uses any StdLib functions, you must
&gt; &gt; reference the header file with &quot;#include( &quot;stdlib.hhf&quot; )&quot; and you must
&gt; &gt; have either &quot;hlalib.exe&quot; or &quot;hlalib.a&quot; in an appropriate directory
&gt; &gt; before you can successfully build the said app.  Does this
&gt; &gt; automagically transform StdLib into a dynamic library???  If
&gt; &gt; &quot;hlalib.a&quot; is not a static linked library, then what is it?

&gt; [snip]

&gt; Apples and oranges.  You're talking about source dependencies, I'm
&gt; talking about binaries.  We aren't even on the same boat here.  I can
&gt; see how this can morph into a source-level discussion when you
&gt; consider that many (if not most) Linux applications are distributed in
&gt; source form.
">

Yes, narrowing your topic to just &quot;apples&quot; allows you to only consider
Windows development issues.  However, the development world is
obviously much bigger than this -- it includes both &quot;apples and
oranges&quot; -- therefore, if you wish to communicate with developers, you
must include all the affected user environments in your discussion.

<QUOTE PREVIOUSPOST="
&gt; Linux wins out on this one since (if my memory serves) if you play
&gt; around with LD, you can determine how to link in the objects and have
&gt; a choice of DLL or SL.  Correct me on this one.  If it is true, than
&gt; the user has full control here and the question of DLL vs. SL becomes
&gt; a non-issue with OS Linux apps (and even OS Windows apps to an
&gt; extent).
">

It is easy to bump into cases where neither the user nor the developer
has control over the matter.  When there is demand for backwards-
compatibility, for instance:   An app may normally take the un-advised
step of building in some of its code from the static libs, but if
certain other libraries are not available at a required version level
or if the Linux kernel version is too old, then the user is told that
he/she must pass a switch to &quot;make&quot; in order to link against the
dynamic libraries.

Nathan.
</POST>
</TEXT>
</BODY>
</DOC>
