<DOC>
<DOCID> eng-NG-31-126394-9137620 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-11-03T21:04:00 </DATETIME>
<BODY>
<HEADLINE>
references and pointers
</HEADLINE>
<TEXT>
<POST>
<POSTER> MQ &lt;michaelquinli...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-03T21:04:00 </POSTDATE>
Can someone tell me where I should use pointers and where I should use
references?  In his book, Stroustrup says that you should use pointers
for passing arguments that are to be modified, not references.  Yet,
in an interview, he laments the overuse of pointers and such in code.
It seems contradictory to me.  Why should we not use references
instead of pointers?  Can someone give me an idea of best practices in
this respect?

regards,
B.
</POST>
<POST>
<POSTER> Juha Nieminen &lt;nos...@thanks.invalid&gt; </POSTER>
<POSTDATE> 2007-11-03T21:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
MQ wrote:
&gt; Can someone tell me where I should use pointers and where I should use
&gt; references?  In his book, Stroustrup says that you should use pointers
&gt; for passing arguments that are to be modified, not references.  Yet,
&gt; in an interview, he laments the overuse of pointers and such in code.
&gt; It seems contradictory to me.  Why should we not use references
&gt; instead of pointers?  Can someone give me an idea of best practices in
&gt; this respect?
">

Think about the basic difference between references and pointers:
Pointers can be made to point to something else than what they were
initialized to point to (including null) while references can't.

This, IMO, gives a good rule of thumb for the decision: If you don't
need to change where the thing is pointing, use references, else use
pointers.
</POST>
<POST>
<POSTER> boroph...@gmail.com </POSTER>
<POSTDATE> 2007-11-03T21:38:00 </POSTDATE>
On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; MQ wrote:
&gt; &gt; Can someone tell me where I should use pointers and where I should use
&gt; &gt; references?  In his book, Stroustrup says that you should use pointers
&gt; &gt; for passing arguments that are to be modified, not references.  Yet,
&gt; &gt; in an interview, he laments the overuse of pointers and such in code.
&gt; &gt; It seems contradictory to me.  Why should we not use references
&gt; &gt; instead of pointers?  Can someone give me an idea of best practices in
&gt; &gt; this respect?

&gt;   Think about the basic difference between references and pointers:
&gt; Pointers can be made to point to something else than what they were
&gt; initialized to point to (including null) while references can't.

&gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt; need to change where the thing is pointing, use references, else use
&gt; pointers.
">

Why then does Stroustrup make the following statement in his book:

&quot;Be suspicious of non-const reference arguments; if you want the
function to modify its arguments, use pointers and value return
instead&quot;

This says to me that we in fact should *not* use references in this
way
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-11-03T22:00:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
boroph ... @gmail.com wrote:
&gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:
&gt;&gt; MQ wrote:
&gt;&gt;&gt; Can someone tell me where I should use pointers and where I should use
&gt;&gt;&gt; references?  In his book, Stroustrup says that you should use pointers
&gt;&gt;&gt; for passing arguments that are to be modified, not references.  Yet,
&gt;&gt;&gt; in an interview, he laments the overuse of pointers and such in code.
&gt;&gt;&gt; It seems contradictory to me.  Why should we not use references
&gt;&gt;&gt; instead of pointers?  Can someone give me an idea of best practices in
&gt;&gt;&gt; this respect?
&gt;&gt;   Think about the basic difference between references and pointers:
&gt;&gt; Pointers can be made to point to something else than what they were
&gt;&gt; initialized to point to (including null) while references can't.

&gt;&gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt;&gt; need to change where the thing is pointing, use references, else use
&gt;&gt; pointers.

&gt; Why then does Stroustrup make the following statement in his book:

&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt; function to modify its arguments, use pointers and value return
&gt; instead&quot;
">

He made a mistake?  Or possibly idiomatic style has changed over time.

--
Ian Collins.
</POST>
<POST>
<POSTER> boroph...@gmail.com </POSTER>
<POSTDATE> 2007-11-03T22:31:00 </POSTDATE>
On Nov 4, 12:00 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; boroph ... @gmail.com wrote:
&gt; &gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:
&gt; &gt;&gt; MQ wrote:
&gt; &gt;&gt;&gt; Can someone tell me where I should use pointers and where I should use
&gt; &gt;&gt;&gt; references?  In his book, Stroustrup says that you should use pointers
&gt; &gt;&gt;&gt; for passing arguments that are to be modified, not references.  Yet,
&gt; &gt;&gt;&gt; in an interview, he laments the overuse of pointers and such in code.
&gt; &gt;&gt;&gt; It seems contradictory to me.  Why should we not use references
&gt; &gt;&gt;&gt; instead of pointers?  Can someone give me an idea of best practices in
&gt; &gt;&gt;&gt; this respect?
&gt; &gt;&gt;   Think about the basic difference between references and pointers:
&gt; &gt;&gt; Pointers can be made to point to something else than what they were
&gt; &gt;&gt; initialized to point to (including null) while references can't.

&gt; &gt;&gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt; &gt;&gt; need to change where the thing is pointing, use references, else use
&gt; &gt;&gt; pointers.

&gt; &gt; Why then does Stroustrup make the following statement in his book:

&gt; &gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt; &gt; function to modify its arguments, use pointers and value return
&gt; &gt; instead&quot;

&gt; He made a mistake?  Or possibly idiomatic style has changed over time.

&gt; --
&gt; Ian Collins.
">

Are you serious?  This is in the most recent version of &quot;The C++
programming language&quot;, and he mentions this point in several
locations.  Hardly an editing mistake.  Let me just state that I am
not debating that the point he makes seems right, it does not seem
right to me, but it seems to be more than just a mistake.
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-11-03T23:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
boroph ... @gmail.com wrote:
&gt; On Nov 4, 12:00 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:
&gt;&gt; boroph ... @gmail.com wrote:
&gt;&gt;&gt; Why then does Stroustrup make the following statement in his book:
&gt;&gt;&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt;&gt;&gt; function to modify its arguments, use pointers and value return
&gt;&gt;&gt; instead&quot;
&gt;&gt; He made a mistake?  Or possibly idiomatic style has changed over time.
">

*Please* don't quote signatures.

<QUOTE PREVIOUSPOST="
&gt; Are you serious?  This is in the most recent version of &quot;The C++
&gt; programming language&quot;, and he mentions this point in several
&gt; locations.  Hardly an editing mistake.  Let me just state that I am
&gt; not debating that the point he makes seems right, it does not seem
&gt; right to me, but it seems to be more than just a mistake.
">

http://www.research.att.com/~bs/bs_faq2.html#pointers-and-references

Puts a different view across, so one of my guesses was probably true.

I'd only recommend using pointers when the argument can meaningfully be
NULL, or when interfacing with legacy code.

--
Ian Collins.
</POST>
<POST>
<POSTER> Tim H &lt;thoc...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-04T01:49:00 </POSTDATE>
On Nov 3, 8:15 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; I'd only recommend using pointers when the argument can meaningfully be
&gt; NULL, or when interfacing with legacy code.
">

Or when you need to store a &quot;reference&quot; (for lack of a better term) to
a shared object in a class that must be STL container-compatible
(assignable).

I admit that I am newish to C++, but the pattern I have found is that
I only use references when passing arguments.  I try hard never to use
&quot;out&quot; variables, but when I do, I use pointers.
</POST>
<POST>
<POSTER> &quot;Jim Langston&quot; &lt;tazmas...@rocketmail.com&gt; </POSTER>
<POSTDATE> 2007-11-04T01:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Ian Collins&quot; &lt;ian-n ... @hotmail.com&gt; wrote in message
">

news:5p4rqvFp7vuvU11@mid.individual.net ...

<QUOTE PREVIOUSPOST="
&gt; boroph ... @gmail.com wrote:
&gt;&gt; On Nov 4, 12:00 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:
&gt;&gt;&gt; boroph ... @gmail.com wrote:

&gt;&gt;&gt;&gt; Why then does Stroustrup make the following statement in his book:
&gt;&gt;&gt;&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt;&gt;&gt;&gt; function to modify its arguments, use pointers and value return
&gt;&gt;&gt;&gt; instead&quot;
&gt;&gt;&gt; He made a mistake?  Or possibly idiomatic style has changed over time.

&gt; *Please* don't quote signatures.

&gt;&gt; Are you serious?  This is in the most recent version of &quot;The C++
&gt;&gt; programming language&quot;, and he mentions this point in several
&gt;&gt; locations.  Hardly an editing mistake.  Let me just state that I am
&gt;&gt; not debating that the point he makes seems right, it does not seem
&gt;&gt; right to me, but it seems to be more than just a mistake.

&gt; http://www.research.att.com/~bs/bs_faq2.html#pointers-and-references

&gt; Puts a different view across, so one of my guesses was probably true.

&gt; I'd only recommend using pointers when the argument can meaningfully be
&gt; NULL, or when interfacing with legacy code.
">

I was actually debating this with myself 2 days ago.  Someone gave me some
code work on, he was using pointers to modify the parameters.  I started to
change them to references, then realized that in mainline, there is no
indication if the parameter was going to be changed or not.

Consider.

void foo( int* Val )
{
*Val = 23;

<QUOTE PREVIOUSPOST="
}
">

void bar( int&amp; Val )
{
Val = 23;

<QUOTE PREVIOUSPOST="
}
">

int main()
{
int MyInt = 10;
foo( &amp;MyInt );
bar( MyInt );

<QUOTE PREVIOUSPOST="
}
">

Becaue Foo forces us to take the address of MyInt, it is fairly obvious in
mainline that MyInt is probably going to be changed, else why pass the
address of a simple int?  bar however gives no indication in mainline that
MyInt will be changed.

Maybe that is the reasoning behind it.

Reguardless, I did go ahead and change them all to references anyway.
</POST>
<POST>
<POSTER> Ian Collins &lt;ian-n...@hotmail.com&gt; </POSTER>
<POSTDATE> 2007-11-04T01:30:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Jim Langston wrote:
&gt; &quot;Ian Collins&quot; &lt;ian-n ... @hotmail.com&gt; wrote:
&gt;&gt; http://www.research.att.com/~bs/bs_faq2.html#pointers-and-references

&gt;&gt; Puts a different view across, so one of my guesses was probably true.

&gt;&gt; I'd only recommend using pointers when the argument can meaningfully be
&gt;&gt; NULL, or when interfacing with legacy code.

&gt; I was actually debating this with myself 2 days ago.  Someone gave me some
&gt; code work on, he was using pointers to modify the parameters.  I started to
&gt; change them to references, then realized that in mainline, there is no
&gt; indication if the parameter was going to be changed or not.

&gt; Consider.

&gt; void foo( int* Val )
&gt; {
&gt;    *Val = 23;
&gt; }

&gt; void bar( int&amp; Val )
&gt; {
&gt;    Val = 23;
&gt; }

&gt; int main()
&gt; {
&gt;    int MyInt = 10;
&gt;    foo( &amp;MyInt );
&gt;    bar( MyInt );
&gt; }

&gt; Becaue Foo forces us to take the address of MyInt, it is fairly obvious in
&gt; mainline that MyInt is probably going to be changed, else why pass the
&gt; address of a simple int?  bar however gives no indication in mainline that
&gt; MyInt will be changed.
">

A good example of why you should give functions meaningful names.

--
Ian Collins.
</POST>
<POST>
<POSTER> Kira Yamato &lt;kira...@earthlink.net&gt; </POSTER>
<POSTDATE> 2007-11-04T02:08:00 </POSTDATE>
On 2007-11-04 01:52:26 -0400, &quot;Jim Langston&quot; &lt;tazmas ... @rocketmail.com&gt; said:

<QUOTE PREVIOUSPOST="
&gt; &quot;Ian Collins&quot; &lt;ian-n ... @hotmail.com&gt; wrote in message
&gt; news:5p4rqvFp7vuvU11@mid.individual.net ...
&gt;&gt; boroph ... @gmail.com wrote:
&gt;&gt;&gt; On Nov 4, 12:00 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:
&gt;&gt;&gt;&gt; boroph ... @gmail.com wrote:

&gt;&gt;&gt;&gt;&gt; Why then does Stroustrup make the following statement in his book:
&gt;&gt;&gt;&gt;&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt;&gt;&gt;&gt;&gt; function to modify its arguments, use pointers and value return
&gt;&gt;&gt;&gt;&gt; instead&quot;
&gt;&gt;&gt;&gt; He made a mistake?  Or possibly idiomatic style has changed over time.

&gt;&gt; *Please* don't quote signatures.

&gt;&gt;&gt; Are you serious?  This is in the most recent version of &quot;The C++
&gt;&gt;&gt; programming language&quot;, and he mentions this point in several
&gt;&gt;&gt; locations.  Hardly an editing mistake.  Let me just state that I am
&gt;&gt;&gt; not debating that the point he makes seems right, it does not seem
&gt;&gt;&gt; right to me, but it seems to be more than just a mistake.

&gt;&gt; http://www.research.att.com/~bs/bs_faq2.html#pointers-and-references

&gt;&gt; Puts a different view across, so one of my guesses was probably true.

&gt;&gt; I'd only recommend using pointers when the argument can meaningfully be
&gt;&gt; NULL, or when interfacing with legacy code.

&gt; I was actually debating this with myself 2 days ago.  Someone gave me some
&gt; code work on, he was using pointers to modify the parameters.  I started to
&gt; change them to references, then realized that in mainline, there is no
&gt; indication if the parameter was going to be changed or not.

&gt; Consider.

&gt; void foo( int* Val )
&gt; {
&gt;    *Val = 23;
&gt; }

&gt; void bar( int&amp; Val )
&gt; {
&gt;    Val = 23;
&gt; }

&gt; int main()
&gt; {
&gt;    int MyInt = 10;
&gt;    foo( &amp;MyInt );
&gt;    bar( MyInt );
&gt; }

&gt; Becaue Foo forces us to take the address of MyInt, it is fairly obvious in
&gt; mainline that MyInt is probably going to be changed, else why pass the
&gt; address of a simple int?  bar however gives no indication in mainline that
&gt; MyInt will be changed.

&gt; Maybe that is the reasoning behind it.

&gt; Reguardless, I did go ahead and change them all to references anyway.
">

I think you made a good call to change them to references anyway.
Otherwise, you would have to worry about people passing invalid pointer
like in foo(0).

So, like Ian Collins had stated in another post, use pointers only if
there is a need to include NULL as a possible value.  But even in that
case, perhaps it is cleaner for the class to implement a singleton
object that represents the &quot;NULL&quot; object of the class anyway.

I'm still a newbie in C++, but I'm getting the sense that proper use of
STL should eliminate all needs of pointers.  However, for efficiency
purposes, perhaps pointers should sometimes be employed, just like
'goto' is theoretically not needed but may be practically needed.

--

-kira
</POST>
<POST>
<POSTER> &quot;Bo Persson&quot; &lt;b...@gmb.dk&gt; </POSTER>
<POSTDATE> 2007-11-04T05:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
boroph ... @gmail.com wrote:
">

:: On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:

<QUOTE PREVIOUSPOST="
::: MQ wrote:
">

:::: Can someone tell me where I should use pointers and where I
:::: should use references?  In his book, Stroustrup says that you
:::: should use pointers for passing arguments that are to be
:::: modified, not references.  Yet, in an interview, he laments the
:::: overuse of pointers and such in code. It seems contradictory to
:::: me.  Why should we not use references instead of pointers?  Can
:::: someone give me an idea of best practices in this respect?
:::
:::   Think about the basic difference between references and
::: pointers: Pointers can be made to point to something else than
::: what they were initialized to point to (including null) while
::: references can't.
:::
:::   This, IMO, gives a good rule of thumb for the decision: If you
::: don't need to change where the thing is pointing, use references,
::: else use pointers.
::
:: Why then does Stroustrup make the following statement in his book:
::
:: &quot;Be suspicious of non-const reference arguments; if you want the
:: function to modify its arguments, use pointers and value return
:: instead&quot;
::
:: This says to me that we in fact should *not* use references in this
:: way

Could you give some context to this statement, like the section number
or something?

It could be that he argues about const against non-const arguments.
Instead of modifyng some part of an argument, like a struct, the
function might be better off just returning the new value.

Bo Persson
</POST>
<POST>
<POSTER> peter koch &lt;peter.koch.lar...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-04T05:54:00 </POSTDATE>
On 4 Nov., 02:38, boroph ... @gmail.com wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:

&gt; &gt; MQ wrote:
&gt; &gt; &gt; Can someone tell me where I should use pointers and where I should use
&gt; &gt; &gt; references?  In his book, Stroustrup says that you should use pointers
&gt; &gt; &gt; for passing arguments that are to be modified, not references.  Yet,
&gt; &gt; &gt; in an interview, he laments the overuse of pointers and such in code.
&gt; &gt; &gt; It seems contradictory to me.  Why should we not use references
&gt; &gt; &gt; instead of pointers?  Can someone give me an idea of best practices in
&gt; &gt; &gt; this respect?

&gt; &gt;   Think about the basic difference between references and pointers:
&gt; &gt; Pointers can be made to point to something else than what they were
&gt; &gt; initialized to point to (including null) while references can't.

&gt; &gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt; &gt; need to change where the thing is pointing, use references, else use
&gt; &gt; pointers.

&gt; Why then does Stroustrup make the following statement in his book:

&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt; function to modify its arguments, use pointers and value return
&gt; instead&quot;

&gt; This says to me that we in fact should *not* use references in this
&gt; way- Skjul tekst i anførselstegn -
">

Where does he write that? I've read that book and certainly would have
remembered that statement, so I believe you must be misunderstanding
him.

/Peter
</POST>
<POST>
<POSTER> Kai-Uwe Bux &lt;jkherci...@gmx.net&gt; </POSTER>
<POSTDATE> 2007-11-04T06:10:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
peter koch wrote:
&gt; On 4 Nov., 02:38, boroph ... @gmail.com wrote:
&gt;&gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:

&gt;&gt; &gt; MQ wrote:
&gt;&gt; &gt; &gt; Can someone tell me where I should use pointers and where I should
&gt;&gt; &gt; &gt; use
&gt;&gt; &gt; &gt; references?  In his book, Stroustrup says that you should use
&gt;&gt; &gt; &gt; pointers
&gt;&gt; &gt; &gt; for passing arguments that are to be modified, not references.  Yet,
&gt;&gt; &gt; &gt; in an interview, he laments the overuse of pointers and such in code.
&gt;&gt; &gt; &gt; It seems contradictory to me.  Why should we not use references
&gt;&gt; &gt; &gt; instead of pointers?  Can someone give me an idea of best practices
&gt;&gt; &gt; &gt; in this respect?

&gt;&gt; &gt;   Think about the basic difference between references and pointers:
&gt;&gt; &gt; Pointers can be made to point to something else than what they were
&gt;&gt; &gt; initialized to point to (including null) while references can't.

&gt;&gt; &gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt;&gt; &gt; need to change where the thing is pointing, use references, else use
&gt;&gt; &gt; pointers.

&gt;&gt; Why then does Stroustrup make the following statement in his book:

&gt;&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt;&gt; function to modify its arguments, use pointers and value return
&gt;&gt; instead&quot;

&gt;&gt; This says to me that we in fact should *not* use references in this
&gt;&gt; way- Skjul tekst i anførselstegn -

&gt; Where does he write that? I've read that book and certainly would have
&gt; remembered that statement, so I believe you must be misunderstanding
&gt; him.
">

See section 7.9, point [1] in the list of advice. There is virtually no
context to the sentence that could change the literal interpretation.

Best

Kai-Uwe Bux
</POST>
<POST>
<POSTER> pauldepst...@att.net </POSTER>
<POSTDATE> 2007-11-04T06:31:00 </POSTDATE>
On Nov 4, 7:10 pm, Kai-Uwe Bux &lt;jkherci ... @gmx.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; peter koch wrote:
&gt; &gt; On 4 Nov., 02:38, boroph ... @gmail.com wrote:
&gt; &gt;&gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:

&gt; &gt;&gt; &gt; MQ wrote:
&gt; &gt;&gt; &gt; &gt; Can someone tell me where I should use pointers and where I should
&gt; &gt;&gt; &gt; &gt; use
&gt; &gt;&gt; &gt; &gt; references?  In his book, Stroustrup says that you should use
&gt; &gt;&gt; &gt; &gt; pointers
&gt; &gt;&gt; &gt; &gt; for passing arguments that are to be modified, not references.  Yet,
&gt; &gt;&gt; &gt; &gt; in an interview, he laments the overuse of pointers and such in code.
&gt; &gt;&gt; &gt; &gt; It seems contradictory to me.  Why should we not use references
&gt; &gt;&gt; &gt; &gt; instead of pointers?  Can someone give me an idea of best practices
&gt; &gt;&gt; &gt; &gt; in this respect?

&gt; &gt;&gt; &gt;   Think about the basic difference between references and pointers:
&gt; &gt;&gt; &gt; Pointers can be made to point to something else than what they were
&gt; &gt;&gt; &gt; initialized to point to (including null) while references can't.

&gt; &gt;&gt; &gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt; &gt;&gt; &gt; need to change where the thing is pointing, use references, else use
&gt; &gt;&gt; &gt; pointers.

&gt; &gt;&gt; Why then does Stroustrup make the following statement in his book:

&gt; &gt;&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt; &gt;&gt; function to modify its arguments, use pointers and value return
&gt; &gt;&gt; instead&quot;

&gt; &gt;&gt; This says to me that we in fact should *not* use references in this
&gt; &gt;&gt; way- Skjul tekst i anførselstegn -

&gt; &gt; Where does he write that? I've read that book and certainly would have
&gt; &gt; remembered that statement, so I believe you must be misunderstanding
&gt; &gt; him.

&gt; See section 7.9, point [1] in the list of advice. There is virtually no
&gt; context to the sentence that could change the literal interpretation.

&gt; Best

&gt; Kai-Uwe Bux- Hide quoted text -

&gt; - Show quoted text -
">

The advice seems a bit odd because most elementary texts have a swap-
two-integers problem, and the intended solution is always to use int&amp;
variables -- pointer-to-int are not mentioned in the standard
solution.

Intended solution is to use void swap(int&amp; x, int&amp; y)

This function creates a local tmp variable whose value = x and then
sets x=y, y = tmp.  The result is that y now contains the value x held
and x contains the value y held.

Paul Epstein
</POST>
<POST>
<POSTER> &quot;Bo Persson&quot; &lt;b...@gmb.dk&gt; </POSTER>
<POSTDATE> 2007-11-04T07:12:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Kai-Uwe Bux wrote:
:: peter koch wrote:
">

::
::: On 4 Nov., 02:38, boroph ... @gmail.com wrote:
:::: On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:
::::
::::
::::
::::
::::

<QUOTE PREVIOUSPOST="
::::: MQ wrote:
">

:::::: Can someone tell me where I should use pointers and where I
:::::: should use
:::::: references?  In his book, Stroustrup says that you should use
:::::: pointers
:::::: for passing arguments that are to be modified, not references.
:::::: Yet, in an interview, he laments the overuse of pointers and
:::::: such in code. It seems contradictory to me.  Why should we not
:::::: use references instead of pointers?  Can someone give me an
:::::: idea of best practices in this respect?
::::
:::::   Think about the basic difference between references and
::::: pointers: Pointers can be made to point to something else than
::::: what they were initialized to point to (including null) while
::::: references can't.
::::
:::::   This, IMO, gives a good rule of thumb for the decision: If
::::: you don't need to change where the thing is pointing, use
::::: references, else use pointers.
::::
:::: Why then does Stroustrup make the following statement in his
:::: book:
::::
:::: &quot;Be suspicious of non-const reference arguments; if you want the
:::: function to modify its arguments, use pointers and value return
:::: instead&quot;
::::
:::: This says to me that we in fact should *not* use references in
:::: this way- Skjul tekst i anførselstegn -
:::
::: Where does he write that? I've read that book and certainly would
::: have remembered that statement, so I believe you must be
::: misunderstanding him.
::
:: See section 7.9, point [1] in the list of advice. There is
:: virtually no context to the sentence that could change the literal
:: interpretation.
::

Interesting!

Point 1 also refers to §5.5 where he writes (p 99 in my 5th printing):

&quot;To keep a program readable, it is often best to avoid functions that
modify their arguments. Instead, you can return a value from the
function explicitly or require a pointer argument.

[some code example]

The increment(x) notation doesn't give a clue to the reader that x's
value is being modified, the way x=next(x) and incr(&amp;x) does.
Consequently 'plain' reference arguments should be used only where the
name of the function gives a strong hint that the reference argument
is modified.&quot;

That's pretty literal!  :-)

So most of us agree that a function should not modifiy its argument,
unless that is clear from the function's name. Generally, a function
name should always tell what the function does. Using a pointer
argument doesn't really solve this problem.

Sometimes even Bjarne gives advice that are not that good.  :-)

Bo Persson
</POST>
<POST>
<POSTER> Erik Wikström &lt;Erik-wikst...@telia.com&gt; </POSTER>
<POSTDATE> 2007-11-04T07:24:00 </POSTDATE>
On 2007-11-04 03:31, boroph ... @gmail.com wrote:

<QUOTE PREVIOUSPOST="
&gt; On Nov 4, 12:00 pm, Ian Collins &lt;ian-n ... @hotmail.com&gt; wrote:
&gt;&gt; boroph ... @gmail.com wrote:
&gt;&gt; &gt; On Nov 4, 11:20 am, Juha Nieminen &lt;nos ... @thanks.invalid&gt; wrote:
&gt;&gt; &gt;&gt; MQ wrote:
&gt;&gt; &gt;&gt;&gt; Can someone tell me where I should use pointers and where I should use
&gt;&gt; &gt;&gt;&gt; references?  In his book, Stroustrup says that you should use pointers
&gt;&gt; &gt;&gt;&gt; for passing arguments that are to be modified, not references.  Yet,
&gt;&gt; &gt;&gt;&gt; in an interview, he laments the overuse of pointers and such in code.
&gt;&gt; &gt;&gt;&gt; It seems contradictory to me.  Why should we not use references
&gt;&gt; &gt;&gt;&gt; instead of pointers?  Can someone give me an idea of best practices in
&gt;&gt; &gt;&gt;&gt; this respect?
&gt;&gt; &gt;&gt;   Think about the basic difference between references and pointers:
&gt;&gt; &gt;&gt; Pointers can be made to point to something else than what they were
&gt;&gt; &gt;&gt; initialized to point to (including null) while references can't.

&gt;&gt; &gt;&gt;   This, IMO, gives a good rule of thumb for the decision: If you don't
&gt;&gt; &gt;&gt; need to change where the thing is pointing, use references, else use
&gt;&gt; &gt;&gt; pointers.

&gt;&gt; &gt; Why then does Stroustrup make the following statement in his book:

&gt;&gt; &gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt;&gt; &gt; function to modify its arguments, use pointers and value return
&gt;&gt; &gt; instead&quot;

&gt;&gt; He made a mistake?  Or possibly idiomatic style has changed over time.

&gt;&gt; --
&gt;&gt; Ian Collins.

&gt; Are you serious?  This is in the most recent version of &quot;The C++
&gt; programming language&quot;, and he mentions this point in several
&gt; locations.  Hardly an editing mistake.
">

The latest edition is still almost 10 years old and written when the
standard was new. I would expect that the idioms have developed a bit
since then.

While I can agree that having to take the address of the arguments makes
it more explicit. But on the other hand you should never call a function
unless you know what effects it is going to have. And since you cannot
indicate the side effects of a function in the signature you must thus
look in the documentation anyway.

My policy regarding the use of pointers and references is to use
references when I can and pointers when I must.

--
Erik Wikström
</POST>
<POST>
<POSTER> Tristan Wibberley &lt;maihem-...@maihem.org&gt; </POSTER>
<POSTDATE> 2007-11-04T09:20:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Sun, 2007-11-04 at 12:24 +0000, Erik Wikström wrote:
&gt; The latest edition is still almost 10 years old and written when the
&gt; standard was new. I would expect that the idioms have developed a bit
&gt; since then.
">

Barne Stroustrup mustn't have had any input into the codecvt facet
then :)

--
Tristan Wibberley

Any opinion expressed is mine (or else I'm playing devils advocate for
the sake of a good argument). My employer had nothing to do with this
communication.
</POST>
<POST>
<POSTER> Juha Nieminen &lt;nos...@thanks.invalid&gt; </POSTER>
<POSTDATE> 2007-11-04T22:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
boroph ... @gmail.com wrote:
&gt; Why then does Stroustrup make the following statement in his book:

&gt; &quot;Be suspicious of non-const reference arguments; if you want the
&gt; function to modify its arguments, use pointers and value return
&gt; instead&quot;

&gt; This says to me that we in fact should *not* use references in this
&gt; way
">

Even though he is the creator of the language, that still sounds like
a question of opinion, a question of style.

IMO functions taking references should *always* take const references
for parameters they do not modify, and only take non-const references
for parameters they might modify. Thus, as a rule of thumb, if you are
calling a function which takes a non-const reference you must assume
that it may change it.

Of course there may be badly-designed third-party C++ libraries which
take non-const references even though they never modify them, but OTOH
even if they took pointers that wouldn't change anything: You still
couldn't be certain whether the function modifies it or not. You must
assume that it may.
</POST>
<POST>
<POSTER> Paavo Helde &lt;nob...@ebi.ee&gt; </POSTER>
<POSTDATE> 2007-11-08T12:24:00 </POSTDATE>
Kira Yamato &lt;kira ... @earthlink.net&gt; wrote in
news:2007110402083216807-kirakun@earthlinknet:
[...]

<QUOTE PREVIOUSPOST="
&gt; I'm still a newbie in C++, but I'm getting the sense that proper use
&gt; of STL should eliminate all needs of pointers.  However, for
&gt; efficiency purposes, perhaps pointers should sometimes be employed,
&gt; just like 'goto' is theoretically not needed but may be practically
&gt; needed.
">

References are usually implemented by pointers anyway, so there is no
efficiency gain (except that you don't (shouldn't) need to check for
NULL-ness, but that's more a design issue and costs next to nothing
anyway on current hardware).

Pointers are not good for out parameters IMHO, because pointers can be
NULL. If I call some function for retrieving some data and passing NULL
pointer, what I'm saying? Do I want to get this data after all or not? If
not, why I call this function? I should call another function or overload
instead if I don't want to get any data back. In case of references I am
obliged to provide the space for data and the meaning of the operation is
much clearer.

You are right that raw pointers should generally not be used in C++ code.
If pointer semantics are required, for example for storing in STL
containers, some kind of smartpointers should be used instead.

Paavo
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T03:42:00 </POSTDATE>
On Nov 4, 8:08 am, Kira Yamato &lt;kira ... @earthlink.net&gt; wrote:

[...]

<QUOTE PREVIOUSPOST="
&gt; I'm still a newbie in C++, but I'm getting the sense that
&gt; proper use of STL should eliminate all needs of pointers.
">

Where did you get this idea from?  Iterators can only be used
for objects in a sequence---in practice, in a container.  Most
objects aren't in a container; entity objects never are, since
they aren't copiable, and it's rare to need a pointer for
anything but an entity object.

<QUOTE PREVIOUSPOST="
&gt; However, for efficiency purposes, perhaps pointers should
&gt; sometimes be employed, just like 'goto' is theoretically not
&gt; needed but may be practically needed.
">

'goto' is never needed, even practically.  Pointers are almost
always needed, even theoretically.  (I say almost, because I
believe that there are applications which don't have any
&quot;entity&quot; objects.  I can imagine some serious numeric
applications, for example, which use neither pointers nor
iterators, ever.)

Iterators are for iterating.  For the most part, you don't want
to maintain iterators (nor pointers to objects in a container)
for any significant duration; adding or removing elements from
the container can invalidate the iterators.  STL containers are
designed with value semantics (the only semantics which really
make sense for a container in the context of C++).  This means
that objects in the container do not have identity; they may
&quot;move around&quot;.  It also means that, conceptually, you won't
normally keep pointers, references or iterators designating them
beyond the scope of a simple algorithm or iteration.  If you
find yourself doing so, then you're using the wrong tool, or
misusing it.

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> Kira Yamato &lt;kira...@earthlink.net&gt; </POSTER>
<POSTDATE> 2007-11-09T04:04:00 </POSTDATE>
On 2007-11-09 03:42:42 -0500, James Kanze &lt;james.ka ... @gmail.com&gt; said:

<QUOTE PREVIOUSPOST="
&gt; On Nov 4, 8:08 am, Kira Yamato &lt;kira ... @earthlink.net&gt; wrote:

&gt;     [...]
&gt;&gt; I'm still a newbie in C++, but I'm getting the sense that
&gt;&gt; proper use of STL should eliminate all needs of pointers.

&gt; Where did you get this idea from?  Iterators can only be used
&gt; for objects in a sequence---in practice, in a container.  Most
&gt; objects aren't in a container; entity objects never are, since
&gt; they aren't copiable, and it's rare to need a pointer for
&gt; anything but an entity object.
">

What is this &quot;entity object&quot; you speak of?  Why can't you use
references to &quot;point&quot; to them instead?

<QUOTE PREVIOUSPOST="
&gt;&gt; However, for efficiency purposes, perhaps pointers should
&gt;&gt; sometimes be employed, just like 'goto' is theoretically not
&gt;&gt; needed but may be practically needed.

&gt; 'goto' is never needed, even practically.
">

I'm been told (from friends in the computer department) that &quot;the use
of goto in Linux kernel code is well thought out and justified.&quot;  Linus
himself cited that use of it can make the code easier to read than with
nested if statements.

<QUOTE PREVIOUSPOST="
&gt; Pointers are almost
&gt; always needed, even theoretically.
">

Well, I'm not saying the concept of pointer is unneeded.  Certainly,
references is a type of &quot;pointer&quot; to refer to an object.  I was
referring to the idea that the STL and C++ reference type &amp; together
should provide sufficient need in place of C++ pointer type *.

<QUOTE PREVIOUSPOST="
&gt; (I say almost, because I
&gt; believe that there are applications which don't have any
&gt; &quot;entity&quot; objects.
">

What is this entity object again?

<QUOTE PREVIOUSPOST="
&gt; I can imagine some serious numeric
&gt; applications, for example, which use neither pointers nor
&gt; iterators, ever.)

&gt; Iterators are for iterating.  For the most part, you don't want
&gt; to maintain iterators (nor pointers to objects in a container)
&gt; for any significant duration; adding or removing elements from
&gt; the container can invalidate the iterators.  STL containers are
&gt; designed with value semantics (the only semantics which really
&gt; make sense for a container in the context of C++).  This means
&gt; that objects in the container do not have identity; they may
&gt; &quot;move around&quot;.
">

Ah...  Good to know this.  Thanks for telling me this or else I might
have introduce hard-to-find bugs.

<QUOTE PREVIOUSPOST="
&gt; It also means that, conceptually, you won't
&gt; normally keep pointers, references or iterators designating them
&gt; beyond the scope of a simple algorithm or iteration.  If you
&gt; find yourself doing so, then you're using the wrong tool, or
&gt; misusing it.
">

--

-kira
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-09T04:07:00 </POSTDATE>
On Nov 8, 6:24 pm, Paavo Helde &lt;nob ... @ebi.ee&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Kira Yamato &lt;kira ... @earthlink.net&gt; wrote in news:2007110402083216807-kirakun@earthlinknet:
&gt; [...]
&gt; References are usually implemented by pointers anyway, so there is no
&gt; efficiency gain (except that you don't (shouldn't) need to check for
&gt; NULL-ness, but that's more a design issue and costs next to nothing
&gt; anyway on current hardware).
">

It depends.  A reference cannot be reseated.  The compiler knows
this.  That may open up some additional optimization
possibilities, or make them simpler.

<QUOTE PREVIOUSPOST="
&gt; Pointers are not good for out parameters IMHO, because
&gt; pointers can be NULL.
">

C++ doesn't allow out parameters, at least not for class types,
so the question is moot:-).

For inout parameters (or parameters which are conceptually out,
even if you can't call the function without actually having
given them a value), it's a question of convention---I prefer
references, too, but I'll adapt to the local convention.

Pointers are required, on the other hand, if the out parameter
is optional---things like the second parameter to functions in
the strtoxxx family (strtod, etc.).

<QUOTE PREVIOUSPOST="
&gt; If I call some function for retrieving some data and passing NULL
&gt; pointer, what I'm saying?
">

That you're not interested in the data, only in the side effects
of looking for it.

Out parameters are not all that frequent.  Except in some very
rare cases of optimization, they only occur when a function has
more than one value to return.  In that case, it's a fairly
common idiom to pass the address of the second return value as a
pointer, with the convention that a null pointer means that
you're only interested in the primary return value.  There are a
number of examples of this in the C standard, for example.

<QUOTE PREVIOUSPOST="
&gt; Do I want to get this data after all or not? If
&gt; not, why I call this function?
">

Because if it has an out parameter, it also has a return value,
and you're only interested in the return value.

<QUOTE PREVIOUSPOST="
&gt; I should call another function or overload instead if I don't
&gt; want to get any data back.
">

That's another alternative---provide two functions.  But what is
the real difference between:
Type1 function( Type2* out = NULL ) ;
and
Type1 function() ;
Type1 function( Type2&amp; out ) ;
(The only real difference I can see is that some older compilers
might still accept a temporary as argument in the second case.
Which is an argument for using the first alternative---and for
using pointers in general for out parameters.  But you should
probably update such compilers, rather than adapting your coding
standards to them.)

<QUOTE PREVIOUSPOST="
&gt; In case of references I am obliged to provide the space for
&gt; data and the meaning of the operation is much clearer.
&gt; You are right that raw pointers should generally not be used
&gt; in C++ code.  If pointer semantics are required, for example
&gt; for storing in STL containers, some kind of smart pointers
&gt; should be used instead.
">

This is simply false.  There are times when smart pointers are
appropriate, but most use of pointers is for navigation, and raw
pointers are still the best solution for that.

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-11-10T07:08:00 </POSTDATE>
On Nov 9, 10:04 am, Kira Yamato &lt;kira ... @earthlink.net&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On 2007-11-09 03:42:42 -0500, James Kanze &lt;james.ka ... @gmail.com&gt; said:
&gt; &gt; On Nov 4, 8:08 am, Kira Yamato &lt;kira ... @earthlink.net&gt; wrote:
&gt; &gt;     [...]
&gt; &gt;&gt; I'm still a newbie in C++, but I'm getting the sense that
&gt; &gt;&gt; proper use of STL should eliminate all needs of pointers.
&gt; &gt; Where did you get this idea from?  Iterators can only be used
&gt; &gt; for objects in a sequence---in practice, in a container.  Most
&gt; &gt; objects aren't in a container; entity objects never are, since
&gt; &gt; they aren't copiable, and it's rare to need a pointer for
&gt; &gt; anything but an entity object.
&gt; What is this &quot;entity object&quot; you speak of?
">

They're the category of objects which represent entities in your
application.  More precisely, they will normally have identity,
and sometimes be polymorphic.

<QUOTE PREVIOUSPOST="
&gt; Why can't you use references to &quot;point&quot; to them instead?
">

You can't reseat references.  You can't put references into
containers.  If you require pointer semantics, references won't
do it.

<QUOTE PREVIOUSPOST="
&gt; &gt;&gt; However, for efficiency purposes, perhaps pointers should
&gt; &gt;&gt; sometimes be employed, just like 'goto' is theoretically not
&gt; &gt;&gt; needed but may be practically needed.
&gt; &gt; 'goto' is never needed, even practically.
&gt; I'm been told (from friends in the computer department) that
&gt; &quot;the use of goto in Linux kernel code is well thought out and
&gt; justified.&quot; Linus himself cited that use of it can make the
&gt; code easier to read than with nested if statements.
">

I wouldn't take Linux as an example of good, well written
software.

<QUOTE PREVIOUSPOST="
&gt; &gt; Pointers are almost always needed, even theoretically.
&gt; Well, I'm not saying the concept of pointer is unneeded.
&gt; Certainly, references is a type of &quot;pointer&quot; to refer to an
&gt; object.  I was referring to the idea that the STL and C++
&gt; reference type &amp; together should provide sufficient need in
&gt; place of C++ pointer type *.
">

But they don't.  They don't even come close.  Both STL iterators
and C++ references handle special cases.  Neither are designed
for more general use.

<QUOTE PREVIOUSPOST="
&gt; &gt; (I say almost, because I believe that there are applications
&gt; &gt; which don't have any &quot;entity&quot; objects.
&gt; What is this entity object again?
">

See above.  Or just Google it.  (But be aware that many of the
hits you'll get with Google refer to entity objects in a
specific context.  Thus, for example, one says &quot;Entity objects
are classes that encapsulate the business model, including
rules, data, relationships, and persistence behavior, for items
that are used in your business application.&quot;  Which is fine as
far as it goes, but I've used entity objects in technical, real
time applications, and I've used entity objects which weren't
persistent.

The key factor, I think, is identity: even if two entity objects
have the same value, they are different objects.  In this case,
another important point is that entity objects typically have
relationships between them: one entity object object knows about
other entity objects.  In many cases, authors will consider only
entity objects as objects, and not consider things like double
an object.  (I prefer to think of everything as an object, even
if not in an OO way.)

While there are a number of ways you can categorize objects, and
a number of different categories, I think it safe to say that
most objects are either entity objects or value object (values);
the other categories are a lot less frequent.  The difference is
that what is important with a value object is the value---which
instance you use doesn't matter.  So you copy and assign them,
put them into containers, etc., and rarely if ever allocate them
dynamically or take their address.  What is important with
entity objects is their identity: they are not generally copied
(only for purposes of rollback in transactions, and such), never
assigned, you can't put them into containers (but you can put
pointers to them), etc.  They often manage themselves; in a
certain sense, they have built-in intelligence.

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> Kai-Uwe Bux &lt;jkherci...@gmx.net&gt; </POSTER>
<POSTDATE> 2007-11-09T04:49:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
James Kanze wrote:
&gt; On Nov 8, 6:24 pm, Paavo Helde &lt;nob ... @ebi.ee&gt; wrote:
&gt;&gt; You are right that raw pointers should generally not be used
&gt;&gt; in C++ code.  If pointer semantics are required, for example
&gt;&gt; for storing in STL containers, some kind of smart pointers
&gt;&gt; should be used instead.

&gt; This is simply false.  There are times when smart pointers are
&gt; appropriate, but most use of pointers is for navigation, and raw
&gt; pointers are still the best solution for that.
">

Whether most use of pointers is for navigation depends heavily on the
application domain. You are presumably correct for event-driven programs.
However, there is a whole lot of other stuff out there where pointers are
used for other purposes (e.g., COW-optimization for large objects,
implementation of container-like data structures, working with incomplete
types to meet conceptual requirements, interfacing legacy code, ...).
Without a qualification of the type of program you are talking about,
statements about the fraction of pointers that are used for navigation
compared to what is used for other purposes seem to be a matter of pure
speculation. On the other hand, if you have some significant data on this,
I would be interested.

Best

Kai-Uwe Bux
</POST>
</TEXT>
</BODY>
</DOC>
