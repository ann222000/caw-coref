<DOC>
<DOCID> eng-NG-31-126394-9138074 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-10-11T04:15:00 </DATETIME>
<BODY>
<HEADLINE>
C++ Online Reference
</HEADLINE>
<TEXT>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-11T04:15:00 </POSTDATE>
Hi all,

you folks have seen how wrongly I understood std::remove() algorithm. I
got that understanding from here:

http://www.cppreference.com/cppalgorithm/remove.html

which simply says, &quot;The remove() algorithm removes all of the elements
....&quot;

fortunately comp.lang.c++ told me that is not true and Stroustrup on my
Desk also confirmed that. Sadly, Nicolai's book is not availale in my
country, So i looked for some correct online reference and I found this
one is frequently recommended:

http://www.dinkumware.com/cpp.aspx

but somone here also recommended the http://www.cppreference.com/ which
has quite wrong information. So I want to know, How is Dinkumware
Documentation ?

-- arnuld
http://lispmachine.wordpress.com
</POST>
<POST>
<POSTER> anon &lt;a...@no.no&gt; </POSTER>
<POSTDATE> 2007-10-11T04:35:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
arnuld wrote:
&gt; Hi all,

&gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; got that understanding from here:

&gt; http://www.cppreference.com/cppalgorithm/remove.html

&gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; ....&quot;

&gt; fortunately comp.lang.c++ told me that is not true and Stroustrup on my
&gt; Desk also confirmed that. Sadly, Nicolai's book is not availale in my
&gt; country, So i looked for some correct online reference and I found this
&gt; one is frequently recommended:
">

Whats wrong there?
http://www.cplusplus.com/reference/algorithm/remove.html gives the same
explanation.
</POST>
<POST>
<POSTER> Zeppe &lt;ze...@remove.all.this.long.comment.yahoo.it&gt; </POSTER>
<POSTDATE> 2007-10-11T04:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
arnuld wrote:
&gt; Hi all,

&gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; got that understanding from here:

&gt; http://www.cppreference.com/cppalgorithm/remove.html

&gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; ....&quot;

&gt; fortunately comp.lang.c++ told me that is not true and Stroustrup on my
&gt; Desk also confirmed that.
">

The standard &quot;simply&quot; sais the same:

&quot;Eliminates all the elements referred to by iterator i in the range
[first, last) for which the following [...] conditions hold: *i == value
[...].&quot;

So, I wouldn't blame that resource that much.

Regards,

Zeppe
</POST>
<POST>
<POSTER> Erik Wikström &lt;Erik-wikst...@telia.com&gt; </POSTER>
<POSTDATE> 2007-10-11T05:22:00 </POSTDATE>
On 2007-10-11 10:15, arnuld wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi all,

&gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; got that understanding from here:

&gt; http://www.cppreference.com/cppalgorithm/remove.html

&gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; ....&quot;
">

It is not exactly wrong, but you need to read the next sentence too:
&quot;The return value of this function is an iterator to the last element of
the new sequence that should contain no elements equal to val.&quot;

<QUOTE PREVIOUSPOST="
&gt; fortunately comp.lang.c++ told me that is not true and Stroustrup on my
&gt; Desk also confirmed that. Sadly, Nicolai's book is not availale in my
&gt; country, So i looked for some correct online reference and I found this
&gt; one is frequently recommended:

&gt; http://www.dinkumware.com/cpp.aspx
">

I would assume that all information on dinkumware's site is quite
accurate, it is after all the reference documentation to their library
implementation (keep an eye out for anything that might be
implementation specific though). The question is whether you understand
their descriptions better than the ones at www.cppreference.com . Another
quite useful site is www.cplusplus.com , they often have more details and
examples.

--
Erik Wikström
</POST>
<POST>
<POSTER> Michael DOUBEZ &lt;michael.dou...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-11T05:57:00 </POSTDATE>
arnuld a écrit :

<QUOTE PREVIOUSPOST="
&gt; Hi all,

&gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; got that understanding from here:

&gt; http://www.cppreference.com/cppalgorithm/remove.html

&gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; ....&quot;

&gt; fortunately comp.lang.c++ told me that is not true
">

I truth only one personn told you that.

<QUOTE PREVIOUSPOST="
&gt; and Stroustrup on my
&gt; Desk also confirmed that.
">

I don't have it here but I will check. I would be a surprise: saying
that std::remove doesn't remove would mean it is a misnommer. Perhaps
the distinction is a bit subtle and another world should have been used
but it doesn't mean it is false.

<QUOTE PREVIOUSPOST="
&gt; Sadly, Nicolai's book is not availale in my
&gt; country, So i looked for some correct online reference and I found this
&gt; one is frequently recommended:

&gt; http://www.dinkumware.com/cpp.aspx

&gt; but somone here also recommended the http://www.cppreference.com/ which
&gt; has quite wrong information. So I want to know, How is Dinkumware
&gt; Documentation ?
">

It is your understanding of 'remove' that is at fault. See defintion of
remove at SGI STL.
http://www.sgi.com/tech/stl/remove.html

Michael
</POST>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-11T06:37:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; On Thu, 11 Oct 2007 11:57:17 +0200, Michael DOUBEZ wrote:
&gt; I don't have it here but I will check. I would be a surprise: saying
&gt; that std::remove doesn't remove would mean it is a misnommer. Perhaps
&gt; the distinction is a bit subtle and another world should have been used
&gt; but it doesn't mean it is false.
&gt; It is your understanding of 'remove' that is at fault. See defintion of
&gt; remove at SGI STL.
&gt; http://www.sgi.com/tech/stl/remove.html
">

yes, that is much better explanation :-)  I checked the NOTES:

NOTES &gt;&gt;&gt;  The meaning of &quot;removal&quot; is somewhat subtle. Remove does
NOTES &gt;&gt;&gt;  not destroy any iterators, and does not change the distance
NOTES &gt;&gt;&gt;  between first and last. (There's no way that it could do
NOTES &gt;&gt;&gt;  anything of thesort.) So, for example, if V is a vector,
NOTES &gt;&gt;&gt;  remove(V.begin(), V.end(), 0)does not change V.size(): V will
NOTES &gt;&gt;&gt;  contain just as many elements as it did before. Remove returns
NOTES &gt;&gt;&gt;  an iterator that points to the end of the resulting range after
NOTES &gt;&gt;&gt;  elements have been removed from it; it follows that the
NOTES &gt;&gt;&gt;  elements after that iterator are of no interest, and may be
NOTES &gt;&gt;&gt;  discarded.

e.g.

copy(V.begin(), V.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));
// The output is &quot;3 1 4 1 5 9&quot;.

vector&lt;int&gt;::iterator new_end = remove(V.begin(), V.end(), 1);

copy(V.begin(), new_end, ostream_iterator&lt;int&gt;(cout, &quot; &quot;));
// The output is &quot;3 4 5 9&quot;.

Therefore I understand that V.size() is still same but we have this range
of V.begin() &amp; V.end() has got new iterator at say V.end_last() that says:

In iterator range ( V.begin(), V.end_last() )  contains elements of V
where integer 1 is not present (removed)

integer 1 is present In iterator range ( V.end_last(), V.end() )

Am I right ?

I think NO, I am wrong because this example says something else:

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{

std::vector&lt;int&gt; V;
V.push_back(3);
V.push_back(1);
V.push_back(4);
V.push_back(1);
V.push_back(5);
V.push_back(9);

std::copy(V.begin(), V.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
// The output is &quot;3 1 4 1 5 9&quot;.

std::vector&lt;int&gt;::iterator new_end = remove(V.begin(), V.end(), 1);

std::cout &lt;&lt; &quot;\n--------------- NEW RANGE -----------\n&quot;;
std::copy(V.begin(), new_end, std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
// The output is &quot;3 4 5 9&quot;.

std::cout &lt;&lt; &quot;\n-------------- REMOVED RANGE -------------\n&quot;;
std::copy( new_end, V.end(), std::ostream_iterator&lt;int&gt;( std::cout, &quot; &quot; ) );
std::cout &lt;&lt; std::endl;

return 0;

<QUOTE PREVIOUSPOST="
}
">

============ OUTPUT ===================
~/programming/c++ $ g++ -ansi -pedantic -Wall -Wextra test.cpp
~/programming/c++ $ .a/
.a/: command not found
~/programming/c++ $ ./a.out
3 1 4 1 5 9
--------------- NEW RANGE -----------
3 4 5 9
-------------- REMOVED RANGE -------------
5 9
~/programming/c++ $

so did it really erase the iterator-range ( new_end, V.end() ) ?

NOTES &gt;&gt;&gt;  If you are removing elements from a Sequence, you may simply
NOTES &gt;&gt;&gt;  erase them. That is, a reasonable way of removingelements from
NOTES &gt;&gt;&gt;  a Sequence is S.erase(remove(S.begin(), S.end(), x), S.end())

I guess that is better and little Googling tells me that it is Scott
Meyer's technique # 32 :-)

-- arnuld
http://lispmachine.wordpress.com
</POST>
<POST>
<POSTER> anon &lt;a...@no.no&gt; </POSTER>
<POSTDATE> 2007-10-11T06:58:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
arnuld wrote:
&gt;&gt; On Thu, 11 Oct 2007 11:57:17 +0200, Michael DOUBEZ wrote:

&gt;&gt; I don't have it here but I will check. I would be a surprise: saying
&gt;&gt; that std::remove doesn't remove would mean it is a misnommer. Perhaps
&gt;&gt; the distinction is a bit subtle and another world should have been used
&gt;&gt; but it doesn't mean it is false.
&gt;&gt; It is your understanding of 'remove' that is at fault. See defintion of
&gt;&gt; remove at SGI STL.
&gt;&gt; http://www.sgi.com/tech/stl/remove.html

&gt; yes, that is much better explanation :-)  I checked the NOTES:

&gt; NOTES &gt;&gt;&gt;  The meaning of &quot;removal&quot; is somewhat subtle. Remove does
&gt; NOTES &gt;&gt;&gt;  not destroy any iterators, and does not change the distance
&gt; NOTES &gt;&gt;&gt;  between first and last. (There's no way that it could do
&gt; NOTES &gt;&gt;&gt;  anything of thesort.) So, for example, if V is a vector,
&gt; NOTES &gt;&gt;&gt;  remove(V.begin(), V.end(), 0)does not change V.size(): V will
&gt; NOTES &gt;&gt;&gt;  contain just as many elements as it did before. Remove returns
&gt; NOTES &gt;&gt;&gt;  an iterator that points to the end of the resulting range after
&gt; NOTES &gt;&gt;&gt;  elements have been removed from it; it follows that the
&gt; NOTES &gt;&gt;&gt;  elements after that iterator are of no interest, and may be
&gt; NOTES &gt;&gt;&gt;  discarded.
">

This link:
http://www.cplusplus.com/reference/algorithm/remove.html
tells this:
&quot;Notice that this function does not alter the elements past the new end,
which keep their old values and are still accessible.&quot;
IOW elements after new_end contain garbage. This is also said in the
last sentence in your notes.
</POST>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-11T07:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; On Thu, 11 Oct 2007 12:58:46 +0200, anon wrote:

&gt; This link:
&gt; http://www.cplusplus.com/reference/algorithm/remove.html
&gt; tells this:
&gt; &quot;Notice that this function does not alter the elements past the new end,
&gt; which keep their old values and are still accessible.&quot;
&gt; IOW elements after new_end contain garbage. This is also said in the
&gt; last sentence in your notes.
">

yes, what i want to now is that where are the 2 removed integers ? They
are not erased, it is sure. look again at the RUN of the program:

~/programming/c++ $ ./a.out
3 1 4 1 5 9
--------------- NEW RANGE -----------
3 4 5 9
-------------- REMOVED RANGE -------------
5 9

so it looks like &quot;3 4 5 9 5 9&quot; and after 9 we have V.end() . Hence I
deduce that:

1.) the 2 integers, the 1s (ones) are pushed beyond V.end()

2.) 4 was pushed closer to 3 and 5 &amp; 9 were copied (leaving the original
values at their original place intact)

3.) If they were pushed byond V.end(), then it really means they are
present at V.end() + 1 and V.end + 2 . (but those may contain garbage now)

-- arnuld
http://lispmachine.wordpress.com
</POST>
<POST>
<POSTER> anon &lt;a...@no.no&gt; </POSTER>
<POSTDATE> 2007-10-11T08:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
arnuld wrote:
&gt;&gt; On Thu, 11 Oct 2007 12:58:46 +0200, anon wrote:

&gt;&gt; This link:
&gt;&gt; http://www.cplusplus.com/reference/algorithm/remove.html
&gt;&gt; tells this:
&gt;&gt; &quot;Notice that this function does not alter the elements past the new end,
&gt;&gt; which keep their old values and are still accessible.&quot;
&gt;&gt; IOW elements after new_end contain garbage. This is also said in the
&gt;&gt; last sentence in your notes.

&gt; yes, what i want to now is that where are the 2 removed integers ? They
&gt; are not erased, it is sure. look again at the RUN of the program:

&gt; ~/programming/c++ $ ./a.out
&gt; 3 1 4 1 5 9
&gt; --------------- NEW RANGE -----------
&gt; 3 4 5 9
&gt; -------------- REMOVED RANGE -------------
&gt; 5 9

&gt; so it looks like &quot;3 4 5 9 5 9&quot; and after 9 we have V.end() . Hence I
&gt; deduce that:

&gt; 1.) the 2 integers, the 1s (ones) are pushed beyond V.end()
">

They are not pushed anywhere - they are removed. Beyond V.end() is some
random memory which you should not access

<QUOTE PREVIOUSPOST="
&gt; 2.) 4 was pushed closer to 3 and 5 &amp; 9 were copied (leaving the original
&gt; values at their original place intact)
">

4-5-9 were copied closer to 3, and in the range [new_end,end()) is left
garbage

<QUOTE PREVIOUSPOST="
&gt; 3.) If they were pushed byond V.end(), then it really means they are
&gt; present at V.end() + 1 and V.end + 2 . (but those may contain garbage now)
">

When you access V.end(), or V.end()+n, you are accessing some random memory.
</POST>
<POST>
<POSTER> Michael DOUBEZ &lt;michael.dou...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-11T09:27:00 </POSTDATE>
arnuld a écrit :

<QUOTE PREVIOUSPOST="
&gt;&gt; On Thu, 11 Oct 2007 12:58:46 +0200, anon wrote:

&gt;&gt; This link:
&gt;&gt; http://www.cplusplus.com/reference/algorithm/remove.html
&gt;&gt; tells this:
&gt;&gt; &quot;Notice that this function does not alter the elements past the new end,
&gt;&gt; which keep their old values and are still accessible.&quot;
&gt;&gt; IOW elements after new_end contain garbage. This is also said in the
&gt;&gt; last sentence in your notes.

&gt; yes, what i want to now is that where are the 2 removed integers ? They
&gt; are not erased, it is sure. look again at the RUN of the program:
">

Just to make clear what std::remove does (or could do - higly unlikely,
should find first element to remove first):

template&lt;typename ForwardIterator, typename T&gt;
iterator remove(ForwardIterator begin, ForwardIterator end, T value)
{
//find at least one element to remove
ForwardIterator new_end=begin;
for(;begin!=end;++begin)
{
if( ! (value == *begin) )
{
*new_end=*begin;
++new_end;
}
}
return new_end;

<QUOTE PREVIOUSPOST="
}
">

Michael
</POST>
<POST>
<POSTER> Anand Hariharan &lt;mailto.anand.hariha...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T11:46:00 </POSTDATE>
On Oct 11, 5:37 am, arnuld &lt;NoS ... @NoPain.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &gt; On Thu, 11 Oct 2007 11:57:17 +0200, Michael DOUBEZ wrote:
(...)
&gt; NOTES &gt;&gt;&gt;  If you are removing elements from a Sequence, you may simply
&gt; NOTES &gt;&gt;&gt;  erase them. That is, a reasonable way of removingelements from
&gt; NOTES &gt;&gt;&gt;  a Sequence is S.erase(remove(S.begin(), S.end(), x), S.end())

&gt; I guess that is better and little Googling tells me that it is Scott
&gt; Meyer's technique # 32 :-)
">

This article by Scott Meyers might help in explaining why remove
behaves like the way it does:

http://www.artima.com/cppsource/top_cpp_aha_moments.html

- Anand
</POST>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-11T14:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; On Thu, 11 Oct 2007 15:27:13 +0200, Michael DOUBEZ wrote:
&gt; Just to make clear what std::remove does (or could do - higly unlikely,
&gt; should find first element to remove first):
">

I do not understadn template source-code yet but I will try :-)

<QUOTE PREVIOUSPOST="
&gt; template&lt;typename ForwardIterator, typename T&gt;
&gt; iterator remove(ForwardIterator begin, ForwardIterator end, T value)
&gt; {
&gt;     //find at least one element to remove
&gt;     ForwardIterator new_end=begin;
&gt;     for(;begin!=end;++begin)
&gt;     {
&gt;        if( ! (value == *begin) )
&gt;        {
&gt;         *new_end=*begin;
&gt;         ++new_end;
&gt;        }
&gt;     }
&gt;     return new_end;
&gt; }
">

to me, it looks like it is creating a new iterator without affecting
the old iterators and the new iterator is of the same type as the older
begin iterator. We are just creating the new begin iterator and using it
to overwrite the elements, it is just that new iterator skips some value
(the value we do not want).

If I am wrong, Poke me in the eye.

-- arnuld
http://lispmachine.wordpress.com
</POST>
<POST>
<POSTER> Michael DOUBEZ &lt;michael.dou...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-12T03:59:00 </POSTDATE>
arnuld a écrit :

<QUOTE PREVIOUSPOST="
&gt;&gt; On Thu, 11 Oct 2007 15:27:13 +0200, Michael DOUBEZ wrote:

&gt;&gt; Just to make clear what std::remove does (or could do - higly unlikely,
&gt;&gt; should find first element to remove first):

&gt; I do not understadn template source-code yet but I will try :-)
">

Removing templating and using generic iterator on container storing
integers:

iterator remove(iterator begin, iterator end, int value)
{
iterator new_end=begin;
for(;begin!=end;++begin)
{
if( ! (value == *begin) )
{
*new_end=*begin;
++new_end;
}
}
return new_end;

<QUOTE PREVIOUSPOST="
}
&gt; [snip]  We are just creating the new begin iterator and using it
&gt; to overwrite the elements, it is just that new iterator skips some value
&gt; (the value we do not want).

&gt; If I am wrong, Poke me in the eye.
">

That's it. Your binocular vision is safe.

Michael
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T04:04:00 </POSTDATE>
On Oct 11, 10:35 am, anon &lt;a ... @no.no&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; arnuld wrote:
&gt; &gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; &gt; got that understanding from here:
&gt; &gt; http://www.cppreference.com/cppalgorithm/remove.html
&gt; &gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; &gt; ....&quot;
&gt; &gt; fortunately comp.lang.c++ told me that is not true and Stroustrup on my
&gt; &gt; Desk also confirmed that. Sadly, Nicolai's book is not availale in my
&gt; &gt; country, So i looked for some correct online reference and I found this
&gt; &gt; one is frequently recommended:
&gt; Whats wrong there? http://www.cplusplus.com/reference/algorithm/remove.htmlgives the same
&gt; explanation.
">

And their explination is wrong as well.  (At least they give
some examples, so you might be able to figure it out.)

std::remove doesn't remove anything.  It can't; to &quot;remove&quot;
something, you need a container, and the algorithm doesn't have
access to one.

The description at Dinkumware is far more precise; the one at
SGI is pretty good as well.  (The one at SGI may be the source
of the misinformation in the other two.  It starts &quot;Remove
removes from the range [first, last) all elements that are equal
to value.&quot;  It immediately follows up with an explination of
what they mean by this, however, and if you read the entire
paragraph, it's quite clear.  Apparently, the two references
mentioned above are guilty of quoting out of context.)

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T04:07:00 </POSTDATE>
On Oct 11, 11:57 am, Michael DOUBEZ &lt;michael.dou ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; arnuld a écrit :
&gt; &gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt; &gt; got that understanding from here:
&gt; &gt; http://www.cppreference.com/cppalgorithm/remove.html
&gt; &gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt; &gt; ....&quot;
&gt; &gt; fortunately comp.lang.c++ told me that is not true
&gt; I truth only one personn told you that.
&gt; &gt; and Stroustrup on my
&gt; &gt; Desk also confirmed that.
&gt; I don't have it here but I will check. I would be a surprise: saying
&gt; that std::remove doesn't remove would mean it is a misnommer. Perhaps
&gt; the distinction is a bit subtle and another world should have been used
&gt; but it doesn't mean it is false.
">

The English word &quot;remove&quot; is incorrect with regards to what
std::remove does.  If you insist on using it, as the SGI
specification does, it is essential to describe exactly what you
mean by it, since the &quot;normal&quot; English meaning will result in a
misunderstanding.

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> Michael DOUBEZ &lt;michael.dou...@free.fr&gt; </POSTER>
<POSTDATE> 2007-10-12T06:53:00 </POSTDATE>
James Kanze a écrit :

<QUOTE PREVIOUSPOST="
&gt; On Oct 11, 11:57 am, Michael DOUBEZ &lt;michael.dou ... @free.fr&gt; wrote:
&gt;&gt; arnuld a écrit :
&gt;&gt;&gt; you folks have seen how wrongly I understood std::remove() algorithm. I
&gt;&gt;&gt; got that understanding from here:

&gt;&gt;&gt; http://www.cppreference.com/cppalgorithm/remove.html

&gt;&gt;&gt; which simply says, &quot;The remove() algorithm removes all of the elements
&gt;&gt;&gt; ....&quot;

&gt;&gt;&gt; fortunately comp.lang.c++ told me that is not true

&gt;&gt; I truth only one personn told you that.

&gt;&gt;&gt; and Stroustrup on my
&gt;&gt;&gt; Desk also confirmed that.

&gt;&gt; I don't have it here but I will check. I would be a surprise: saying
&gt;&gt; that std::remove doesn't remove would mean it is a misnommer. Perhaps
&gt;&gt; the distinction is a bit subtle and another world should have been used
&gt;&gt; but it doesn't mean it is false.

&gt; The English word &quot;remove&quot; is incorrect with regards to what
&gt; std::remove does.  If you insist on using it, as the SGI
&gt; specification does, it is essential to describe exactly what you
&gt; mean by it, since the &quot;normal&quot; English meaning will result in a
&gt; misunderstanding.
">

Well, you know best. English is not my native tongue.

Googling for the definiton of remove:

Remove 1
Definition: To move away from the position occupied; to cause to change
place; to displace; as, to remove a building.

Remove 2
Definition: To cause to leave a person or thing; to cause to cease to
be; to take away; hence, to banish; to destroy; to put an end to; to
kill; as, to remove a disease.

Remove 3
Definition: To dismiss or discharge from office; as, the President
removed many postmasters.

Remove 4
Definition: To change place in any manner, or to make a change in place;
to move or go from one residence, position, or place to another.

Remove 5
Definition: The act of removing; a removal.

...

Since the parameter of the std::remove() algorithm is a range and
considering the above definition, IMHO 'remove' is not that bad.
Perhaps 'strip' would have been more meaningful.

Removing from a container is more related to 'erase' (google again)
because it relate to the storage system:

erase: 1. To obliterate information from a storage medium, such as to
clear or to overwrite. 2. In a magnetic storage medium, to remove all
stored data by (a) changing the medium to an unmagnetized state or (b)
changing the medium to a predetermined magnetized state. 3. In paper
tape and punched card storage, to punch a hole at every punch position.

Hence the member function Container::erase() I guess.

Michael
</POST>
<POST>
<POSTER> Joe Greer &lt;jgr...@doubletake.com&gt; </POSTER>
<POSTDATE> 2007-10-12T08:07:00 </POSTDATE>
Michael DOUBEZ &lt;michael.dou ... @free.fr&gt; wrote in
news:470f5047$0$6607$426a74cc@news.free.fr:

<QUOTE PREVIOUSPOST="
&gt; Well, you know best. English is not my native tongue.

&gt; Googling for the definiton of remove:

&gt; Remove 1
&gt; Definition: To move away from the position occupied; to cause to
&gt; change place; to displace; as, to remove a building.

&gt; Remove 2
&gt; Definition: To cause to leave a person or thing; to cause to cease to
&gt; be; to take away; hence, to banish; to destroy; to put an end to; to
&gt; kill; as, to remove a disease.

&gt; Remove 3
&gt; Definition: To dismiss or discharge from office; as, the President
&gt; removed many postmasters.

&gt; Remove 4
&gt; Definition: To change place in any manner, or to make a change in
&gt; place; to move or go from one residence, position, or place to
&gt; another.

&gt; Remove 5
&gt; Definition: The act of removing; a removal.
">

These are all pretty good.  (Except for definition #2 which has the odd mix of 'take
away', 'banish', and 'destroy'.  Destroy != banish in my mind.)  The implication is
that the removed item is no longer there, not that it has been moved next door.
However, except for in a few cases (such as a building), remove doesn't necessisarily
imply that the item was destroyed either.  So, I personally would say that remove is
generally an odd word to try to apply to a programming language action.  Of course,
there are other standard method names I find odd as well.  empty() is my favorite.
There is no way I would have guessed that this returned a boolean and did nothing
except for reading the docs. :)

joe
</POST>
<POST>
<POSTER> James Kanze &lt;james.ka...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T12:10:00 </POSTDATE>
On Oct 12, 12:53 pm, Michael DOUBEZ &lt;michael.dou ... @free.fr&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; James Kanze a écrit :
&gt; &gt; The English word &quot;remove&quot; is incorrect with regards to what
&gt; &gt; std::remove does.  If you insist on using it, as the SGI
&gt; &gt; specification does, it is essential to describe exactly what you
&gt; &gt; mean by it, since the &quot;normal&quot; English meaning will result in a
&gt; &gt; misunderstanding.
&gt; Well, you know best. English is not my native tongue.
">

I'm not sure it's mine any more either---I haven't used it on a
regular basis for close to 40 years.  (I'm not sure I have a
native tongue.  I feel most at home in French, but any Frenchman
will spot my accent a mile off.)

<QUOTE PREVIOUSPOST="
&gt; Googling for the definiton of remove:
">

[...]

There are a number of very good on line dictionaries as well;
you don't even have to Google (and you know exactly how reliable
the source is).  There are uses of remove whose meanings could
be more or less understood to apply.  They're simply not the
ones we &quot;expect&quot; in this context.

The proof, of course, is the number of people who are confused
by it, and expect it to remove something from somewhere.

<QUOTE PREVIOUSPOST="
&gt; ...
&gt; Since the parameter of the std::remove() algorithm is a range and
&gt; considering the above definition, IMHO 'remove' is not that bad.
&gt; Perhaps 'strip' would have been more meaningful.
">

I think that part of the problem is that &quot;remove&quot; is expected to
act on the sequence itself.  Within the C++ community, at least,
I don't think that most people think in (or expect) functional
programming idioms.  What the function really does (sort of) is
create a new sequence which contains all of the elements in the
original sequence, in order, except those it &quot;removed&quot;.  Except,
of course, that the &quot;new sequence&quot; isn't really new.

I suspect that Lisp programmers would feel right at home with
the name; from what little I've seen, they're quite used to the
functional programming idiom, and sharing parts of a list (a
sequence).

And while I don't like the name, I can't really think of a
better one, either.  But the easiest way to explain it to a
beginner is to start by saying something along the lines of
&quot;remove doesn't really remove&quot;, which really suggests very
strongly that the name isn't the right one.

<QUOTE PREVIOUSPOST="
&gt; Removing from a container is more related to 'erase' (google
&gt; again) because it relate to the storage system:
">

Except that &quot;erase&quot; isn't that often used in computer circles
for that operation.  In my first container class (very, very
pre-standard), I used &quot;delete&quot;, which I found perfect.  The
compiler didn't however, and I was forced to change it---to
remove.  (To me, erase suggests erasing something from a
blackboard, or pencil marks from a piece of paper.  The
information is lost, but the support is still there.  Something
like filling an array of int with 0's.)

<QUOTE PREVIOUSPOST="
&gt; erase: 1. To obliterate information from a storage medium, such as to
&gt; clear or to overwrite. 2. In a magnetic storage medium, to remove all
&gt; stored data by (a) changing the medium to an unmagnetized state or (b)
&gt; changing the medium to a predetermined magnetized state. 3. In paper
&gt; tape and punched card storage, to punch a hole at every punch position.
&gt; Hence the member function Container::erase() I guess.
&gt;From the above definition, I think that the names are reversed;
">

erase clears or overwrites (without removing the elements).

Perhaps part of the problem with remove, here, is that generally
within the STL, one thinks in terms of elements, and not values.
Remove &quot;defines&quot; a new sequence with the relevant values
removed, but does not remove elements.

--
James Kanze (GABI Software)             email:james.ka ... @gmail.com
Conseils en informatique orientée objet/
Beratung in objektorientierter Datenverarbeitung
9 place Sémard, 78210 St.-Cyr-l'École, France, +33 (0)1 30 23 00 34
</POST>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-12T14:06:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; On Fri, 12 Oct 2007 16:10:02 +0000, James Kanze wrote:
&gt; erase clears or overwrites (without removing the elements).
">

Ohh... One more confusion. Erase does not erase :-\

<QUOTE PREVIOUSPOST="
&gt; Perhaps part of the problem with remove, here, is that generally
&gt; within the STL, one thinks in terms of elements, and not values.
&gt; Remove &quot;defines&quot; a new sequence with the relevant values
&gt; removed, but does not remove elements.
">

I think a better name for std::remove will be:

std::remove_that_does_not_remove_BUT_actaully_is_just_an_iterator_creator

that explains well about what it does ;-)

-- arnuld
http://lispmachine.wordpress.com
</POST>
<POST>
<POSTER> arnuld &lt;NoS...@NoPain.com&gt; </POSTER>
<POSTDATE> 2007-10-12T14:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; On Fri, 12 Oct 2007 16:10:02 +0000, James Kanze wrote:
&gt; Perhaps part of the problem with remove, here, is that generally
&gt; within the STL, one thinks in terms of elements, and not values.
&gt; Remove &quot;defines&quot; a new sequence with the relevant values
&gt; removed, but does not remove elements.
">

perhaps this wil fit much betetr as a std::remove replacement:

std::remove_that_does_not_remove_BUT_actaully_is_just_an_iterator_creator_a nd_this_is_not_about_elements_but_values_only

that explains well about what it does ;-)

--
http://lispmachine.wordpress.com
</POST>
</TEXT>
</BODY>
</DOC>
