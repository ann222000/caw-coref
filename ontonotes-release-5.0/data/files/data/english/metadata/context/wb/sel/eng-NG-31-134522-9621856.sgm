<DOC>
<DOCID> eng-NG-31-134522-9621856 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-10-11T03:04:00 </DATETIME>
<BODY>
<HEADLINE>
Thanks Joe! (properties)
</HEADLINE>
<TEXT>
<POST>
<POSTER> Reinier Zwitserloot &lt;reini...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T03:04:00 </POSTDATE>
Until now I totally didn't get the hoopla about properties and I was a
proponent of 3 standardized annotations to solve the whole issue
(@Getter, @Setter, and @ChangeListener, which would generate standard
implementations of getFoobar/setFoobar/add-removeFoobarListener - and
if standard implementations are no good, remove the annotation and
actually write it the old fashioned way).

However, now I see where this property stuff is going. I did a
practice project in Cocoa/ObjC 2 months back and that is very
component oriented. It's all stuff we can do now but it is indeed a
completely different way of working.

I'm convinced. Properties FTW!
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-11T07:02:00 </POSTDATE>
Yay more one down, 57.261.235 to go. ;) Sadly the list of people who
haven't seen its merits appears to be really long. I guess you need to
have worked within such component systems to see why the Java way is
just too cumbersome and low-level.

/Casper

On Oct 11, 9:04 am, Reinier Zwitserloot &lt;reini ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Until now I totally didn't get the hoopla about properties and I was a
&gt; proponent of 3 standardized annotations to solve the whole issue
&gt; (@Getter, @Setter, and @ChangeListener, which would generate standard
&gt; implementations of getFoobar/setFoobar/add-removeFoobarListener - and
&gt; if standard implementations are no good, remove the annotation and
&gt; actually write it the old fashioned way).

&gt; However, now I see where this property stuff is going. I did a
&gt; practice project in Cocoa/ObjC 2 months back and that is very
&gt; component oriented. It's all stuff we can do now but it is indeed a
&gt; completely different way of working.

&gt; I'm convinced. Properties FTW!
">
</POST>
<POST>
<POSTER> &quot;J. McConnell&quot; &lt;jdo...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T08:22:00 </POSTDATE>
Does anyone know of any sample code you can point me at?  I've got a vague
notion of the benefits they'd offer, but I'd love to get a better idea of
how they work in practice.

Thanks,

- J.

On 10/11/07, Casper Bang &lt;c ... @brunata.dk&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Yay more one down, 57.261.235 to go. ;) Sadly the list of people who
&gt; haven't seen its merits appears to be really long. I guess you need to
&gt; have worked within such component systems to see why the Java way is
&gt; just too cumbersome and low-level.

&gt; /Casper

&gt; On Oct 11, 9:04 am, Reinier Zwitserloot &lt;reini ... @gmail.com&gt; wrote:
&gt; &gt; Until now I totally didn't get the hoopla about properties and I was a
&gt; &gt; proponent of 3 standardized annotations to solve the whole issue
&gt; &gt; (@Getter, @Setter, and @ChangeListener, which would generate standard
&gt; &gt; implementations of getFoobar/setFoobar/add-removeFoobarListener - and
&gt; &gt; if standard implementations are no good, remove the annotation and
&gt; &gt; actually write it the old fashioned way).

&gt; &gt; However, now I see where this property stuff is going. I did a
&gt; &gt; practice project in Cocoa/ObjC 2 months back and that is very
&gt; &gt; component oriented. It's all stuff we can do now but it is indeed a
&gt; &gt; completely different way of working.

&gt; &gt; I'm convinced. Properties FTW!
">
</POST>
<POST>
<POSTER> &quot;Curt Cox&quot; &lt;curt...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T08:32:00 </POSTDATE>
Joe and Casper,

Do you have any convincing arguments for those of us that would like
to see better properties support added, but aren't convinced that a
language level change is the best way to do it?  For a long time, I
was firmly in the add properties support to the language camp.  In the
last year, various implementations of property objects have shown that
the same advantages can be achieved by adding property object support
to the APIs.  The syntax is a little different, but the implementation
is far more flexible.  Now I'm on the fence.  Show me what I'm
missing.

- Curt
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-11T09:36:00 </POSTDATE>
J. McConnel: Have a brief look at some Flex or C# code, how simple and
natural it feels to model dynamic interactions when it is supported
directly within the language itself. I fear it's hard to see the
benefits without having worked with sufficiently complex applications.
Most technologies work well in their own micro-cosmos (here goes a
very long list of JSR's...), its when applying them horizontally
rather than vertically things start to fall apart.

Curt:
Well there certainly has been progress, but the classic flipside of
the Java umbrella still persists: There are far too many choices to be
made and lines of code to be written. The current relationship between
bean/POJO creator and consumer is too weak and fragile and IDE's have
an equally hard time reasoning about these interactions when it
depends on your choice of binding API or application framework/
technology. The bulk of the power comes from the consistency of
knowing that this is how we communicate dependencies and
responsibilities - regardless of what technology we're working with at
the moment. I.e. BeansBinding has to use a vast array of Swing
wrappers (which again uses AWT adaptors) to do its magic. This is
neither simple nor elegant and frankly I think we could use a bit more
convension and reuse in Java. Why would you want more than one
property/event model anyway?

/Casper

On Oct 11, 2:32 pm, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Joe and Casper,

&gt; Do you have any convincing arguments for those of us that would like
&gt; to see better properties support added, but aren't convinced that a
&gt; language level change is the best way to do it?  For a long time, I
&gt; was firmly in the add properties support to the language camp.  In the
&gt; last year, various implementations of property objects have shown that
&gt; the same advantages can be achieved by adding property object support
&gt; to the APIs.  The syntax is a little different, but the implementation
&gt; is far more flexible.  Now I'm on the fence.  Show me what I'm
&gt; missing.

&gt; - Curt
">
</POST>
<POST>
<POSTER> &quot;J. McConnell&quot; &lt;jdo...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T10:35:00 </POSTDATE>
Wow, I'm sold (and I don't do any client-side coding).  I've been a fan of
C#'s properties and delegates for awhile now, but I don't know how the event
and multicasting for delegates features escaped my notice.

Anyway, for anyone else that is vague on the notion of events, this is a
great intro:

http://www.akadia.com/services/dotnet_delegates_and_events.html

- J.

On 10/11/07, Casper Bang &lt;c ... @brunata.dk&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; J. McConnel: Have a brief look at some Flex or C# code, how simple and
&gt; natural it feels to model dynamic interactions when it is supported
&gt; directly within the language itself. I fear it's hard to see the
&gt; benefits without having worked with sufficiently complex applications.
&gt; Most technologies work well in their own micro-cosmos (here goes a
&gt; very long list of JSR's...), its when applying them horizontally
&gt; rather than vertically things start to fall apart.

&gt; Curt:
&gt; Well there certainly has been progress, but the classic flipside of
&gt; the Java umbrella still persists: There are far too many choices to be
&gt; made and lines of code to be written. The current relationship between
&gt; bean/POJO creator and consumer is too weak and fragile and IDE's have
&gt; an equally hard time reasoning about these interactions when it
&gt; depends on your choice of binding API or application framework/
&gt; technology. The bulk of the power comes from the consistency of
&gt; knowing that this is how we communicate dependencies and
&gt; responsibilities - regardless of what technology we're working with at
&gt; the moment. I.e. BeansBinding has to use a vast array of Swing
&gt; wrappers (which again uses AWT adaptors) to do its magic. This is
&gt; neither simple nor elegant and frankly I think we could use a bit more
&gt; convension and reuse in Java. Why would you want more than one
&gt; property/event model anyway?

&gt; /Casper

&gt; On Oct 11, 2:32 pm, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:
&gt; &gt; Joe and Casper,

&gt; &gt; Do you have any convincing arguments for those of us that would like
&gt; &gt; to see better properties support added, but aren't convinced that a
&gt; &gt; language level change is the best way to do it?  For a long time, I
&gt; &gt; was firmly in the add properties support to the language camp.  In the
&gt; &gt; last year, various implementations of property objects have shown that
&gt; &gt; the same advantages can be achieved by adding property object support
&gt; &gt; to the APIs.  The syntax is a little different, but the implementation
&gt; &gt; is far more flexible.  Now I'm on the fence.  Show me what I'm
&gt; &gt; missing.

&gt; &gt; - Curt
">
</POST>
<POST>
<POSTER> &quot;Curt Cox&quot; &lt;curt...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-11T11:10:00 </POSTDATE>
Casper,

Look at the list of implementing classes to see the value of multiple
implementations.

net.java.dev.properties Interface Property&lt;T&gt;
https://bean-properties.dev.java.net/javadoc/net/java/dev/properties/...

I would add wrappers that modify threading to that list.  Perhaps
there is one particular implementation, that so dominates the others,
that it alone deserves special language support.  I doubt that.
Hiding behind an interface gives much more room to be wrong, or at
least not completely right.

There are two basic arguments that could convince me that language
level properties are superior to property objects.
1) Tool support that can be accomplished much more easily.
2) Code that is more readable.

- Curt
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-12T10:39:00 </POSTDATE>
Curt,

Interoperability and homogeneity are not issues in your book? I don't
see how bean-properties cater to a generic component model and not
really crazy about having the IDE's do even more boilerplate code
generation.

An analogy: What have we gained from having 15+ different layout
managers over the years? Personally I would rather have one good
generic one that I can become an expert on than having to research and
pick from a large group of possible ones. Try opening a Swing form
generated by NetBeans Matisse (GroupLayout), in another state-of-the-
art IDE such as JDeveloper (which favors JGoodies FormLayout) and the
benefits become really hard to see. Even if there is one more optimal
manager for a given layout task (say a GridLayout if you are
implementing a spreadsheet), the payoff of having/knowing/tooling with
just one is greater.

/Casper

On Oct 11, 5:10 pm, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Casper,

&gt; Look at the list of implementing classes to see the value of multiple
&gt; implementations.

&gt; net.java.dev.properties Interface Property&lt;T&gt; https://bean-properties.dev.java.net/javadoc/net/java/dev/properties/ ...

&gt; I would add wrappers that modify threading to that list.  Perhaps
&gt; there is one particular implementation, that so dominates the others,
&gt; that it alone deserves special language support.  I doubt that.
&gt; Hiding behind an interface gives much more room to be wrong, or at
&gt; least not completely right.

&gt; There are two basic arguments that could convince me that language
&gt; level properties are superior to property objects.
&gt; 1) Tool support that can be accomplished much more easily.
&gt; 2) Code that is more readable.

&gt; - Curt
">
</POST>
<POST>
<POSTER> &quot;Curt Cox&quot; &lt;curt...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T11:08:00 </POSTDATE>
Casper,

You're going to have to make this more concrete for me to follow it.
Can you give me some code snippets that demonstrate the advantages
you're thinking of?

- Curt
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-12T12:48:00 </POSTDATE>
On Oct 12, 5:08 pm, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Can you give me some code snippets that demonstrate the advantages
">

----------------[ Java bean-properties ]----------------
class Customer{
private final PropertyChangeSupport _propertyChangeSupport;
private String _name;

public void addPropertyChangeListener(PropertyChangeListener
listener){

_propertyChangeSupport.addPropertyChangeListener(listener);
}

public void
removePropertyChangeListener(PropertyChangeListener listener){

_propertyChangeSupport.removePropertyChangeListener(listener);
}

public PropertyChangeListener[] getPropertyChangeListeners(){
return
_propertyChangeSupport.getPropertyChangeListeners();
}

protected void firePropertyChange(String propertyName, Object
oldValue, Object newValue){
_propertyChangeSupport.firePropertyChange(propertyName,
oldValue, newValue);
}

public Customer(String name){
propertyChangeSupport = new PropertyChangeSupport(this);
setName(name);
};

public String getName(){ return _name; }
public void setName(String name){ firePropertyChange(&quot;name&quot;,
_name, _name = name); }
}

Customer customer = new Customer(&quot;John&quot;);
String customerName =
BeanProperty.create(&quot;name&quot;).getValue(customer);
// customerName now is a workable property containing the string
John

----------------[ C# (Orcas) ]----------------

class Customer{
public String name { get; set; }
}

Customer customer = new Customer { name=&quot;John&quot; };
// customer.name now is a workable property containing the string
John.
</POST>
<POST>
<POSTER> &quot;Curt Cox&quot; &lt;curt...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T23:04:00 </POSTDATE>
Casper,

I agree that the status quo is unworkable.  Using the implementation
of property objects from the bean-properties project, your example
would become:

class Customer {
public final Property&lt;String&gt; name = ObservableProperty.create();
public Customer() {
BeanContainer.bind(this);
}

<QUOTE PREVIOUSPOST="
}
">

While that still represents more code than a language change, it's now
pretty close.  A static import and moving logic into a super class
could give you:

class Customer extends BasicBean {
public final Property&lt;String&gt; name = create();

<QUOTE PREVIOUSPOST="
}
">

A lot of library work would need to be done to ensure that this style
of property is supported on equal footing with the classic style.
Still, no language changes would be needed.

Sun has put the JVM in a bad position by so heavily weighting language
support towards Java.  They have a desire to be conservative about
adding language features and favor readability. That would sit better
if they supported more languages, so people didn't always need to turn
to Java for their JVM language needs.

I want JVM support for all of the top ten:
http://www.tiobe.com/tpci.htm
</POST>
<POST>
<POSTER> Kevin Wong &lt;kevin.peter.w...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-12T23:13:00 </POSTDATE>
I thought the bean-properties version would look like this:

public class Customer {
public final Property&lt;Integer&gt; name = ObservableProperty.create();

public CompatibilityBean() {
BeanContainer.bind(this);
}

public void addPropertyChangeListener(PropertyChangeListener l) {
BeanContainer.get().addPropertyChangeListener(this, l);
}

public void addPropertyChangeListener(String n,
PropertyChangeListener l) {
BeanContainer.get().addPropertyChangeListener(this, n, l);
}

<QUOTE PREVIOUSPOST="
}
">

Customer customer = new Customer(&quot;John&quot;);
// customer.name.get() provides the string John

Also, how is the listener stuff handled in the C# version, i.e., how
do you add a listener to the Customer instance?

Perhaps it would also be helpful if someone could refute the claims in
this article entitled &quot;10 Things That are considerably harder/
impossible to achieve with get/set methods or the property keyword&quot;:
https://bean-properties.dev.java.net/10things.html .

On Oct 12, 12:48 pm, Casper Bang &lt;c ... @brunata.dk&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Oct 12, 5:08 pm, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:

&gt; &gt; Can you give me some code snippets that demonstrate the advantages

&gt;     ----------------[ Java bean-properties ]----------------
&gt;     class Customer{
&gt;         private final PropertyChangeSupport _propertyChangeSupport;
&gt;         private String _name;

&gt;         public void addPropertyChangeListener(PropertyChangeListener
&gt; listener){

&gt; _propertyChangeSupport.addPropertyChangeListener(listener);
&gt;         }

&gt;         public void
&gt; removePropertyChangeListener(PropertyChangeListener listener){

&gt; _propertyChangeSupport.removePropertyChangeListener(listener);
&gt;         }

&gt;         public PropertyChangeListener[] getPropertyChangeListeners(){
&gt;             return
&gt; _propertyChangeSupport.getPropertyChangeListeners();
&gt;         }

&gt;         protected void firePropertyChange(String propertyName, Object
&gt; oldValue, Object newValue){
&gt;             _propertyChangeSupport.firePropertyChange(propertyName,
&gt; oldValue, newValue);
&gt;         }

&gt;         public Customer(String name){
&gt;             propertyChangeSupport = new PropertyChangeSupport(this);
&gt;             setName(name);
&gt;         };

&gt;         public String getName(){ return _name; }
&gt;         public void setName(String name){ firePropertyChange(&quot;name&quot;,
&gt; _name, _name = name); }
&gt;     }

&gt;     Customer customer = new Customer(&quot;John&quot;);
&gt;     String customerName =
&gt; BeanProperty.create(&quot;name&quot;).getValue(customer);
&gt;     // customerName now is a workable property containing the string
&gt; John

&gt;     ----------------[ C# (Orcas) ]----------------

&gt;     class Customer{
&gt;         public String name { get; set; }
&gt;     }

&gt;     Customer customer = new Customer { name=&quot;John&quot; };
&gt;     // customer.name now is a workable property containing the string
&gt; John.
">
</POST>
<POST>
<POSTER> Kevin Wong &lt;kevin.peter.w...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T00:18:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; An analogy: What have we gained from having 15+ different layout
&gt; managers over the years? Personally I would rather have one good
&gt; generic one that I can become an expert on than having to research and
&gt; pick from a large group of possible ones. Try opening a Swing form
&gt; generated by NetBeans Matisse (GroupLayout), in another state-of-the-
&gt; art IDE such as JDeveloper (which favors JGoodies FormLayout) and the
&gt; benefits become really hard to see. Even if there is one more optimal
&gt; manager for a given layout task (say a GridLayout if you are
&gt; implementing a spreadsheet), the payoff of having/knowing/tooling with
&gt; just one is greater.
">

Um, I think this layout example perfectly illustrates why extension by
API is a _good_ thing.  Imagine we had committed ourselves to the
original silly layout managers with language constructs; we would
never have gained the pleasure of Matisse.  The fact that they were
API extensions and not language ones meant that they could evolve,
improve, and eventually be succeeded.

Another example of the benefits of API extensions is the for-each
loop.  For-each should have been implemented as an addition to the
Collections API (Collection#forEach(closure)) (of course, closures
would have
to be added as well, but that's excusable as it has no API
equivalent).  Had we gone that way, the current outcries for a
java.uitl.Map equivalent could have been satisfied trivially:
Map#forEach(closure).

Evolution is a wonderful and powerful process, and is especially
beneficial to the advancement of software.  We should let it do its
thing, if we can.
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-13T00:53:00 </POSTDATE>
On Oct 13, 5:04 am, &quot;Curt Cox&quot; &lt;curt ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; While that still represents more code than a language change, it's now
&gt; pretty close.  A static import and moving logic into a super class
&gt; could give you:
">

Yeah but the Java single inheritance philosophy (and no extension
methods) does not sit well with super classes, thus I would prefer if
it was factored into the language at Object level - perhaps through
the same mechanism as when we denote a class as Serializable.

<QUOTE PREVIOUSPOST="
&gt; Sun has put the JVM in a bad position by so heavily weighting language
&gt; support towards Java.  They have a desire to be conservative about
&gt; adding language features and favor readability. That would sit better
&gt; if they supported more languages, so people didn't always need to turn
&gt; to Java for their JVM language needs.
">

Right, one just have to debug a class file to see how strong the
language is tied to the JVM, expanding idioms, inner classes etc. We
did not hear a peep about multiple languages until the CLR arrived
(which IL op-codes are lower-level) so yes it will support other
languages, but it wasn't designed for it.

<QUOTE PREVIOUSPOST="
&gt; Also, how is the listener stuff handled in the C# version, i.e., how
&gt; do you add a listener to the Customer instance?
">

In C# there is a distinct difference between a property (the
manipulation of internal states) and events (published notifications
of state change). The notification mechanism do not differ much from
Java and the classic observer pattern except that they are supported
in the language though delegates (parameter list signature callbacks,
rather than interfaces). You may also use data binding to hook
components together (anything implementing IList or IComponent) but
that has very little to do with the basic consept of a property and an
event - although binding seems to be the primary focus in the Java
proposals.

<QUOTE PREVIOUSPOST="
&gt; we would never have gained the pleasure of Matisse.
">

After many late hours struggling with GridbagLayout, all it took
was .NET's Dock and Anchor to inspire. ;) GroupLayout is great yes,
but not perfect, it requires an accompanying XML file and locks
whichever lines the IDE has generated so you often need an editor next
to NetBeans. Anyway, I did not actually insinuate that a layout
manager should be in the language (how would that be done?) but rather
used it as an example of tooling complications from having many
specific instead of one general.

<QUOTE PREVIOUSPOST="
&gt; Evolution is a wonderful and powerful process, and is especially
&gt; beneficial to the advancement of software.  We should let it do its
&gt; thing, if we can.
">

I agree, that's why its so sad to see Java become a dinosaur - large,
old and unable to adapt.

/Casper
</POST>
<POST>
<POSTER> &quot;shai.al...@gmail.com&quot; &lt;shai.al...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T04:02:00 </POSTDATE>
Hi Casper,
I think you are mixing between bean-properties and bean bindings (JSR
295). I am the project lead of bean properties https://bean-properties.dev.java.net/
which is completely different from 295 and predated it in the public
(although was formed well after the expert group started work).

The layout manager analogy is completely broken in several ways if
that was the case which layout manager would we pick?
My money is we would have been stuck with gridbag, formlayout has its
problems not to mention group layout was remarkably late for the party
and mig came after it (turns out it wasn't the &quot;end all&quot;).
Assuming it was theoretically possible to have the layout manager that
&quot;solved everything&quot; and everyone liked... Layout managers is a far
smaller problem than properties.

Currently properties in Java do NOT work! So all property keyword
suggestion that would &quot;just&quot; translate &quot;property&quot; to getter/setter
would work for trivial cases but not for something slightly harder.
E.g. an IndexedProperty in Java, this is so broken in current
JavaBeans there is a getValue(int) convention which no one uses since
it just doesn't work in the spec level. Even Hibernate and 295 use a
collection based approach since indexed properties in JavaBeans don't
work.
In bean properties this is as simple as:
public final IndexedProperty&lt;MyBean&gt; list =
ObservableIndexed.create();

Notice that this would be type safe and observable to begin with... No
tricks.

Why would you need to do your own property interface  implementations?

Imagine language support for the following:
1. Indexed properties
2. Map properties.
3. Observability - for all types of properties
4. Vetoable properties
5. Validations
6. Delegates (properties that hold no state and delegate to another
bean)
7. Mirrors (beans that contain getters and setters and represent
themselves using a virtual object to the system).
8. Virtual properties (properties that can be added on the fly, I hate
this myself but there are a few justified use cases).

The list goes on and sometimes you would want a combination of
elements from the list.

About a threaded property, I added just before M1 some threading
policy support at the bean container level. This is rather elaborate
and should support most use cases.

About a language change, I am in discussions with several pro language
change people. I was able to convince them that the bean-properties
approach is superior but I was not able to dissuade them from their
desire to a language change. So our discussion right now is focused
around how you can build a language change on top of something like
bean-properties and what would the advantages be. There are huge
advantages for this approach after all bean-properties without a
language change is already more concise than most language change
suggestions in the wild right now...

<QUOTE PREVIOUSPOST="
&gt; &gt; While that still represents more code than a language change, it's now
&gt; &gt; pretty close.  A static import and moving logic into a super class
&gt; &gt; could give you:
">

This is more code only for the trivial case which you hardly ever do.
If you add observability/validation etc... you will have far less
code. Jesse made a language change suggestion in a recent JavaLobby
thread and I demonstrated how I can write the same code with all the
benefits and a shorter syntax today.

<QUOTE PREVIOUSPOST="
&gt; Yeah but the Java single inheritance philosophy (and no extension
&gt; methods) does not sit well with super classes, thus I would prefer if
&gt; it was factored into the language at Object level - perhaps through
&gt; the same mechanism as when we denote a class as Serializable.
">

Property and BaseProperty are generic interfaces not classes. Feel
free to build anything you want. Much of the &quot;heavy lifting&quot; is done
in bean properties by context objects and the bean-container which you
can inherit but don't need to.

<QUOTE PREVIOUSPOST="
&gt; Right, one just have to debug a class file to see how strong the
&gt; language is tied to the JVM, expanding idioms, inner classes etc. We
&gt; did not hear a peep about multiple languages until the CLR arrived
&gt; (which IL op-codes are lower-level) so yes it will support other
&gt; languages, but it wasn't designed for it.
">

The funny is that before CLR arrived we had many small languages on
the VM already from REXX to Jython and quite a few others. Not to
mention Java enhancements such as Pizza...
We just didn't hear about them and now we do.
All in favor for many languages on the VM ;-)

<QUOTE PREVIOUSPOST="
&gt; In C# there is a distinct difference between a property (the
&gt; manipulation of internal states) and events (published notifications
&gt; of state change). The notification mechanism do not differ much from
&gt; Java and the classic observer pattern except that they are supported
&gt; in the language though delegates (parameter list signature callbacks,
&gt; rather than interfaces). You may also use data binding to hook
&gt; components together (anything implementing IList or IComponent) but
&gt; that has very little to do with the basic consept of a property and an
&gt; event - although binding seems to be the primary focus in the Java
&gt; proposals.
">

Copied from Delphi as would be expected...
This is a huge step back from bean-properties both in terms of
verbosity and in terms of user control.

In fact our whole ORM layer was written on top of our listener and
event engine without instrumenting a single class. This is a testament
to the power of an open/extensible API to be used for things other
than the original intention.

<QUOTE PREVIOUSPOST="
&gt; &gt; we would never have gained the pleasure of Matisse.

&gt; After many late hours struggling with GridbagLayout, all it took
&gt; was .NET's Dock and Anchor to inspire. ;) GroupLayout is great yes,
&gt; but not perfect, it requires an accompanying XML file and locks
">

Group layout makes no XML requirement. The Form XML file is a part of
the GUI builder which locks lines of code for editing (a good policy
IMO).
Funny, you should mention .NET and complain about locking :)

<QUOTE PREVIOUSPOST="
&gt; whichever lines the IDE has generated so you often need an editor next
&gt; to NetBeans. Anyway, I did not actually insinuate that a layout
&gt; manager should be in the language (how would that be done?) but rather
&gt; used it as an example of tooling complications from having many
&gt; specific instead of one general.
">

Locked lines should NEVER be manually edited. All locked lines can be
modified using the tabs for the code customization in the GUI editor.
Unlike 2-way tools on the market Matisse very rarely &quot;breaks down&quot;,
all other GUI builders I know break down when you start coding
anything even slightly elaborate.

<QUOTE PREVIOUSPOST="
&gt; &gt; Evolution is a wonderful and powerful process, and is especially
&gt; &gt; beneficial to the advancement of software.  We should let it do its
&gt; &gt; thing, if we can.

&gt; I agree, that's why its so sad to see Java become a dinosaur - large,
&gt; old and unable to adapt.
">

Thats a generic and unfounded statement! If Java is a dinosaur it is a
raptor fast and deadly...
Adapting should be done in an intelligent way rather than copying
whatever other languages did and building a whole huge C++ style mess
like C# has done. It is already more bloated and inconsistent than C++
as it is. Ruby is another great example of code that is practically
unreadable because every single feature was built directly into the
language rather than the API.

When you build something into the language you are stuck with it for
good. It is set in stone and can't be fixed properly or upgraded, so
if properties are implemented in the language badly (as in C#) then we
will be stuck with that forever. Java has the opportunity to innovate
in this case rather than just &quot;do what everyone else is doing&quot;.
</POST>
<POST>
<POSTER> &quot;shai.al...@gmail.com&quot; &lt;shai.al...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T04:49:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; I thought the bean-properties version would look like this:
">

The code bellow is only necessary for PropertyChangeSupport
compatibility normally you can just write this:
public class Customer {
public final Property&lt;Integer&gt; name = ObservableProperty.create();

public CompatibilityBean() {
BeanContainer.bind(this);
}

<QUOTE PREVIOUSPOST="
}
">

And then to add a listener you would just:
BeanContainer.get().addListener(customerInstance.name, myListener);

Notice that no String name is necessary or used in this example which
is fully checked by the compiler.

If you need getters/setters and add/removePropertyChangeListener to
exist in the bean (for binary compatibility with API's that accept
JavaBeans) you can code something similar to your example or you can
use an Ant task/command line tool that we provide in bean-properties
that automatically adds these methods to the bean.
This is explained in the tutorial although the explanation might be a
bit hazy it was one of my first tutorials and might need some
refinement ;-)

<QUOTE PREVIOUSPOST="
&gt; public class Customer {
&gt;     public final Property&lt;Integer&gt; name = ObservableProperty.create();

&gt;     public CompatibilityBean() {
&gt;         BeanContainer.bind(this);
&gt;     }

&gt;     public void addPropertyChangeListener(PropertyChangeListener l) {
&gt;         BeanContainer.get().addPropertyChangeListener(this, l);
&gt;     }

&gt;     public void addPropertyChangeListener(String n,
&gt; PropertyChangeListener l) {
&gt;         BeanContainer.get().addPropertyChangeListener(this, n, l);
&gt;     }

&gt; }
">
</POST>
<POST>
<POSTER> Casper Bang &lt;c...@brunata.dk&gt; </POSTER>
<POSTDATE> 2007-10-13T10:56:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; The funny is that before CLR arrived we had many small languages on
&gt; the VM already from REXX to Jython and quite a few others. Not to
&gt; mention Java enhancements such as Pizza...
">

Right, and we all know how &quot;wonderful&quot; a generics implementation Pizza
gave us, being all syntax sugar (automated casts) and nothing more.
Jim Hugunin needed only a few weeks of playing with the CLR before
dumping the JVM and thus Jython became IronPython. But we all agree
that having many languages is a good thing, hell the JVM will probably
outlive Java the language.

<QUOTE PREVIOUSPOST="
&gt; This is a huge step back from bean-properties both in terms of
&gt; verbosity and in terms of user control.
">

But it reflects the KISS which seems to have long gone out of Java.

<QUOTE PREVIOUSPOST="
&gt; Locked lines should NEVER be manually edited. All locked lines can be
&gt; modified using the tabs for the code customization in the GUI editor.
&gt; Unlike 2-way tools on the market Matisse very rarely &quot;breaks down&quot;,
&gt; all other GUI builders I know break down when you start coding
&gt; anything even slightly elaborate.
">

We had several projects break down, where we had to do a SVN revert to
get back to whichever valid state between the XML and the java file is
required. It especially happens with 3'rd part &quot;components&quot; and its
just not optimal having a tool lock lines of code because that is the
only way it can reason about it. Cut-n-pasting chunks of code to
improve internal structure is just impossible. In C# not even the
InitializeComponent (like the Matisse initComponents) is locked, I'm
guessing they can do that because they do not need a million adaptors
in place and associated housekeeping metadata. In any event, it feels
less of a prison with horizontal blue bars. ;)

<QUOTE PREVIOUSPOST="
&gt; Thats a generic and unfounded statement! If Java is a dinosaur it is a
&gt; raptor fast and deadly...
&gt; Adapting should be done in an intelligent way rather than copying
&gt; whatever other languages did and building a whole huge C++ style mess
&gt; like C# has done. It is already more bloated and inconsistent than C++
&gt; as it is.
">

Could you elaborate on what mess in C# you are referring to? We can
all agree that C++ went too far, but sweep in front of your own door
before pointing at the neighbors. Have you tried explaining what the
final keyword means in Java to newcomers trying to get their head
around 1 word with 3 semantics? Talk about inconsistancy right there
in core of the language type system, not to mention API level stuff
like Comparator vs. Comparable, Iterator vs. Enumerator etc.

<QUOTE PREVIOUSPOST="
&gt; Ruby is another great example of code that is practically
&gt; unreadable because every single feature was built directly into the
&gt; language rather than the API.
">

Aha, so now C# and C++ is practically unreadable? At least in Ruby you
only have to read 3 lines of code instead of 10 in Java, and I don't
think its fair comparing readability between a static and a dynamic
language, two entirely different beasts. Out of curiousity, is Scala
also on your unreadable list?

<QUOTE PREVIOUSPOST="
&gt; When you build something into the language you are stuck with it for
&gt; good. It is set in stone and can't be fixed properly or upgraded, so
&gt; if properties are implemented in the language badly (as in C#) then we
&gt; will be stuck with that forever. Java has the opportunity to innovate
&gt; in this case rather than just &quot;do what everyone else is doing&quot;.
">

There it is again, you really need to come with more substance than
the statement that its implemented badly in C#. I can only guess that
you are missing some very specific binding features which again, has
nothing to do with a published component property. Perhaps the notion
of a property and an event simply meens different things to use, but I
definately do commend you and Remi Forax for the interesting
workarounds to these problems in Java - while Sun is busy changing
Nasdaq ticker and other important stuff.

/Casper
</POST>
<POST>
<POSTER> &quot;shai.al...@gmail.com&quot; &lt;shai.al...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T11:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; Right, and we all know how &quot;wonderful&quot; a generics implementation Pizza
&gt; gave us, being all syntax sugar (automated casts) and nothing more.
">

As opposed to the current generics implementation in what way ;-)

<QUOTE PREVIOUSPOST="
&gt; &gt; This is a huge step back from bean-properties both in terms of
&gt; &gt; verbosity and in terms of user control.

&gt; But it reflects the KISS which seems to have long gone out of Java.
">

Here I disagree completely and thats a blanket statement that doesn't
give an example. I however will give an example:

public property String name = &quot;X&quot;;

This implicitly creates a field called String name which you cannot
remove and getter/setter. If you want observability you need to do
something like:

public observable property String name = &quot;X&quot;;
public void magicCallback(Property p, Object oldVal, Object newVal) {
// .... code to fire events

<QUOTE PREVIOUSPOST="
}
">

public addPropertyChangeListener(Property p,
PropertyChangeListener ...) {
//...

<QUOTE PREVIOUSPOST="
}
">

public removePropertyChangeListener(Property p,
PropertyChangeListener ...) {
//...

<QUOTE PREVIOUSPOST="
}
">

public addPropertyChangeListener(PropertyChangeListener ...) {
//...

<QUOTE PREVIOUSPOST="
}
">

public removePropertyChangeListener(PropertyChangeListener ...) {

<QUOTE PREVIOUSPOST="
}
">

This is pretty close to REAL code with current language change
suggestions... simple?

You add several new keywords some magic callback methods etc... Yet
you are not really compatible with older Java so whats the benefit?

You are forced to create a field for a property, how is this
encapsulation?

It would only be simple for the very theoretical and unrealistic
example in the beginning. This is just the tip of the iceberg.

However, the bean-properties example takes the ideas every Java
developer should know of object oriented principals and encapsulation.
It stretches those ideas which we all understand into properties. So
if you understand what an object is then you understand what a
property is: its an object.

You can use standard API implementations of a property or you can
define your own by inheritance or implementing an interface. If that
is not simple to a Java developer then the property keyword would not
be simple either.

<QUOTE PREVIOUSPOST="
&gt; We had several projects break down, where we had to do a SVN revert to
&gt; get back to whichever valid state between the XML and the java file is
&gt; required. It especially happens with 3'rd part &quot;components&quot; and its
&gt; just not optimal having a tool lock lines of code because that is the
&gt; only way it can reason about it. Cut-n-pasting chunks of code to
&gt; improve internal structure is just impossible. In C# not even the
&gt; InitializeComponent (like the Matisse initComponents) is locked, I'm
&gt; guessing they can do that because they do not need a million adaptors
&gt; in place and associated housekeeping metadata. In any event, it feels
&gt; less of a prison with horizontal blue bars. ;)
">

I had matisse break on me too, there are some tricks to force it to
regenerate code using a simple editor and the form XML. However,
normally it just breaks down because you use an external component
that matisse suddenly can't load/manipulate as it could before. Both
problems have nothing to do with the blue code and are just matisse
bugs, it is buggy but not inherently like every Java GUI builder I
worked with.
VB or Delphi never ever broke on me but they were designed for GUI
building from scratch and held the data separately from the language
(no blue sections necessary).

<QUOTE PREVIOUSPOST="
&gt; Could you elaborate on what mess in C# you are referring to?
">

Not a C# expert but callbacks, namespaces etc... the code is way over
the top IMO, matter of taste you obviously want language changes I
don't. No point in arguing that.

<QUOTE PREVIOUSPOST="
&gt; We can
&gt; all agree that C++ went too far, but sweep in front of your own door
&gt; before pointing at the neighbors. Have you tried explaining what the
&gt; final keyword means in Java to newcomers trying to get their head
&gt; around 1 word with 3 semantics? Talk about inconsistancy right there
&gt; in core of the language type system, not to mention API level stuff
&gt; like Comparator vs. Comparable, Iterator vs. Enumerator etc.
">

Java is far from perfect but the fact that stuff is broken doesn't
mean we need to break it further and make it worse.

<QUOTE PREVIOUSPOST="
&gt; Aha, so now C# and C++ is practically unreadable? At least in Ruby you
&gt; only have to read 3 lines of code instead of 10 in Java, and I don't
&gt; think its fair comparing readability between a static and a dynamic
&gt; language, two entirely different beasts. Out of curiousity, is Scala
&gt; also on your unreadable list?
">

Yes its unfair to compare to a scripting language and no I don't like
Scala either.

<QUOTE PREVIOUSPOST="
&gt; There it is again, you really need to come with more substance than
&gt; the statement that its implemented badly in C#. I can only guess that
&gt; you are missing some very specific binding features which again, has
&gt; nothing to do with a published component property.
">

You should read the documentation or examples this has nothing to do
with binding.
However, the fact that I can implement binding more easily,
efficiently and with a more concise syntax than most language changes
is an important fact.

<QUOTE PREVIOUSPOST="
&gt; Perhaps the notion
&gt; of a property and an event simply meens different things to use, but I
&gt; definately do commend you and Remi Forax for the interesting
&gt; workarounds to these problems in Java - while Sun is busy changing
&gt; Nasdaq ticker and other important stuff.
">

Thanks.
</POST>
<POST>
<POSTER> RogerV &lt;rog...@qwest.net&gt; </POSTER>
<POSTDATE> 2007-10-13T14:43:00 </POSTDATE>
I will go so far as to pronounce that any GUI framework initiative
launched at this point in history, and that omits language intrinsic
properties, events, and data binding architecture, is doomed to
ultimate failure.

AND IT MUST BE LANGUAGE INTEGRAL - NOT CONVENTION/SOFTWARE-PATTERN

Because Java doesn't have any of that, the JavaFX iniative will not
get sufficient traction to succeed in the long run. (It will be a
pitiful programming experience compared to the solutions that do have
this.)

Sun is busy tacking on all the things that they think JavaFX needs to
be a competitive solution, yet because they're ultimately relying on
the Java language, they will not have an approach that supports
component-based software development. Also, when Java's language
evolution wheels gradually do turn, such that these features are
finally added to the language, it will be too late to matter.

OOP component-based platforms, such as Flex, will get on to small
devices before JavaFX gets the features it needs to be viable relative
to the alternatives.

Sun has done this to themselves as the need for properties/events has
been apparent ever since the java bean convention was devised. Other
languages in the meantime addressed this while the Sun and the Java
community made excuses as to why it wasn't really needed as part of
the language.

Now JavaFX is rendered non competitive by the Java language not being
able to check off the component development option in the feature set
matrix.

On Oct 11, 12:04 am, Reinier Zwitserloot &lt;reini ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Until now I totally didn't get the hoopla about properties and I was a
&gt; proponent of 3 standardized annotations to solve the whole issue
&gt; (@Getter, @Setter, and @ChangeListener, which would generate standard
&gt; implementations of getFoobar/setFoobar/add-removeFoobarListener - and
&gt; if standard implementations are no good, remove the annotation and
&gt; actually write it the old fashioned way).

&gt; However, now I see where this property stuff is going. I did a
&gt; practice project in Cocoa/ObjC 2 months back and that is very
&gt; component oriented. It's all stuff we can do now but it is indeed a
&gt; completely different way of working.

&gt; I'm convinced. Properties FTW!
">
</POST>
<POST>
<POSTER> &quot;shai.al...@gmail.com&quot; &lt;shai.al...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T14:57:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; I will go so far as to pronounce that any GUI framework initiative
&gt; launched at this point in history, and that omits language intrinsic
&gt; properties, events, and data binding architecture, is doomed to
&gt; ultimate failure.

&gt; AND IT MUST BE LANGUAGE INTEGRAL - NOT CONVENTION/SOFTWARE-PATTERN
">

As long as you give a compelling well informed argument, that covers
your points ;-)

<QUOTE PREVIOUSPOST="
&gt; Sun is busy tacking on all the things that they think JavaFX needs to
&gt; be a competitive solution
">

Java FX will fail because it over promises and under delivers when
talking to Flash developers they normally hate the language but love
the designer oriented tools. So Java FX is a better programming
experience from something that sucks all around (Flash
ActiveScript)... It is nice but its such a minor piece of the puzzle
it that its practically insignificant.

<QUOTE PREVIOUSPOST="
&gt; Sun has done this to themselves as the need for properties/events has
&gt; been apparent ever since the java bean convention was devised. Other
&gt; languages in the meantime addressed this while the Sun and the Java
&gt; community made excuses as to why it wasn't really needed as part of
&gt; the language.
">

If Sun had language based properties or something similar in the
beginning that might have been nice. However, now that we are coming
late to the party we should probably leapfrog the competition rather
than copy them. I suggest you take a deep look at what bean-properties
can do, how it can beat the crap out of RoR:
https://bean-properties.dev.java.net/Rapid_Development.html

And do stuff you just can't do in any other approach to properties.
Java should not copy, it should innovate that is not an excuse.
</POST>
<POST>
<POSTER> RogerV &lt;rog...@qwest.net&gt; </POSTER>
<POSTDATE> 2007-10-13T15:40:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt;On Oct 13, 11:57 am, &quot;shai.al ... @gmail.com&quot; &lt;shai.al ... @gmail.com&gt; wrote:
&gt; Java FX will fail because it over promises and under delivers when
&gt; talking to Flash developers they normally hate the language but love
&gt; the designer oriented tools. So Java FX is a better programming
&gt; experience from something that sucks all around (Flash
&gt; ActiveScript)... It is nice but its such a minor piece of the puzzle
&gt; it that its practically insignificant.
">

I beg to differ on this characterization of the current Adobe
development situation because I see an old canard being repeated here
that is obsolete.

Flex 2 and Flex 3 software development taking place today, using MXML/
ActionScript3, is not the same beast as Flash and ActionScript
development of yore.

Yes, the Flash player is still there in the runtime with it's ability
to play video and animations. However, Flex classes and ActionScript3
are geared toward forms user interface development. Yet even this
predominant orientation of development capitalizes on the underlying
Flash engine in such things as data visualization charts that can
incorporate video hardware and animation effects.

ActionScript3 is strongly typed and the compiler by default compiles
in a mode that enforces static strong type checking. ActionScript3 is
a language that rather closely resembles Java, and as a consequence
Java developers take to it like ducks take to water. Everything in
ActionScript3 is an object, though, so there is not the dichotomy of
primitive types that Java has.

If you think the Flex transformation of the web going on right now is
just the Flash/ActionScript development of the last several years
being carried forward, you are completely misconstruing things. Those
folks are having to learn, what to them, is a new programming model.
The ActionScript they knew was much closer to JavaScript than Java.
Today it is fair to say that ActionScript3 is much closer to Java than
JavaScript. Programming the Flex SDK does not impose the Flash
animation frame-based model - it is just still there to use.

<QUOTE PREVIOUSPOST="
&gt; than copy them. I suggest you take a deep look at what bean-properties
&gt; can do, how it can beat the crap out of RoR: https://bean-properties.dev.java.net/Rapid_Development.html

&gt; And do stuff you just can't do in any other approach to properties.
&gt; Java should not copy, it should innovate that is not an excuse.
">

Hmm, you may have a point - is probably better the Java community does
look for a way to leap forward through some manner of innovation.
</POST>
<POST>
<POSTER> &quot;shai.al...@gmail.com&quot; &lt;shai.al...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-10-13T16:02:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; I beg to differ on this characterization of the current Adobe
&gt; development situation because I see an old canard being repeated here
&gt; that is obsolete.
">

I wasn't talking about Flex, I was talking about ActionScript vs. Java
FX Script. Flex has nothing to do with it, Flex is a RIA not a
language.

<QUOTE PREVIOUSPOST="
&gt; ActionScript3 is strongly typed and the compiler by default compiles
&gt; in a mode that enforces static strong type checking.
">

Not very familiar with version 3 but I don't really see how this is in
any way related to the topic at hand?
I think we can all accept that pretty much every language doing GUI in
recent years has a property abstraction and that Java's &quot;properties&quot;
are the lamest (the get/set convention paired with property change
listeners). I think everyone in this thread agrees Java's existing
properties suck...
About language changes, I'm generally against but that doesn't matter
here either... we are not going to bridge that sort of divide.

My properties approach is to view properties as an object, that does
not negate a language change and in fact works much better with a
language change than all currently public proposals.
I suggest you take a look at the syntax offed by bean-properties, you
will notice it is pretty darn close to anything you can achieve with a
language change. This would essentially mean that a language change
based on top of something similar to bean-properties would be far more
powerful and people need to study and experiment with this (which is
what bean-properties is all about).
</POST>
</TEXT>
</BODY>
</DOC>
