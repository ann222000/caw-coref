<DOC>
<DOCID> eng-NG-31-135588-8596897 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-09-03T06:31:00 </DATETIME>
<BODY>
<HEADLINE>
Symbols - when are they garbage collected?
</HEADLINE>
<TEXT>
<POST>
<POSTER> iu2 &lt;isra...@elbit.co.il&gt; </POSTER>
<POSTDATE> 2007-09-03T06:31:00 </POSTDATE>
Hi,

I use gensyms for macros (like, I believe, many more do). As I
understand it, each time a symbol is read it is interned in the
current package. Well, this means that whenever a macro is executed,
new symbols are interned. When are they garbage collected? Do we have
memory leak due to gensym?

Thanks,
iu2
</POST>
<POST>
<POSTER> Tamas Papp &lt;tkp...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-09-03T06:45:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
iu2 &lt;isra ... @elbit.co.il&gt; writes:
&gt; Hi,

&gt; I use gensyms for macros (like, I believe, many more do). As I
&gt; understand it, each time a symbol is read it is interned in the
&gt; current package. Well, this means that whenever a macro is executed,
&gt; new symbols are interned. When are they garbage collected? Do we have
&gt; memory leak due to gensym?
">

AFAIK symbols generated by gensym are not interned, they are written
with #: before them.  Eg

CL-USER&gt; (gensym)
#:G1906

HTH,

Tamas
</POST>
<POST>
<POSTER> Rainer Joswig &lt;jos...@lisp.de&gt; </POSTER>
<POSTDATE> 2007-09-03T06:54:00 </POSTDATE>
In article &lt;1188815469.438678.266 ... @50g2000hsm.googlegroups.com&gt;,

<QUOTE PREVIOUSPOST="
iu2 &lt;isra ... @elbit.co.il&gt; wrote:
&gt; Hi,

&gt; I use gensyms for macros (like, I believe, many more do). As I
&gt; understand it, each time a symbol is read it is interned in the
&gt; current package. Well, this means that whenever a macro is executed,
&gt; new symbols are interned.
">

Macros are not read when executed.

It means, whenever that macro is expanded, new symbols
are created (but not interned in a package).

Also, gensym creates a symbol which is not interned in a package.

CL-USER&gt; (gensym)
#:G1
CL-USER&gt; (describe *)
Symbol: #:G1
No home package.
Print name: &quot;G1&quot;
Value: #&lt;Unbound&gt;
Function: #&lt;Unbound&gt;
Plist: NIL
; No value
CL-USER&gt; (symbol-package **)
NIL

Additionally, reading such a symbol will not intern it.

CL-USER&gt; (read)
#:foo
#:FOO
CL-USER&gt; (symbol-package *)
NIL

<QUOTE PREVIOUSPOST="
&gt; When are they garbage collected? Do we have
&gt; memory leak due to gensym?

&gt; Thanks,
&gt; iu2
">

--
http://lispm.dyndns.org
</POST>
<POST>
<POSTER> Tim Bradshaw &lt;tfb+goo...@tfeb.org&gt; </POSTER>
<POSTDATE> 2007-09-03T07:37:00 </POSTDATE>
On Sep 3, 11:31 am, iu2 &lt;isra ... @elbit.co.il&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Hi,

&gt; I use gensyms for macros (like, I believe, many more do). As I
&gt; understand it, each time a symbol is read it is interned in the
&gt; current package. Well, this means that whenever a macro is executed,
&gt; new symbols are interned. When are they garbage collected? Do we have
&gt; memory leak due to gensym?
">

A symbol is never &quot;read&quot;.  The reader may create a symbol as the
result of reading some characters from a stream, and it may also
intern that symbol in a package (possibly the current one).

GENSYM creates a symbol from whole cloth, and does not intern it in
any package.  So no package has a reference to the symbol which will
keep it in being (unless you later intern it yourself).  There may be
other references, of course, and the implementation may or may not
actually GC symbols.
</POST>
<POST>
<POSTER> Pascal Bourguignon &lt;p...@informatimago.com&gt; </POSTER>
<POSTDATE> 2007-09-03T08:51:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Tim Bradshaw &lt;tfb+goo ... @tfeb.org&gt; writes:
&gt; On Sep 3, 11:31 am, iu2 &lt;isra ... @elbit.co.il&gt; wrote:
&gt;&gt; Hi,

&gt;&gt; I use gensyms for macros (like, I believe, many more do). As I
&gt;&gt; understand it, each time a symbol is read it is interned in the
&gt;&gt; current package. Well, this means that whenever a macro is executed,
&gt;&gt; new symbols are interned. When are they garbage collected? Do we have
&gt;&gt; memory leak due to gensym?

&gt; A symbol is never &quot;read&quot;.  The reader may create a symbol as the
&gt; result of reading some characters from a stream, and it may also
&gt; intern that symbol in a package (possibly the current one).

&gt; GENSYM creates a symbol from whole cloth, and does not intern it in
&gt; any package.  So no package has a reference to the symbol which will
&gt; keep it in being (unless you later intern it yourself).  There may be
&gt; other references, of course, and the implementation may or may not
&gt; actually GC symbols.
">

You cannot &quot;intern&quot; a symbol, you can only INTERN a symbol name, that
is a string.

But you can &quot;import&quot; a symbol:

C/USER[7]&gt; (import (print  (gensym)))

#:G3777
T
C/USER[8]&gt; (find-symbol &quot;G3777&quot;)
G3777 ;
:INTERNAL
C/USER[9]&gt;

--
__Pascal Bourguignon__ http://www.informatimago.com/

COMPONENT EQUIVALENCY NOTICE: The subatomic particles (electrons,
protons, etc.) comprising this product are exactly the same in every
measurable respect as those used in the products of other
manufacturers, and no claim to the contrary may legitimately be
expressed or implied.
</POST>
<POST>
<POSTER> Tim Bradshaw &lt;tfb+goo...@tfeb.org&gt; </POSTER>
<POSTDATE> 2007-09-03T14:28:00 </POSTDATE>
On Sep 3, 1:51 pm, Pascal Bourguignon &lt;p ... @informatimago.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; You cannot &quot;intern&quot; a symbol, you can only INTERN a symbol name, that
&gt; is a string.
">

I think that what the function IMPORT does to a symbol which has no
home package is often considered to be interning it (certainly it is
by me).  I agree that the CL function INTERN does not do this.  I was,
of course, using the word intern in the former sense (that's why I
said &quot;intern&quot; not &quot;INTERN&quot;.

--tim
</POST>
<POST>
<POSTER> Kent M Pitman &lt;pit...@nhplace.com&gt; </POSTER>
<POSTDATE> 2007-09-03T16:41:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Tim Bradshaw &lt;tfb+goo ... @tfeb.org&gt; writes:
&gt; On Sep 3, 1:51 pm, Pascal Bourguignon &lt;p ... @informatimago.com&gt; wrote:

&gt; &gt; You cannot &quot;intern&quot; a symbol, you can only INTERN a symbol name, that
&gt; &gt; is a string.

&gt; I think that what the function IMPORT does to a symbol which has no
&gt; home package is often considered to be interning it (certainly it is
&gt; by me).  I agree that the CL function INTERN does not do this.  I was,
&gt; of course, using the word intern in the former sense (that's why I
&gt; said &quot;intern&quot; not &quot;INTERN&quot;.
">

I agree with Tim.  INTERN, the function, certainly doesn't take symbols as
arguments, but functions often are more idiosyncratic than their Webster's
English counterparts.  OPEN, the function, is an operation that takes a
string (or pathname) as its primary input, and yet it's commonly informally
referred to as a file operation, not a string or pathname operation.  Again
for the same reason.

But also, from the CLHS glossary:

intern v.t. 1. (a string in a package) to look up the string in the
package, returning either a symbol with that name which was already
accessible in the package or a newly created internal symbol of the
package with that name. 2. Idiom. generally, to observe a protocol
whereby objects which are equivalent or have equivalent names under
some predicate defined by the protocol are mapped to a single
canonical object.

I wrote things like this (and probably this text in specific, though
who can remember for sure) because there are other protocols that are
said to do &quot;interning&quot; besides what one does even just with symbols.

Some people refer to &quot;interned pathnames&quot; on those implementations in
which MAKE-PATHNAME on string= arguments (or sometimes even
string-equal arguments) return the same [under eq] pathname.  The
Symbolics LMFS file system did this, for example, and I doubt it's the
only one.

MACLISP, an earlier dialect, interned small fixnums (the
first few hundred--a somewhat randomly chosen number, curiously, using
up some otherwise accidentally unused data space, so not a fixed
amount, and definitely not the whole fixnum range), mostly for space
efficiency [to use the space usefully and to avoid many pointers to
commonly used numbers in a 256KW fixed address space].  Sometimes
this was called EQ-ification (&quot;Eek-if-uh-CAY-shun&quot;), since it made
such small fixnums EQ.

Part of the reason the glossary exists is not just to modularize the
terminology of the language, but also to normalize the vocabulary
among Lisp practitioners.  I had felt that there was a rich set of
terms often used by Lispers in places that were &quot;well connected&quot; with
the Lisp implementors and that didn't come up directly in Lisp books,
and so never got farther out and got recreated (sometimes badly) in
obscure places.  It was my goal in creating the glossary to just give
people a sense for how the spoken language surrounding the use of Lisp
was done, and that's why I included entries like definition 2
above--to say &quot;if you hear this use of this word, you shouldn't assume
that it's always someone formally trying to wedge the meaning into the
one use that motivated the choice of term as a function name; rather,
the choice of the function name was done by observing that a specific
functional need was filled by this very general concept&quot;.  No one
would ever assume that if we used &quot;open&quot; to open a file that it was no
longer available to open doors or windows or databases or
conversations or network connections or bank accounts, because the
word is widely used.  But for words used less widely, but still with
broader connotation, they needed some additional protection.

- - - -

More Trivia: In MACLISP, which had no packages, symbols that weren't
pointed to could theoretically be GC'd, since they would be recreated
the first time they were later touched, and there was a question about
whether this was worth doing.  It usually wasn't done, just to avoid
thrashing and to avoid thinking you had preallocated enough storage
for an application to be able to read data, only to find out you
hadn't.  But you could called GCTWA (Garbage Collect Truly Worthless
Atoms) to tell the GC it was ok to collect such symbols.
</POST>
</TEXT>
</BODY>
</DOC>
