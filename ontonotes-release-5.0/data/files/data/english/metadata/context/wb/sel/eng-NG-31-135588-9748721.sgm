<DOC>
<DOCID> eng-NG-31-135588-9748721 </DOCID>
<DOCTYPE SOURCE="usenet"> USENET TEXT </DOCTYPE>
<DATETIME> 2007-12-04T07:56:00 </DATETIME>
<BODY>
<HEADLINE>
are relational databases not needed when you use lisp? paul graham did not
</HEADLINE>
<TEXT>
<POST>
<POSTER> gavino &lt;gavcom...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-04T07:56:00 </POSTDATE>
paul graham said he did not use a relational db for viaweb

can one do webapps with lisp and avoid use of a relational db?
</POST>
<POST>
<POSTER> &quot;Andreas Thiele&quot; &lt;nos...@nospam.com&gt; </POSTER>
<POSTDATE> 2007-12-04T08:15:00 </POSTDATE>
&quot;gavino&quot; &lt;gavcom ... @gmail.com&gt; schrieb im Newsbeitrag news:14c3ff11-ea35-45bd-b466-803b07faba84@n20g2000hsh.googlegroups.com ...

<QUOTE PREVIOUSPOST="
&gt; paul graham said he did not use a relational db for viaweb

&gt; can one do webapps with lisp and avoid use of a relational db?
">

Yes, there are some alternatives. Although I use relational DBs, I don't appreciate them
very much. They are not very handy. It's simply marketing for me. The customer is happy
when he has access to the relational DB and can do reporting the same way throughout his
company.

At least there is 'Allegro Cache' a commercial solution by franz. I think the idea behind it
can be found in 'elephant' ( http://common-lisp.net/project/elephant/ ). But there are other
solutions out there. I'm sure people will mention very soon :)

Andreas
</POST>
<POST>
<POSTER> llothar &lt;llot...@web.de&gt; </POSTER>
<POSTDATE> 2007-12-04T09:16:00 </POSTDATE>
On Dec 4, 8:15 pm, &quot;Andreas Thiele&quot; &lt;nos ... @nospam.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Yes, there are some alternatives. Although I use relational DBs, I don't appreciate them
&gt; very much. They are not very handy. It's simply marketing for me.
">

No not marketing, you simply have a solid toolchain from different
vendors and don't bind
yourself to strange solutions. It's important for mission critical.
Especially if the application
grows and you need a realiable and good scaling data store the easiest
and best way are still RDBMS.
</POST>
<POST>
<POSTER> &quot;metaperl.com&quot; &lt;metap...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-04T10:55:00 </POSTDATE>
On Dec 4, 8:15 am, &quot;Andreas Thiele&quot; &lt;nos ... @nospam.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; &quot;gavino&quot; &lt;gavcom ... @gmail.com&gt; schrieb im Newsbeitrag news:14c3ff11-ea35-45bd-b466-803b07faba84@n20g2000hsh.googlegroups.com ...

&gt; &gt; paul graham said he did not use a relational db for viaweb

&gt; &gt; can one do webapps with lisp and avoid use of a relational db?

&gt; At least there is 'Allegro Cache' a commercial solution by franz. I think the idea behind it
&gt; can be found in 'elephant' ( http://common-lisp.net/project/elephant/ ). But there are other
&gt; solutions out there. I'm sure people will mention very soon :)
">

Interestingly, elephant uses a relational-db for it's objectstore:
http://common-lisp.net/project/elephant/doc/Getting-Started.html#Gett...

But I think we always have this question in our heads of how to map
complex programming data structures to the relational data model...
even trees have not one but two different popular ways of getting shoe-
horned into databases - nested sets and adjacency models.

Perhaps we should start all programming projects from a database and
simply build new database operators to accomodate to program specs.
That way we dont have the object-relational mismatch.

Just brainstorming...
</POST>
<POST>
<POSTER> smallpond &lt;smallp...@juno.com&gt; </POSTER>
<POSTDATE> 2007-12-04T11:02:00 </POSTDATE>
On Dec 4, 9:16 am, llothar &lt;llot ... @web.de&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Dec 4, 8:15 pm, &quot;Andreas Thiele&quot; &lt;nos ... @nospam.com&gt; wrote:

&gt; &gt; Yes, there are some alternatives. Although I use relational DBs, I don't appreciate them
&gt; &gt; very much. They are not very handy. It's simply marketing for me.

&gt; No not marketing, you simply have a solid toolchain from different
&gt; vendors and don't bind
&gt; yourself to strange solutions. It's important for mission critical.
&gt; Especially if the application
&gt; grows and you need a realiable and good scaling data store the easiest
&gt; and best way are still RDBMS.
">

Could you please tell me what units &quot;solid&quot;, &quot;strange&quot;, &quot;easiest&quot;,
&quot;important&quot;, &quot;good&quot; and &quot;best&quot; are measured in?  Otherwise, they
are marketing.
Reliability is usually measured in FITS, do you have any numbers?
--S
</POST>
<POST>
<POSTER> Ken Tilton &lt;kennytil...@optonline.net&gt; </POSTER>
<POSTDATE> 2007-12-04T11:08:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
smallpond wrote:
&gt; On Dec 4, 9:16 am, llothar &lt;llot ... @web.de&gt; wrote:

&gt;&gt;On Dec 4, 8:15 pm, &quot;Andreas Thiele&quot; &lt;nos ... @nospam.com&gt; wrote:

&gt;&gt;&gt;Yes, there are some alternatives. Although I use relational DBs, I don't appreciate them
&gt;&gt;&gt;very much. They are not very handy. It's simply marketing for me.

&gt;&gt;No not marketing, you simply have a solid toolchain from different
&gt;&gt;vendors and don't bind
&gt;&gt;yourself to strange solutions. It's important for mission critical.
&gt;&gt;Especially if the application
&gt;&gt;grows and you need a realiable and good scaling data store the easiest
&gt;&gt;and best way are still RDBMS.

&gt; Could you please tell me what units &quot;solid&quot;, &quot;strange&quot;, &quot;easiest&quot;,
&gt; &quot;important&quot;, &quot;good&quot; and &quot;best&quot; are measured in?
">

That would be the fud.

<QUOTE PREVIOUSPOST="
&gt;  Otherwise, they
&gt; are marketing.
">

check.

kt
</POST>
<POST>
<POSTER> Edi Weitz &lt;spamt...@agharta.de&gt; </POSTER>
<POSTDATE> 2007-12-04T11:24:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Tue, 4 Dec 2007 07:55:17 -0800 (PST), &quot;metaperl.com&quot; &lt;metap ... @gmail.com&gt; wrote:
&gt; Interestingly, elephant uses a relational-db for it's objectstore:
&gt; http://common-lisp.net/project/elephant/doc/Getting-Started.html#Gett...
">

The page you're linking to specifically mentions that you can choose
between an SQL database or BerkeleyDB.  And BerkeleyDB is /not/ a
relational DB.  Furthermore, Elephant has what they call a
&quot;multi-store architecture&quot; which means that these are &quot;just&quot;
interchangeable backends.  There's nothing preventing you from writing
your own backend in Lisp, for example.

Edi.

--

Lisp is not dead, it just smells funny.

Real email: (replace (subseq &quot;spamt ... @agharta.de&quot; 5) &quot;edi&quot;)
</POST>
<POST>
<POSTER> Tim Bradshaw &lt;tfb+goo...@tfeb.org&gt; </POSTER>
<POSTDATE> 2007-12-04T12:05:00 </POSTDATE>
On Dec 4, 12:56 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; paul graham said he did not use a relational db for viaweb

&gt; can one do webapps with lisp and avoid use of a relational db?
">

Serious relational databases (not all are) go to very considerable
lengths to ensure data integrity, ACID properties, allow online
backup, replicate transactions to your DR site, scale to large systems
or to clusters of small (or large systems).  If you don't need those
properties or are willing to implement the subset you do need (which,
for some or most of them, is pretty hard), then you probably don't
need the expense or overhead of a relational database.
</POST>
<POST>
<POSTER> Dan Muller &lt;itd98d...@sneakemail.com&gt; </POSTER>
<POSTDATE> 2007-12-04T20:46:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Edi Weitz &lt;spamt ... @agharta.de&gt; writes:
&gt; &quot;metaperl.com&quot; &lt;metap ... @gmail.com&gt; wrote:

&gt;&gt; Interestingly, elephant uses a relational-db for it's objectstore:

&gt; The page you're linking to specifically mentions that you can choose
&gt; between an SQL database or BerkeleyDB.  And BerkeleyDB is /not/ a
&gt; relational DB.
">

Neither is an SQL DBMS a relational DBMS, for that matter. But that's
a topic covered at length in different venues...
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-04T21:19:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Tim Bradshaw wrote:
&gt; On Dec 4, 12:56 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:
&gt;&gt; paul graham said he did not use a relational db for viaweb

&gt;&gt; can one do webapps with lisp and avoid use of a relational db?

&gt; Serious relational databases (not all are) go to very considerable
&gt; lengths to ensure data integrity, ACID properties, allow online
&gt; backup, replicate transactions to your DR site, scale to large systems
&gt; or to clusters of small (or large systems).  If you don't need those
&gt; properties or are willing to implement the subset you do need (which,
&gt; for some or most of them, is pretty hard), then you probably don't
&gt; need the expense or overhead of a relational database.
">

Yup, those are the issues.  I wrote one of the first, perhaps
the first, object-oriented database for Lisp (Statice at
Symbolics), and spent the next fourteen years at a startup
I co-founded (Object Design) doing object-oriented database
systems.  We never did a Lisp version -- not enough market
for it.  We did C++, and then when Java came along, Java.
We did data integrity and ACID properties just fine.
Online backup was not so good, replication to the DR site
was not provided.  The scaling issue is sort of hard to
explain (i.e. it depends what you mean).  We did not
have what Oracle calls &quot;Oracle RAC&quot;, the redundant
highly-available architecture.  We did not have
smarts on the server side, no stored procedures, no
views.  Oracle has third-party vendors with some
really spiffy tools; we were too small to attract
such vendors.  So it's all a complicated question.
The issues for Oracle are different than the
issues for other relational systems like MySQL,
of course.  (Yes, I know that these systems are not
literally &quot;relational&quot; in all theoretical aspects.)

The ITA reservation system is using Oracle RAC.  We
have our own Lisp object-to-relational mapping
subsystem.  It's not easy to make one, particularly
if you want both flexibility, long-term caching,
and other high-performance features.  It takes a lot
of performance work to get it fast.

Had we written in Java, it's likely that we would have
used Hibernate, and had less work to do ourselves.
I don't currently know of an existing available
open-source object-to-relational system for Common
Lisp, at least not one that would meet our needs.
</POST>
<POST>
<POSTER> gavino &lt;gavcom...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-04T21:51:00 </POSTDATE>
On Dec 4, 6:19 pm, Daniel Weinreb &lt;d ... @alum.mit.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; Tim Bradshaw wrote:
&gt; &gt; On Dec 4, 12:56 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:
&gt; &gt;&gt; paul graham said he did not use a relational db for viaweb

&gt; &gt;&gt; can one do webapps with lisp and avoid use of a relational db?

&gt; &gt; Serious relational databases (not all are) go to very considerable
&gt; &gt; lengths to ensure data integrity, ACID properties, allow online
&gt; &gt; backup, replicate transactions to your DR site, scale to large systems
&gt; &gt; or to clusters of small (or large systems).  If you don't need those
&gt; &gt; properties or are willing to implement the subset you do need (which,
&gt; &gt; for some or most of them, is pretty hard), then you probably don't
&gt; &gt; need the expense or overhead of a relational database.

&gt; Yup, those are the issues.  I wrote one of the first, perhaps
&gt; the first, object-oriented database for Lisp (Statice at
&gt; Symbolics), and spent the next fourteen years at a startup
&gt; I co-founded (Object Design) doing object-oriented database
&gt; systems.  We never did a Lisp version -- not enough market
&gt; for it.  We did C++, and then when Java came along, Java.
&gt; We did data integrity and ACID properties just fine.
&gt; Online backup was not so good, replication to the DR site
&gt; was not provided.  The scaling issue is sort of hard to
&gt; explain (i.e. it depends what you mean).  We did not
&gt; have what Oracle calls &quot;Oracle RAC&quot;, the redundant
&gt; highly-available architecture.  We did not have
&gt; smarts on the server side, no stored procedures, no
&gt; views.  Oracle has third-party vendors with some
&gt; really spiffy tools; we were too small to attract
&gt; such vendors.  So it's all a complicated question.
&gt; The issues for Oracle are different than the
&gt; issues for other relational systems like MySQL,
&gt; of course.  (Yes, I know that these systems are not
&gt; literally &quot;relational&quot; in all theoretical aspects.)

&gt; The ITA reservation system is using Oracle RAC.  We
&gt; have our own Lisp object-to-relational mapping
&gt; subsystem.  It's not easy to make one, particularly
&gt; if you want both flexibility, long-term caching,
&gt; and other high-performance features.  It takes a lot
&gt; of performance work to get it fast.

&gt; Had we written in Java, it's likely that we would have
&gt; used Hibernate, and had less work to do ourselves.
&gt; I don't currently know of an existing available
&gt; open-source object-to-relational system for Common
&gt; Lisp, at least not one that would meet our needs.
">

at what pont does the power of the programming language become not
important if you are using a relational db?  I read some great stuff
by P Greenspun about how tcl combines with aolserver and postgresql
are a killer combination.....Does this mean that the programming
language is not where the gain are to be made?
</POST>
<POST>
<POSTER> Ken Tilton &lt;kennytil...@optonline.net&gt; </POSTER>
<POSTDATE> 2007-12-05T00:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Daniel Weinreb wrote:
&gt; Tim Bradshaw wrote:

&gt;&gt; On Dec 4, 12:56 pm, gavino &lt;gavcom ... @gmail.com&gt; wrote:

&gt;&gt;&gt; paul graham said he did not use a relational db for viaweb

&gt;&gt;&gt; can one do webapps with lisp and avoid use of a relational db?

&gt;&gt; Serious relational databases (not all are) go to very considerable
&gt;&gt; lengths to ensure data integrity, ACID properties, allow online
&gt;&gt; backup, replicate transactions to your DR site, scale to large systems
&gt;&gt; or to clusters of small (or large systems).  If you don't need those
&gt;&gt; properties or are willing to implement the subset you do need (which,
&gt;&gt; for some or most of them, is pretty hard), then you probably don't
&gt;&gt; need the expense or overhead of a relational database.

&gt; Yup, those are the issues.  I wrote one of the first, perhaps
&gt; the first, object-oriented database for Lisp (Statice at
&gt; Symbolics), and spent the next fourteen years at a startup
&gt; I co-founded (Object Design) doing object-oriented database
&gt; systems.  We never did a Lisp version -- not enough market
&gt; for it.
">

Ah, so that is how AllegroStore ended up atop ObjectStore. A closet
Lispnik at ODI! :)

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;  We did C++, and then when Java came along, Java.
&gt; We did data integrity and ACID properties just fine.
&gt; Online backup was not so good, replication to the DR site
&gt; was not provided.  The scaling issue is sort of hard to
&gt; explain (i.e. it depends what you mean).  We did not
&gt; have what Oracle calls &quot;Oracle RAC&quot;, the redundant
&gt; highly-available architecture.  We did not have
&gt; smarts on the server side, no stored procedures, no
&gt; views.  Oracle has third-party vendors with some
&gt; really spiffy tools; we were too small to attract
&gt; such vendors.  So it's all a complicated question.
&gt; The issues for Oracle are different than the
&gt; issues for other relational systems like MySQL,
&gt; of course.  (Yes, I know that these systems are not
&gt; literally &quot;relational&quot; in all theoretical aspects.)

&gt; The ITA reservation system is using Oracle RAC.  We
&gt; have our own Lisp object-to-relational mapping
&gt; subsystem.  It's not easy to make one, particularly
&gt; if you want both flexibility, long-term caching,
&gt; and other high-performance features.  It takes a lot
&gt; of performance work to get it fast.

&gt; Had we written in Java, it's likely that we would have
&gt; used Hibernate, and had less work to do ourselves.
&gt; I don't currently know of an existing available
&gt; open-source object-to-relational system for Common
&gt; Lisp, at least not one that would meet our needs.
">

I find myself fascinated by RDF triple stores, and have my eye on
Redland as an open persistent storage solution for Lisp apps. yeah, to
hell with persistent CLOS, gavino talked me out of OO. :)

kzo

--
http://www.theoryyalgebra.com/

&quot;In the morning, hear the Way;
in the evening, die content!&quot;
-- Confucius
</POST>
<POST>
<POSTER> Tim Bradshaw &lt;tfb+goo...@tfeb.org&gt; </POSTER>
<POSTDATE> 2007-12-05T02:56:00 </POSTDATE>
On Dec 5, 2:19 am, Daniel Weinreb &lt;d ... @alum.mit.edu&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; The scaling issue is sort of hard to
&gt; explain (i.e. it depends what you mean).
">

I think I specifically meant scaling well to large shared-memory
systems.  I don't know how well Oracle &amp;co do on very large systems -
where I am now I know we use it on systems with 30-100 cores and
perhaps larger - I don't know how big our largest domains are.  This
means not being able to use the number of processors well, but
nowadays also understanding the memory characteristics well I think.

<QUOTE PREVIOUSPOST="
&gt; We did not
&gt; have what Oracle calls &quot;Oracle RAC&quot;, the redundant
&gt; highly-available architecture.
">

Also this.

--tim
</POST>
<POST>
<POSTER> &quot;Dmitriy Ivanov&quot; &lt;divanov_nospa@m_aha.ru&gt; </POSTER>
<POSTDATE> 2007-12-05T03:25:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&quot;Daniel Weinreb&quot; &lt;d ... @alum.mit.edu&gt; wrote:
">

DW&gt; I don't currently know of an existing available
DW&gt; open-source object-to-relational system for Common
DW&gt; Lisp, at least not one that would meet our needs.

What is your opinion about Xanalys/LispWork CommonSQL? For it, open-source
counterparts do exist, e.g. CLSQL and YSQL. Can it be considered an
object-relational system?
--
Sincerely,
Dmitriy Ivanov
lisp.ystok.ru
</POST>
<POST>
<POSTER> attila.lend...@gmail.com </POSTER>
<POSTDATE> 2007-12-05T05:04:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; Had we written in Java, it's likely that we would have
&gt; used Hibernate, and had less work to do ourselves.
">

the last time i used Hibernate two years ago it was, well, quite
inflexible.

<QUOTE PREVIOUSPOST="
&gt; I don't currently know of an existing available
&gt; open-source object-to-relational system for Common
&gt; Lisp, at least not one that would meet our needs.
">

we have http://common-lisp.net/project/cl-perec/ using
http://common-lisp.net/project/cl-rdbms/ and they are both free.

i don't want to suggest that cl-perec would be useful for something
like what ITA is working on, but i think its design has the place for
all those optimizations, if someone had enough free time.

- attila
</POST>
<POST>
<POSTER> levy &lt;levente.mesza...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-05T05:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
&gt; Had we written in Java, it's likely that we would have
&gt; used Hibernate, and had less work to do ourselves.
&gt; I don't currently know of an existing available
&gt; open-source object-to-relational system for Common
&gt; Lisp, at least not one that would meet our needs.
">

cl-perec is an object-to-realtional mapping tool for Common Lisp and
it is open source.

Two out of three is not that bad...

levy

ps: We are using it in a production system.
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-05T06:54:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ken Tilton wrote:

&gt; Ah, so that is how AllegroStore ended up atop ObjectStore. A closet
&gt; Lispnik at ODI! :)
">

Actually, no, I didn't have anything to do with it.  In fact,
as far as I know, Franz went ahead and invented and implemented
it without particularly interacting with anyone at ODI, although
maybe they talked to some of my co-workers and I didn't hear about it.
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-05T06:57:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Tim Bradshaw wrote:
&gt; On Dec 5, 2:19 am, Daniel Weinreb &lt;d ... @alum.mit.edu&gt; wrote:
&gt;&gt; The scaling issue is sort of hard to
&gt;&gt; explain (i.e. it depends what you mean).

&gt; I think I specifically meant scaling well to large shared-memory
&gt; systems.  I don't know how well Oracle &amp;co do on very large systems -
&gt; where I am now I know we use it on systems with 30-100 cores and
&gt; perhaps larger - I don't know how big our largest domains are.  This
&gt; means not being able to use the number of processors well, but
&gt; nowadays also understanding the memory characteristics well I think.
">

An ObjectStore server is multi-threaded and so presumably
can handle multiple cores, although I don't know how much
load they have been subjected to and whether internal
lock contention starts to come into play.  You'd have to
ask the people who are there now ( www.objectstore.com ).

As for size, you can make pretty big ObjectStore databases.
And then you can make a lot of them and have pointers
between them, and those can be on different servers.
Again, you'd have to ask them for details of how it
works currently; I've been out of that game for years now.

<QUOTE PREVIOUSPOST="
&gt;&gt; We did not
&gt;&gt; have what Oracle calls &quot;Oracle RAC&quot;, the redundant
&gt;&gt; highly-available architecture.

&gt; Also this.

&gt; --tim
">
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-05T06:58:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Dmitriy Ivanov wrote:
&gt; &quot;Daniel Weinreb&quot; &lt;d ... @alum.mit.edu&gt; wrote:

&gt; DW&gt; I don't currently know of an existing available
&gt; DW&gt; open-source object-to-relational system for Common
&gt; DW&gt; Lisp, at least not one that would meet our needs.

&gt; What is your opinion about Xanalys/LispWork CommonSQL? For it, open-source
&gt; counterparts do exist, e.g. CLSQL and YSQL. Can it be considered an
&gt; object-relational system?
&gt; --
&gt; Sincerely,
&gt; Dmitriy Ivanov
&gt; lisp.ystok.ru
">

Sorry, I'm not familiar with those.  Anything with SQL in its
name is almost certainly a relational-type database rather
than an object-oriented-type database, though.
</POST>
<POST>
<POSTER> Duane Rettig &lt;du...@franz.com&gt; </POSTER>
<POSTDATE> 2007-12-05T11:17:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Daniel Weinreb &lt;d ... @alum.mit.edu&gt; writes:
&gt; Ken Tilton wrote:
&gt;&gt; Ah, so that is how AllegroStore ended up atop ObjectStore. A closet
&gt;&gt; Lispnik at ODI! :)

&gt; Actually, no, I didn't have anything to do with it.  In fact,
&gt; as far as I know, Franz went ahead and invented and implemented
&gt; it without particularly interacting with anyone at ODI, although
&gt; maybe they talked to some of my co-workers and I didn't hear about it.
">

We did negotiate with ODI for cooperation in handling signals.  Both
OS and Allegro CL uses SIGSEGV, as it happens, and since signals are a
global resource, it makes for poor multiple-usage.  ODI didn't want to
give away their secrets, but we knew that instantiation of objects was
done by explicitly forcing a SEGV and handling it, so we negotiated
with them an interface whereby they would write their SEGV handler to
save off any current handlers and invoke them if/when it determined
that the SEGV wasn't an object instantiation.  Thus, OS could filter
out the SEGVs it knew about, and Allegro CL could handle the rest.

--
Duane Rettig    du ... @franz.com    Franz Inc. http://www.franz.com/
555 12th St., Suite 1450 http://www.555citycenter.com/
Oakland, Ca. 94607        Phone: (510) 452-2000; Fax: (510) 452-0182
</POST>
<POST>
<POSTER> Maciej Katafiasz &lt;mathr...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-05T14:09:00 </POSTDATE>
Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

<QUOTE PREVIOUSPOST="
&gt; [...] but we knew that instantiation of objects was done by explicitly
&gt; forcing a SEGV and handling it [...]
">

Now, it's hard to reach an informed conclusion from such a short passage,
but instantiation through SEGV sounds so outlandish that I just have to
ask for details, if there are any you can share without breaching any
contracts.

Cheers,
Maciej
</POST>
<POST>
<POSTER> Duane Rettig &lt;du...@franz.com&gt; </POSTER>
<POSTDATE> 2007-12-05T18:05:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:
&gt; Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

&gt;&gt; [...] but we knew that instantiation of objects was done by explicitly
&gt;&gt; forcing a SEGV and handling it [...]

&gt; Now, it's hard to reach an informed conclusion from such a short passage,
&gt; but instantiation through SEGV sounds so outlandish that I just have to
&gt; ask for details, if there are any you can share without breaching any
&gt; contracts.
">

Why outlandish?

I can't share facts with you because I don't know many, other than
what my fellow developer told me.  I can only guess, though, at both
reasons for ODI's design and also reasons for your horror.  I assume
that you can address the latter, and perhaps Daniel Weinreb would
consider sharing some of the former.  But to take some guesses, I
presume that you are either reacting against the very thought of using
traditionally error-based programming to handle normal programming
situations, or against the long cycle times that would be present in
handling user level traps in a unix environment.  Recall, though, that
not too many years ago 2 Mb was considered to be a huge program, and a
file-based database application that could avoid structural program
change from the first instantiation of an object to the second was
likely to be very efficient for those objects already in memory.
As for the timing issue, when you are dealing with a single hit of
several hundred to a thousand or two cycles for a signal handler to be
dispatched, that cycle count gets swamped by the time it takes to go
out to the disk to get the data, especially if it is randomly
addressed.

As for the possibility that your reaction is to the very thought of
using signals to effect programming - if so, I've seen this kind of
reaction before - my theory is that such aversion is based on the
tendency of error and exception systems to be afterthoughts, and thus
either not complete or not well-tested.  I've even had a conversation
with a person in comp.arch who insisted that I could never get
recoverable semantics for stack-overflows.  And yet, on operating
systems that support soft overflows, we are indeed able to fully
recover to the point where programmers can continue and complete their
projects (rather than having to consider the environment to be corrupt
after a stack overflow).

It is likely that your guess as to how things were set up in OS are
correct - it seemed like a straightforward situation, at least from my
persepective of supporting the fellow-developer's low-level
requirements when he did his build of AllegroStore.  Perhaps you can
explain why your reaction is so strong...

--
Duane Rettig    du ... @franz.com    Franz Inc. http://www.franz.com/
555 12th St., Suite 1450 http://www.555citycenter.com/
Oakland, Ca. 94607        Phone: (510) 452-2000; Fax: (510) 452-0182
</POST>
<POST>
<POSTER> &quot;Matthew D. Swank&quot; &lt;akopa.gmane.pos...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-05T21:27:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:
&gt; I find myself fascinated by RDF triple stores, and have my eye on
&gt; Redland as an open persistent storage solution for Lisp apps. yeah, to
&gt; hell with persistent CLOS, gavino talked me out of OO. :)
">

What is your interest in RDF?

Matt
--
&quot;You do not really understand something unless you
can explain it to your grandmother.&quot; -- Albert Einstein.
</POST>
<POST>
<POSTER> Ken Tilton &lt;kennytil...@optonline.net&gt; </POSTER>
<POSTDATE> 2007-12-05T21:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Matthew D. Swank wrote:
&gt; On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt;&gt;I find myself fascinated by RDF triple stores, and have my eye on
&gt;&gt;Redland as an open persistent storage solution for Lisp apps. yeah, to
&gt;&gt;hell with persistent CLOS, gavino talked me out of OO. :)

&gt; What is your interest in RDF?
">

I think triples are a better way to represent data. Triples are to
objects what objects are to tables and rows, and what dynamic typing is
to static. Triples have the power of natural language without the
ambiguity. In brief, triples are the Lisp Way of data. I think even PG
and RPG would like them.

I hope Redland is good, it would be cool having persistence for free.

kzo

--
http://www.theoryyalgebra.com/

&quot;In the morning, hear the Way;
in the evening, die content!&quot;
-- Confucius
</POST>
<POST>
<POSTER> Kent M Pitman &lt;pit...@nhplace.com&gt; </POSTER>
<POSTDATE> 2007-12-05T23:18:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:
&gt; Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

&gt; &gt; [...] but we knew that instantiation of objects was done by explicitly
&gt; &gt; forcing a SEGV and handling it [...]

&gt; Now, it's hard to reach an informed conclusion from such a short passage,
&gt; but instantiation through SEGV sounds so outlandish that I just have to
&gt; ask for details, if there are any you can share without breaching any
&gt; contracts.
">

MACLISP used to manage WITHOUT-INTERRUPTS in a similarly bizarre way.
It wanted to bind interrupts, but there was no way to bind anything
but a variable.  So it had a variable called
+INTERNAL-WITHOUT-INTERRUPTS that had its value cell on a pure page
[that's what we called read-only memory].  If you bound it, it would
signal a pure page error and Lisp would decipher the stack frame to
figure out whether to set interrupts on or off. The value of that &quot;variable&quot;
never changed, so you had to read it by reading a completely alternate
facility, (STATUS NOINTERRUPT).  It was all kind of weird and indirect.
</POST>
<POST>
<POSTER> Frank Buss &lt;f...@frank-buss.de&gt; </POSTER>
<POSTDATE> 2007-12-06T03:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Duane Rettig wrote:
&gt; Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:

&gt;&gt; Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

&gt;&gt;&gt; [...] but we knew that instantiation of objects was done by explicitly
&gt;&gt;&gt; forcing a SEGV and handling it [...]

&gt;&gt; Now, it's hard to reach an informed conclusion from such a short passage,
&gt;&gt; but instantiation through SEGV sounds so outlandish that I just have to
&gt;&gt; ask for details, if there are any you can share without breaching any
&gt;&gt; contracts.

&gt; Why outlandish?
">

At least for me it sounds more complicated than necessary. I assume the
part of the database which handles the SEGV is part of the application
process, so you don't mean sending a SEGV to another process, but to the
same process, e.g. by accessing invalid memory. Then the SEGV handler has
to determine what it means. What is the advantage compared to a simple
function call?

--
Frank Buss, f ... @frank-buss.de
http://www.frank-buss.de , http://www.it4-systems.de
</POST>
<POST>
<POSTER> Maciej Katafiasz &lt;mathr...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-06T04:22:00 </POSTDATE>
Den Wed, 05 Dec 2007 15:05:55 -0800 skrev Duane Rettig:

<QUOTE PREVIOUSPOST="
&gt;&gt; Now, it's hard to reach an informed conclusion from such a short
&gt;&gt; passage, but instantiation through SEGV sounds so outlandish that I
&gt;&gt; just have to ask for details, if there are any you can share without
&gt;&gt; breaching any contracts.

&gt; Why outlandish?
">

Perhaps outlandish was a wrong word, but it certainly seemed like an
unusual take on object instantiation. And my reaction was a combination
of several factors, see below.

<QUOTE PREVIOUSPOST="
&gt; I can't share facts with you because I don't know many, other than what
&gt; my fellow developer told me.  I can only guess, though, at both reasons
&gt; for ODI's design and also reasons for your horror.  I assume that you
&gt; can address the latter, and perhaps Daniel Weinreb would consider
&gt; sharing some of the former.  But to take some guesses, I presume that
&gt; you are either reacting against the very thought of using traditionally
&gt; error-based programming to handle normal programming situations, or
&gt; against the long cycle times that would be present in handling user
&gt; level traps in a unix environment.  Recall, though, that not too many
&gt; years ago 2 Mb was considered to be a huge program, and a file-based
&gt; database application that could avoid structural program change from the
&gt; first instantiation of an object to the second was likely to be very
&gt; efficient for those objects already in memory.
">

I guess I was thinking about a different meaning of &quot;object
instantiation&quot;. Page fault-like handling is indeed less surprising.
However, my main objection was that signals are so brittle and offer so
little in the way of a protocol (there's no way to attach any data to a
signal, which makes them inherently a global resource, which is very
yucky). I appreciate the ability to present a uniform interface to the
outside code, I'm unsure, however, how signals help compared to ordinary
function calls. Unless you posses the ability to do true page fault
handling (ie. can rewrite memory references), it seems to me like just a
very indirect way of doing funcalls.

<QUOTE PREVIOUSPOST="
&gt; As for the timing issue,
&gt; when you are dealing with a single hit of several hundred to a thousand
&gt; or two cycles for a signal handler to be dispatched, that cycle count
&gt; gets swamped by the time it takes to go out to the disk to get the data,
&gt; especially if it is randomly addressed.
">

Good point.

<QUOTE PREVIOUSPOST="
&gt; As for the possibility that your reaction is to the very thought of
&gt; using signals to effect programming - if so, I've seen this kind of
&gt; reaction before - my theory is that such aversion is based on the
&gt; tendency of error and exception systems to be afterthoughts, and thus
&gt; either not complete or not well-tested.
">

I agree that robust error handling can substantially change the notion
of what is a recoverable situation, however, Unix signals aren't exactly
a paragon of expressible, well-integrated error handling mechanism
design :).

Cheers,
Maciej
</POST>
<POST>
<POSTER> Duane Rettig &lt;du...@franz.com&gt; </POSTER>
<POSTDATE> 2007-12-06T05:15:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Frank Buss &lt;f ... @frank-buss.de&gt; writes:
&gt; Duane Rettig wrote:

&gt;&gt; Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:

&gt;&gt;&gt; Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

&gt;&gt;&gt;&gt; [...] but we knew that instantiation of objects was done by explicitly
&gt;&gt;&gt;&gt; forcing a SEGV and handling it [...]

&gt;&gt;&gt; Now, it's hard to reach an informed conclusion from such a short passage,
&gt;&gt;&gt; but instantiation through SEGV sounds so outlandish that I just have to
&gt;&gt;&gt; ask for details, if there are any you can share without breaching any
&gt;&gt;&gt; contracts.

&gt;&gt; Why outlandish?

&gt; At least for me it sounds more complicated than necessary. I assume the
&gt; part of the database which handles the SEGV is part of the application
&gt; process, so you don't mean sending a SEGV to another process, but to the
&gt; same process, e.g. by accessing invalid memory. Then the SEGV handler has
&gt; to determine what it means. What is the advantage compared to a simple
&gt; function call?
">

Space, as I understand it, both code and data.  The code accesses the
&quot;bogus&quot; (i.e. unloaded) datum as if it were a real object and gets the
segv, and the segv handler loads it in and ensures that it is in the
right register for the code to get at.  The next time it is accessed,
the same code (i.e. without having to take a different route) accesses
the loaded data in the same simple way (i.e. without having to be
concerned about the case where the datum is unloaded) and gets the
datum because it is now loaded.

It's actually simpler than usual - there are fewer decision paths in
the runtime code - all of the decisions and bending over backward is
done in the trap handler, which can arrange for just about any context
to be presented back to the user code.

I must repeat: I don't know the ObjectStore code personally, but it
was described to me, and all of my encounters with it tend to be
consistent with my own experience in programming-by-trap.  We actually
do a lot of it in Allegro CL itself, although we don't use traps for
functionality that is likely to occur very often.  Instead we trap on
things like unbound-variable errors for symbol-value accesses, so that
you have restarts that include setting the symbol's value and/or
continuing with the value at the point of the trap.  A programmatic
interface to such global variable accesses would be much more bulky,
since the locus of code would have to temporarily jump out of the code
to an error handler, and then find its way back into the same code
path.  With a trap, the handler has the complete state of the running
lisp and can come back to that point after handling the error.  We use
the same technique on our instruction-level breakpoint stepper, which
I describe (along with some of the concepts of user trap handling) in
ftp://ftp.franz.com/pub/duane/break.ps

--
Duane Rettig    du ... @franz.com    Franz Inc. http://www.franz.com/
555 12th St., Suite 1450 http://www.555citycenter.com/
Oakland, Ca. 94607        Phone: (510) 452-2000; Fax: (510) 452-0182
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-06T07:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Duane Rettig wrote:
&gt; Frank Buss &lt;f ... @frank-buss.de&gt; writes:

&gt;&gt; Duane Rettig wrote:

&gt;&gt;&gt; Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:

&gt;&gt;&gt;&gt; Den Wed, 05 Dec 2007 08:17:43 -0800 skrev Duane Rettig:

&gt;&gt;&gt;&gt;&gt; [...] but we knew that instantiation of objects was done by explicitly
&gt;&gt;&gt;&gt;&gt; forcing a SEGV and handling it [...]
&gt;&gt;&gt;&gt; Now, it's hard to reach an informed conclusion from such a short passage,
&gt;&gt;&gt;&gt; but instantiation through SEGV sounds so outlandish that I just have to
&gt;&gt;&gt;&gt; ask for details, if there are any you can share without breaching any
&gt;&gt;&gt;&gt; contracts.
&gt;&gt;&gt; Why outlandish?
&gt;&gt; At least for me it sounds more complicated than necessary. I assume the
&gt;&gt; part of the database which handles the SEGV is part of the application
&gt;&gt; process, so you don't mean sending a SEGV to another process, but to the
&gt;&gt; same process, e.g. by accessing invalid memory. Then the SEGV handler has
&gt;&gt; to determine what it means. What is the advantage compared to a simple
&gt;&gt; function call?

&gt; Space, as I understand it, both code and data.  The code accesses the
&gt; &quot;bogus&quot; (i.e. unloaded) datum as if it were a real object and gets the
&gt; segv, and the segv handler loads it in and ensures that it is in the
&gt; right register for the code to get at.  The next time it is accessed,
&gt; the same code (i.e. without having to take a different route) accesses
&gt; the loaded data in the same simple way (i.e. without having to be
&gt; concerned about the case where the datum is unloaded) and gets the
&gt; datum because it is now loaded.
">

Yeah, that's the basic idea.  SIGSEGV is being used to create
the equivalent of a demand-paged virtual memory, within the
user level (as opposed to the kernel level).  ObjectStore
assigns your database to virtual address space, and then
uses mmap/mprotect/SIGSEGV to keep track of which pages
are read, written, or need to be brought in from the server.
This is all explained in our CACM paper.  Google for
&quot;Lamb Orenstein Weinreb&quot;.  Unfortunately it is copyright
by the ACM so you need to have access to the ACM Digital
Library.  None of it is secret, though.

<QUOTE PREVIOUSPOST="
&gt; It's actually simpler than usual - there are fewer decision paths in
&gt; the runtime code - all of the decisions and bending over backward is
&gt; done in the trap handler, which can arrange for just about any context
&gt; to be presented back to the user code.

&gt; I must repeat: I don't know the ObjectStore code personally,
">

I personally wrote all the stuff being described above.  If
you have any questions, I'll be happy to answer them.

but it

<QUOTE PREVIOUSPOST="
&gt; was described to me, and all of my encounters with it tend to be
&gt; consistent with my own experience in programming-by-trap.  We actually
&gt; do a lot of it in Allegro CL itself, although we don't use traps for
&gt; functionality that is likely to occur very often.  Instead we trap on
&gt; things like unbound-variable errors for symbol-value accesses, so that
&gt; you have restarts that include setting the symbol's value and/or
&gt; continuing with the value at the point of the trap.  A programmatic
&gt; interface to such global variable accesses would be much more bulky,
&gt; since the locus of code would have to temporarily jump out of the code
&gt; to an error handler, and then find its way back into the same code
&gt; path.  With a trap, the handler has the complete state of the running
&gt; lisp and can come back to that point after handling the error.  We use
&gt; the same technique on our instruction-level breakpoint stepper, which
&gt; I describe (along with some of the concepts of user trap handling) in
&gt; ftp://ftp.franz.com/pub/duane/break.ps
">

Cool.  I actually never learned about AllegroStore.

Sorry if you had trouble interacting with ODI.  I don't
know who you talked to but I apologize on their behalf.
We tried hard to be cooperative with anyone building
something on top of ObjectStore, in general.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="

">
</POST>
<POST>
<POSTER> Richard M Kreuter &lt;kreu...@progn.net&gt; </POSTER>
<POSTDATE> 2007-12-06T09:38:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Daniel Weinreb &lt;d ... @alum.mit.edu&gt; writes:
&gt; SIGSEGV is being used to create the equivalent of a demand-paged
&gt; virtual memory, within the user level (as opposed to the kernel
&gt; level).  ObjectStore assigns your database to virtual address space,
&gt; and then uses mmap/mprotect/SIGSEGV to keep track of which pages are
&gt; read, written, or need to be brought in from the server.  This is
&gt; all explained in our CACM paper.  Google for &quot;Lamb Orenstein
&gt; Weinreb&quot;.  Unfortunately it is copyright by the ACM so you need to
&gt; have access to the ACM Digital Library.  None of it is secret,
&gt; though.
">

There's a publically available paper that cites your paper and calls
their technique similar titled &quot;Pointer Swizzling at Page Fault Time&quot;
by Paul R. Wilson and Sheetal V. Kakkad, linked here:

http://citeseer.ist.psu.edu/92467.html
</POST>
<POST>
<POSTER> Duane Rettig &lt;du...@franz.com&gt; </POSTER>
<POSTDATE> 2007-12-06T11:04:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Daniel Weinreb &lt;d ... @alum.mit.edu&gt; writes:
&gt; Cool.  I actually never learned about AllegroStore.
">

I never learned AllegroStore either, at least from the user point of
view - I was always busy in the bowels of the implementation (mostly
where they clashed).

<QUOTE PREVIOUSPOST="
&gt; Sorry if you had trouble interacting with ODI.  I don't
&gt; know who you talked to but I apologize on their behalf.
&gt; We tried hard to be cooperative with anyone building
&gt; something on top of ObjectStore, in general.
">

I don't think we had any trouble with ODI.  The major problems we had
to solve were technical ones, especially dealing with the fact that we
both used the same signal for different purposes.

--
Duane Rettig    du ... @franz.com    Franz Inc. http://www.franz.com/
555 12th St., Suite 1450 http://www.555citycenter.com/
Oakland, Ca. 94607        Phone: (510) 452-2000; Fax: (510) 452-0182
</POST>
<POST>
<POSTER> Duane Rettig &lt;du...@franz.com&gt; </POSTER>
<POSTDATE> 2007-12-06T11:43:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Maciej Katafiasz &lt;mathr ... @gmail.com&gt; writes:
&gt; Den Wed, 05 Dec 2007 15:05:55 -0800 skrev Duane Rettig:

&gt;&gt;&gt; Now, it's hard to reach an informed conclusion from such a short
&gt;&gt;&gt; passage, but instantiation through SEGV sounds so outlandish that I
&gt;&gt;&gt; just have to ask for details, if there are any you can share without
&gt;&gt;&gt; breaching any contracts.

&gt;&gt; Why outlandish?

&gt; Perhaps outlandish was a wrong word, but it certainly seemed like an
&gt; unusual take on object instantiation. And my reaction was a combination
&gt; of several factors, see below.
&gt; I guess I was thinking about a different meaning of &quot;object
&gt; instantiation&quot;. Page fault-like handling is indeed less surprising.
&gt; However, my main objection was that signals are so brittle and offer so
&gt; little in the way of a protocol
">

Agreed so far

<QUOTE PREVIOUSPOST="
&gt;  (there's no way to attach any data to a signal,
">

Ah, but that's the beauty of thinking inside the box [most people
think that thinkiong outside the box is the epitmy of creativity, but
consciously thinking of creative solutions with a tight set of
constraints is one of the most rewarding of programming experiences].
You'd be surprised what kind of data you can attach to a signal.  The
handler itself gives you a whole context, which includes the state of
the registers at the time of the signal.  And one of these registers
is the program counter, which, if you are willing to do a bit of
instruction decoding, gives you a wealth of information about what the
code was trying to do at the time.  We use this extensively in Allegro
CL, for things like taking the car of a non-listp object (this is
especially beautiful on a machine which traps on mis-aligned accesses -
the CAR and CDR operations are exactly one instruction long, and yet
the handler is able to figure out what the object was that you were
trying to access).

which makes them inherently a global resource,

Also agreed,

<QUOTE PREVIOUSPOST="
&gt; which is very yucky).
">

This I disagree with, on two counts:

1. It is only disgusting/repugnant/disagreeable if you are not
willing to work within the constraints that are set by their
operation.

2. Any yuckiness should not stem from their being global resources.
How do you deal with the possibility of multiple definitions of the
same symbol in CL?  You inject rules: naming conventions, protocols
for introducing packages, rules about the usage of public packages
(and most implementations provide package locks to support such
rules).  Have you ever described the fact that you could overwrite
your function definition as &quot;yucky&quot;?  I doubt it.

I appreciate the ability to present a uniform interface to the

<QUOTE PREVIOUSPOST="
&gt; outside code, I'm unsure, however, how signals help compared to ordinary
&gt; function calls.
">

As is the case when deciding whether to use function calls or macros,
using signals is a choice that must be made carefully and with
purpose.

<QUOTE PREVIOUSPOST="
&gt; Unless you posses the ability to do true page fault
&gt; handling (ie. can rewrite memory references), it seems to me like just a
&gt; very indirect way of doing funcalls.
">

Is this a Turing argument? Of course it can be done differently; the
main point of difference is in the efficiency of the design along the
axes of optimization you consider important.

<QUOTE PREVIOUSPOST="
&gt;&gt; As for the possibility that your reaction is to the very thought of
&gt;&gt; using signals to effect programming - if so, I've seen this kind of
&gt;&gt; reaction before - my theory is that such aversion is based on the
&gt;&gt; tendency of error and exception systems to be afterthoughts, and thus
&gt;&gt; either not complete or not well-tested.

&gt; I agree that robust error handling can substantially change the notion
&gt; of what is a recoverable situation, however, Unix signals aren't exactly
&gt; a paragon of expressible, well-integrated error handling mechanism
&gt; design :).
">

Agreed here, also.  Our biggest problems with signals is that they are
all different.  They even manage sometimes to change in subtle ways
from one operating system version to the next.  However, similar
things could be said about hardware or operating systems themselves.
I have no problem dealing with them on this basis, when categorizing
signals as a part of the uniqueness that comes with a particular
architecture/operating-system pair.

--
Duane Rettig    du ... @franz.com    Franz Inc. http://www.franz.com/
555 12th St., Suite 1450 http://www.555citycenter.com/
Oakland, Ca. 94607        Phone: (510) 452-2000; Fax: (510) 452-0182
</POST>
<POST>
<POSTER> Maciej Katafiasz &lt;mathr...@gmail.com&gt; </POSTER>
<POSTDATE> 2007-12-06T14:21:00 </POSTDATE>
Den Thu, 06 Dec 2007 08:43:29 -0800 skrev Duane Rettig:

<QUOTE PREVIOUSPOST="
&gt;&gt;  (there's no way to attach any data to a signal,

&gt; Ah, but that's the beauty of thinking inside the box [most people think
&gt; that thinkiong outside the box is the epitmy of creativity, but
&gt; consciously thinking of creative solutions with a tight set of
&gt; constraints is one of the most rewarding of programming experiences].
&gt; You'd be surprised what kind of data you can attach to a signal.  The
&gt; handler itself gives you a whole context, which includes the state of
&gt; the registers at the time of the signal.  And one of these registers is
&gt; the program counter, which, if you are willing to do a bit of
&gt; instruction decoding, gives you a wealth of information about what the
&gt; code was trying to do at the time.  We use this extensively in Allegro
&gt; CL, for things like taking the car of a non-listp object (this is
&gt; especially beautiful on a machine which traps on mis-aligned accesses -
&gt; the CAR and CDR operations are exactly one instruction long, and yet the
&gt; handler is able to figure out what the object was that you were trying
&gt; to access).
">

Ah, interesting. I never really tried pushing the boundaries of what you
can do with signals, so I wasn't aware you can localise the signalling
site so precisely. This is indeed a very nifty hack.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;  which makes them inherently a global resource,

&gt; Also agreed,

&gt;&gt; which is very yucky).

&gt; This I disagree with, on two counts:

&gt;  1. It is only disgusting/repugnant/disagreeable if you are not
&gt; willing to work within the constraints that are set by their operation.

&gt;  2. Any yuckiness should not stem from their being global resources.
&gt; How do you deal with the possibility of multiple definitions of the same
&gt; symbol in CL?  You inject rules: naming conventions, protocols for
&gt; introducing packages, rules about the usage of public packages (and most
&gt; implementations provide package locks to support such rules).  Have you
&gt; ever described the fact that you could overwrite your function
&gt; definition as &quot;yucky&quot;?  I doubt it.
">

It's only yucky when you aren't able to effectively locate the
originating site, which, as you explain, is perfectly doable, and thus
reverts signal handling back to non-yucky granularity.

<QUOTE PREVIOUSPOST="
&gt;  I appreciate the ability to present a uniform interface to the
&gt;&gt; outside code, I'm unsure, however, how signals help compared to
&gt;&gt; ordinary function calls.

&gt; As is the case when deciding whether to use function calls or macros,
&gt; using signals is a choice that must be made carefully and with purpose.
">

Yes. But the real (ie. the one I had in mind when asking this) answer to
this question you already gave above :). I'll skip the rest of no-longer-
valid points.

<QUOTE PREVIOUSPOST="
&gt;&gt; I agree that robust error handling can substantially change the notion
&gt;&gt; of what is a recoverable situation, however, Unix signals aren't
&gt;&gt; exactly a paragon of expressible, well-integrated error handling
&gt;&gt; mechanism design :).
">

Of course, I meant *expressive* here.

<QUOTE PREVIOUSPOST="
&gt; Agreed here, also.  Our biggest problems with signals is that they are
&gt; all different.  They even manage sometimes to change in subtle ways from
&gt; one operating system version to the next.  However, similar things could
&gt; be said about hardware or operating systems themselves. I have no
&gt; problem dealing with them on this basis, when categorizing signals as a
&gt; part of the uniqueness that comes with a particular
&gt; architecture/operating-system pair.
">

That is also one of the reasons I don't jump to signals as the first
solution of a problem, they have almost no defined semantics. About the
only stable thing you can say about them is that they exist, and that you
can't handle KILL and STOP/CONT. Everything else, from their meaning, to
semantics of signalling yourself, to semantics of what happens in multi-
threaded scenarios, is pretty much a big cloud of unspecifiedness.

Cheers,
Maciej
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-06T20:42:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Maciej Katafiasz wrote:
&gt; Den Wed, 05 Dec 2007 15:05:55 -0800 skrev Duane Rettig:

&gt;&gt;&gt; Now, it's hard to reach an informed conclusion from such a short
&gt;&gt;&gt; passage, but instantiation through SEGV sounds so outlandish that I
&gt;&gt;&gt; just have to ask for details, if there are any you can share without
&gt;&gt;&gt; breaching any contracts.
&gt;&gt; Why outlandish?

&gt; Perhaps outlandish was a wrong word, but it certainly seemed like an
&gt; unusual take on object instantiation. And my reaction was a combination
&gt; of several factors, see below.
">

It's not actually object instantiation.  Object instantiation
was done by an overloaded &quot;operator new&quot;, where the parameter
said what database or cluster to allocate the object in.
This might or might not do a SIGSEGV depending only on whether
it happened to touch a page that was not already writable.

<QUOTE PREVIOUSPOST="
&gt;&gt; I can't share facts with you because I don't know many, other than what
&gt;&gt; my fellow developer told me.  I can only guess, though, at both reasons
&gt;&gt; for ODI's design and also reasons for your horror.  I assume that you
&gt;&gt; can address the latter, and perhaps Daniel Weinreb would consider
&gt;&gt; sharing some of the former.  But to take some guesses, I presume that
&gt;&gt; you are either reacting against the very thought of using traditionally
&gt;&gt; error-based programming to handle normal programming situations, or
&gt;&gt; against the long cycle times that would be present in handling user
&gt;&gt; level traps in a unix environment.  Recall, though, that not too many
&gt;&gt; years ago 2 Mb was considered to be a huge program, and a file-based
&gt;&gt; database application that could avoid structural program change from the
&gt;&gt; first instantiation of an object to the second was likely to be very
&gt;&gt; efficient for those objects already in memory.

&gt; I guess I was thinking about a different meaning of &quot;object
&gt; instantiation&quot;. Page fault-like handling is indeed less surprising.
&gt; However, my main objection was that signals are so brittle and offer so
&gt; little in the way of a protocol (there's no way to attach any data to a
&gt; signal, which makes them inherently a global resource, which is very
&gt; yucky). I appreciate the ability to present a uniform interface to the
&gt; outside code, I'm unsure, however, how signals help compared to ordinary
&gt; function calls. Unless you posses the ability to do true page fault
&gt; handling (ie. can rewrite memory references), it seems to me like just a
&gt; very indirect way of doing funcalls.
">

The SIGSEGV was a lot like a page fault. It told us that the
program was trying to read or write a certain page.  We didn't
need to attach any data.  The fact of the SIGSEGV was all
we needed.

<QUOTE PREVIOUSPOST="
&gt;&gt; As for the timing issue,
&gt;&gt; when you are dealing with a single hit of several hundred to a thousand
&gt;&gt; or two cycles for a signal handler to be dispatched, that cycle count
&gt;&gt; gets swamped by the time it takes to go out to the disk to get the data,
&gt;&gt; especially if it is randomly addressed.

&gt; Good point.
">

Yes, although often the data would already be in the
local cache so that you didn't pay that price of going out
to the server.

<QUOTE PREVIOUSPOST="
- Hide quoted text - - Show quoted text -
">

<QUOTE PREVIOUSPOST="
&gt;&gt; As for the possibility that your reaction is to the very thought of
&gt;&gt; using signals to effect programming - if so, I've seen this kind of
&gt;&gt; reaction before - my theory is that such aversion is based on the
&gt;&gt; tendency of error and exception systems to be afterthoughts, and thus
&gt;&gt; either not complete or not well-tested.

&gt; I agree that robust error handling can substantially change the notion
&gt; of what is a recoverable situation, however, Unix signals aren't exactly
&gt; a paragon of expressible, well-integrated error handling mechanism
&gt; design :).

&gt; Cheers,
&gt; Maciej
">
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-06T20:50:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Maciej Katafiasz wrote:
&gt; That is also one of the reasons I don't jump to signals as the first
&gt; solution of a problem, they have almost no defined semantics. About the
&gt; only stable thing you can say about them is that they exist, and that you
&gt; can't handle KILL and STOP/CONT. Everything else, from their meaning, to
&gt; semantics of signalling yourself, to semantics of what happens in multi-
&gt; threaded scenarios, is pretty much a big cloud of unspecifiedness.
">

Not SIGSEGV.  A confusing things about Unix/Posix/Linux is that
there are two completely different things, both modelled as
&quot;signals&quot;.  There are asynchronous ones (like killing a process)
and there are synchronous ones like SIGSEGV.  The semantics of
SIGSEGV is 100% completely clear.
</POST>
<POST>
<POSTER> r...@rpw3.org (Rob Warnock) </POSTER>
<POSTDATE> 2007-12-06T23:45:00 </POSTDATE>
Daniel Weinreb  &lt;d ... @alum.mit.edu&gt; wrote:
+---------------

<QUOTE PREVIOUSPOST="
| Maciej Katafiasz wrote:
">

| &gt; That is also one of the reasons I don't jump to signals as the first
| &gt; solution of a problem, they have almost no defined semantics. About the
| &gt; only stable thing you can say about them is that they exist, and that you
| &gt; can't handle KILL and STOP/CONT. Everything else, from their meaning, to
| &gt; semantics of signalling yourself, to semantics of what happens in multi-
| &gt; threaded scenarios, is pretty much a big cloud of unspecifiedness.
|
| Not SIGSEGV.  A confusing things about Unix/Posix/Linux is that
| there are two completely different things, both modelled as
| &quot;signals&quot;.  There are asynchronous ones (like killing a process)
| and there are synchronous ones like SIGSEGV.  The semantics of
| SIGSEGV is 100% completely clear.
+---------------

And indeed, a number of generational garbage collectors[1] use the
VM system itself to implement a hardware write barrier to enable the
noting/recording of the &quot;remembered sets&quot;, that is, which objects
in older generations point to objects in newer generations, and thus
which older generation pointers must be added to the root set when
collecting newer generations. There are several variants on this
theme[2], and there are arguments about whether this or that workload
would benefit from using a software write barrier [perhaps plus
&quot;card marking&quot;] instead[3], but the &quot;paging hardware write barrier&quot;
approach is certainly reliable [where it can be used at all].

-Rob

[1] CMUCL's (on x86) is one, but there are many others.

[2] In all of them, at the completion of a GC all of the write
enable bits are turned off (or write protection bits are
turned on) on all of the pages in the GC-managed heap
[*except* for the nursery, of course!]. In some versions,
for any store into a write-protected heap page the signal
handler [usually part of the GC] will simply turn write-enable
back on for that page and return from the signal, which will
automatically retry the store, which will now quietly succeed.
At the next GC, any heap pages in generations older that the
one(s) being collection which have their write enable bits on
have thus been stored into since the last GC, and all of the
objects on all such pages are scanned to see if they need to
be added to the remembered set. Overall, this approach can be
quite cheap if there are *lots* of stores but to relatively few
older generation pages.

Another approach is, when a write-protection SIGSEGV occurs, to
precisely locate the object being stored into and record either
the whole object (if it's small) or *only* the slot being written
into (if the object's really large) in the remembered set, then
(a) temporarily turn on write-enable on the page, (b) emulate
[that is, perform] the store in the signal handler, (c) &quot;push
forward&quot; the interrupted PC past the store, (d) turn write-enable
back off on that page, and (e) return from the signal handler
to the new PC just past the store. Overall, this approach may
be cheaper than that previous one if there are relatively few
total stores but to widely-scattered older generation pages.

[3] This is particularly true if (a) the cost of a write-protection
trap and the associated SIGSEGV is *very* high on that platform;
(b) type-propagation can be used to suppress performing the write
barrier when non-pointer data is being stored; (c) pointer stores
are fairly infrequent, and (d) pointer stores tend to be clustered
around regions considerably smaller than a page size [in which
case that region/cluster size is probably a good choice for the
&quot;card&quot; size in a card-marking scheme].

-----
Rob Warnock                     &lt;r ... @rpw3.org&gt;
627 26th Avenue                 &lt;URL: http://rpw3.org/ &gt;
San Mateo, CA 94403             (650)572-2607
</POST>
<POST>
<POSTER> sharpqu...@aol.com </POSTER>
<POSTDATE> 2007-12-07T02:32:00 </POSTDATE>
On Dec 4, 11:02 am, smallpond &lt;smallp ... @juno.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; On Dec 4, 9:16 am, llothar &lt;llot ... @web.de&gt; wrote:

&gt; &gt; On Dec 4, 8:15 pm, &quot;Andreas Thiele&quot; &lt;nos ... @nospam.com&gt; wrote:

&gt; &gt; &gt; Yes, there are some alternatives. Although I use relational DBs, I don't appreciate them
&gt; &gt; &gt; very much. They are not very handy. It's simply marketing for me.

&gt; &gt; No not marketing, you simply have a solid toolchain from different
&gt; &gt; vendors and don't bind
&gt; &gt; yourself to strange solutions. It's important for mission critical.
&gt; &gt; Especially if the application
&gt; &gt; grows and you need a realiable and good scaling data store the easiest
&gt; &gt; and best way are still RDBMS.

&gt; Could you please tell me what units &quot;solid&quot;, &quot;strange&quot;, &quot;easiest&quot;,
&gt; &quot;important&quot;, &quot;good&quot; and &quot;best&quot; are measured in?  Otherwise, they
&gt; are marketing.
">

They are measured in units of ease, of course. It is a lot easier to
smack your data around 'til it fits into tables than it is to touch
the filesystem. It gets harder, each year. to remember how the
filesystem works.
</POST>
<POST>
<POSTER> Daniel Weinreb &lt;d...@alum.mit.edu&gt; </POSTER>
<POSTDATE> 2007-12-07T08:52:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Rob Warnock wrote:
&gt; Daniel Weinreb  &lt;d ... @alum.mit.edu&gt; wrote:
&gt; +---------------
&gt; | Maciej Katafiasz wrote:
&gt; | &gt; That is also one of the reasons I don't jump to signals as the first
&gt; | &gt; solution of a problem, they have almost no defined semantics. About the
&gt; | &gt; only stable thing you can say about them is that they exist, and that you
&gt; | &gt; can't handle KILL and STOP/CONT. Everything else, from their meaning, to
&gt; | &gt; semantics of signalling yourself, to semantics of what happens in multi-
&gt; | &gt; threaded scenarios, is pretty much a big cloud of unspecifiedness.
&gt; |
&gt; | Not SIGSEGV.  A confusing things about Unix/Posix/Linux is that
&gt; | there are two completely different things, both modelled as
&gt; | &quot;signals&quot;.  There are asynchronous ones (like killing a process)
&gt; | and there are synchronous ones like SIGSEGV.  The semantics of
&gt; | SIGSEGV is 100% completely clear.
&gt; +---------------

&gt; And indeed, a number of generational garbage collectors[1] use the
&gt; VM system itself to implement a hardware write barrier to enable the
&gt; noting/recording of the &quot;remembered sets&quot;, that is, which objects
&gt; in older generations point to objects in newer generations, and thus
&gt; which older generation pointers must be added to the root set when
&gt; collecting newer generations. There are several variants on this
&gt; theme[2], and there are arguments about whether this or that workload
&gt; would benefit from using a software write barrier [perhaps plus
&gt; &quot;card marking&quot;] instead[3], but the &quot;paging hardware write barrier&quot;
&gt; approach is certainly reliable [where it can be used at all].

&gt; -Rob

&gt; [1] CMUCL's (on x86) is one, but there are many others.

&gt; [2] In all of them, at the completion of a GC all of the write
&gt;     enable bits are turned off (or write protection bits are
&gt;     turned on) on all of the pages in the GC-managed heap
&gt;     [*except* for the nursery, of course!]. In some versions,
&gt;     for any store into a write-protected heap page the signal
&gt;     handler [usually part of the GC] will simply turn write-enable
&gt;     back on for that page and return from the signal, which will
&gt;     automatically retry the store, which will now quietly succeed.
&gt;     At the next GC, any heap pages in generations older that the
&gt;     one(s) being collection which have their write enable bits on
&gt;     have thus been stored into since the last GC, and all of the
&gt;     objects on all such pages are scanned to see if they need to
&gt;     be added to the remembered set. Overall, this approach can be
&gt;     quite cheap if there are *lots* of stores but to relatively few
&gt;     older generation pages.

&gt;     Another approach is, when a write-protection SIGSEGV occurs, to
&gt;     precisely locate the object being stored into and record either
&gt;     the whole object (if it's small) or *only* the slot being written
&gt;     into (if the object's really large) in the remembered set, then
&gt;     (a) temporarily turn on write-enable on the page, (b) emulate
&gt;     [that is, perform] the store in the signal handler, (c) &quot;push
&gt;     forward&quot; the interrupted PC past the store, (d) turn write-enable
&gt;     back off on that page, and (e) return from the signal handler
&gt;     to the new PC just past the store. Overall, this approach may
&gt;     be cheaper than that previous one if there are relatively few
&gt;     total stores but to widely-scattered older generation pages.

&gt; [3] This is particularly true if (a) the cost of a write-protection
&gt;     trap and the associated SIGSEGV is *very* high on that platform;
&gt;     (b) type-propagation can be used to suppress performing the write
&gt;     barrier when non-pointer data is being stored; (c) pointer stores
&gt;     are fairly infrequent, and (d) pointer stores tend to be clustered
&gt;     around regions considerably smaller than a page size [in which
&gt;     case that region/cluster size is probably a good choice for the
&gt;     &quot;card&quot; size in a card-marking scheme].

&gt; -----
&gt; Rob Warnock                        &lt;r ... @rpw3.org&gt;
&gt; 627 26th Avenue                    &lt;URL: http://rpw3.org/ &gt;
&gt; San Mateo, CA 94403                (650)572-2607
">

That's a great explanation of how to use SIGSEGV as a hardware
write barrier in a GC.

In the case of ObjectStore, we had to do it in &quot;hardware&quot; (SIGSEGV)
rather than software, because of the fundamental claim that
we were making, that once you had touched all the pages
that you were going to use during a transaction, your
program would run at absolutely full C++ speed.  ObjectStore
(for C++) was, at its heart, a largely-transparent way to
have persistent storage for C++ objects.  It was a selling
point that you could use ObjectStore by doing only a small
amount of rewriting of your existing C++ code.  I demonstrated
this for our first semi-public demo of the project, by taking
an existing graphics package from Berkeley (I can't remember
its name any more), and converting it, mainly by changing
all the &quot;new&quot;'s to &quot;new (db)&quot; and putting in transaction
boundaries.  It only took me a few hours and it worked fine;
this was source code that I had never seen before.

Actually I don't think too many of customers back-converted
their own C++ code, but I do think they converted pre-existing
libraries.  If your library didn't do any &quot;new&quot;'s (which some
math libraries, etc, do), you could often just link in the
binaries of the library direction without even recompiling
and it would work just fine on persistent memory.

(I should not talk in the past tense.  It's still maintained
and you can buy it from ObjectStore (Progress Software).)
</POST>
<POST>
<POSTER> jayessay &lt;nos...@foo.com&gt; </POSTER>
<POSTDATE> 2007-12-08T13:01:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:
&gt; Matthew D. Swank wrote:
&gt; &gt; On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt; &gt;&gt; I find myself fascinated by RDF triple stores, and have my eye on
&gt; &gt;&gt; Redland as an open persistent storage solution for Lisp apps. yeah,
&gt; &gt;&gt; to hell with persistent CLOS, gavino talked me out of OO. :)
&gt; &gt; What is your interest in RDF?

&gt; I think triples are a better way to represent data. Triples are to
&gt; objects what objects are to tables and rows, and what dynamic typing
">

I think you have this backwards/upside down.  Triples are basically a
(sparse) representation of adjacency matrices (which are typically and
more directly modeled by tables).  From a representational POV, all
this stuff is equivalent (including objects or structures which can be
modeled as sets of triples, [after all it's pretty easy to see a that
slot basically encodes a single triple]).  Things start to separate
out when you curry in the context of the particular task at hand and
the underlying details of specific implementations of the
representations.

<QUOTE PREVIOUSPOST="
&gt; Triples have the power of natural language without the
&gt; ambiguity.
">

Have you been drinking before writing this??

/Jon

--
'j' - a n t h o n y at romeo/charley/november com
</POST>
<POST>
<POSTER> Ken Tilton &lt;kennytil...@optonline.net&gt; </POSTER>
<POSTDATE> 2007-12-08T15:13:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
jayessay wrote:
&gt; Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:

&gt;&gt;Matthew D. Swank wrote:

&gt;&gt;&gt;On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt;&gt;&gt;&gt;I find myself fascinated by RDF triple stores, and have my eye on
&gt;&gt;&gt;&gt;Redland as an open persistent storage solution for Lisp apps. yeah,
&gt;&gt;&gt;&gt;to hell with persistent CLOS, gavino talked me out of OO. :)

&gt;&gt;&gt;What is your interest in RDF?

&gt;&gt;I think triples are a better way to represent data. Triples are to
&gt;&gt;objects what objects are to tables and rows, and what dynamic typing

&gt; I think you have this backwards/upside down.  Triples are basically a
&gt; (sparse) representation of adjacency matrices (which are typically and
&gt; more directly modeled by tables).  From a representational POV, all
&gt; this stuff is equivalent (including objects or structures which can be
&gt; modeled as sets of triples, [after all it's pretty easy to see a that
&gt; slot basically encodes a single triple]).  Things start to separate
&gt; out when you curry in the context of the particular task at hand and
&gt; the underlying details of specific implementations of the
&gt; representations.
">

If you have to use so many big words, you must be wrong.

<QUOTE PREVIOUSPOST="
&gt;&gt;Triples have the power of natural language without the
&gt;&gt;ambiguity.

&gt; Have you been drinking before writing this??
">

I think our different perspectives arise from me being a serious
application developer and you being a Usenet asshole wannabe.

Please follow up, I want to see if my killfile is working.
</POST>
<POST>
<POSTER> Russell McManus &lt;russell_mcma...@yahoo.com&gt; </POSTER>
<POSTDATE> 2007-12-08T21:44:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:
&gt; jayessay wrote:
&gt; &gt; Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:

&gt; &gt;&gt;Matthew D. Swank wrote:

&gt; &gt;&gt;&gt;On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt; &gt;&gt;&gt;&gt;I find myself fascinated by RDF triple stores, and have my eye on
&gt; &gt;&gt;&gt;&gt;Redland as an open persistent storage solution for Lisp apps. yeah,
&gt; &gt;&gt;&gt;&gt;to hell with persistent CLOS, gavino talked me out of OO. :)

&gt; &gt;&gt;&gt;What is your interest in RDF?

&gt; &gt;&gt;I think triples are a better way to represent data. Triples are to
&gt; &gt;&gt;objects what objects are to tables and rows, and what dynamic typing
&gt; &gt; I think you have this backwards/upside down.  Triples are basically a
&gt; &gt; (sparse) representation of adjacency matrices (which are typically and
&gt; &gt; more directly modeled by tables).  From a representational POV, all
&gt; &gt; this stuff is equivalent (including objects or structures which can be
&gt; &gt; modeled as sets of triples, [after all it's pretty easy to see a that
&gt; &gt; slot basically encodes a single triple]).  Things start to separate
&gt; &gt; out when you curry in the context of the particular task at hand and
&gt; &gt; the underlying details of specific implementations of the
&gt; &gt; representations.

&gt; If you have to use so many big words, you must be wrong.

&gt; &gt;&gt;Triples have the power of natural language without the
&gt; &gt;&gt;ambiguity.
&gt; &gt; Have you been drinking before writing this??

&gt; I think our different perspectives arise from me being a serious
&gt; application developer and you being a Usenet asshole wannabe.

&gt; Please follow up, I want to see if my killfile is working.
">

You fell victim to one of the classic blunders! The most famous is
never get involved in a land war in Asia, but only slightly less
well-known is this: never go in against Ken Tilton when drinking is on
the line! Ha ha ha ha ha ha ha! Ha ha ha ha ha ha ha! Ha ha ha...

-russ
</POST>
<POST>
<POSTER> jayessay &lt;nos...@foo.com&gt; </POSTER>
<POSTDATE> 2007-12-09T13:11:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:
&gt; jayessay wrote:
&gt; &gt; Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:

&gt; &gt;&gt;Matthew D. Swank wrote:

&gt; &gt;&gt;&gt;On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt; &gt;&gt;&gt;&gt;I find myself fascinated by RDF triple stores, and have my eye on
&gt; &gt;&gt;&gt;&gt;Redland as an open persistent storage solution for Lisp apps. yeah,
&gt; &gt;&gt;&gt;&gt;to hell with persistent CLOS, gavino talked me out of OO. :)

&gt; &gt;&gt;&gt;What is your interest in RDF?

&gt; &gt;&gt;I think triples are a better way to represent data. Triples are to
&gt; &gt;&gt;objects what objects are to tables and rows, and what dynamic typing

&gt; &gt; I think you have this backwards/upside down.  Triples are basically a
&gt; &gt; (sparse) representation of adjacency matrices (which are typically and
&gt; &gt; more directly modeled by tables).  From a representational POV, all
&gt; &gt; this stuff is equivalent (including objects or structures which can be
&gt; &gt; modeled as sets of triples, [after all it's pretty easy to see a that
&gt; &gt; slot basically encodes a single triple]).  Things start to separate
&gt; &gt; out when you curry in the context of the particular task at hand and
&gt; &gt; the underlying details of specific implementations of the
&gt; &gt; representations.

&gt; If you have to use so many big words, you must be wrong.
">

Who would have thought that stating the obvious would have touched a
nerve?  Heh.

<QUOTE PREVIOUSPOST="
&gt; &gt;&gt;Triples have the power of natural language without the
&gt; &gt;&gt;ambiguity.
&gt; &gt; Have you been drinking before writing this??

&gt; I think our different perspectives arise from me being a serious
&gt; application developer and you being a Usenet asshole wannabe.
">

And here I was trying to give you a graceful exit.  Seriously claiming
that &quot;triples have the power of natural language&quot; just makes you look
like a fool.  I guess this goes under the heading of &quot;no good deed
goes unpunished&quot;...

Perspectives are good.  I have no idea if you really are a &quot;serious&quot;
application developer.  But you say it enough and I have no reason to
doubt it.  OTOH, you are definitely wrong on your second point: I
don't claim or desire to be a &quot;usenet * wannabe&quot; for any value of *.

If you like triples - use them.  I don't care.

<QUOTE PREVIOUSPOST="
&gt; Please follow up, I want to see if my killfile is working.
">

Whatever...

/Jon

--
'j' - a n t h o n y at romeo/charley/november com
</POST>
<POST>
<POSTER> Ken Tilton &lt;kennytil...@optonline.net&gt; </POSTER>
<POSTDATE> 2007-12-09T18:23:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Russell McManus wrote:
&gt; Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:

&gt;&gt;jayessay wrote:

&gt;&gt;&gt;Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:

&gt;&gt;&gt;&gt;Matthew D. Swank wrote:

&gt;&gt;&gt;&gt;&gt;On Wed, 05 Dec 2007 00:25:47 -0500, Ken Tilton wrote:

&gt;&gt;&gt;&gt;&gt;&gt;I find myself fascinated by RDF triple stores, and have my eye on
&gt;&gt;&gt;&gt;&gt;&gt;Redland as an open persistent storage solution for Lisp apps. yeah,
&gt;&gt;&gt;&gt;&gt;&gt;to hell with persistent CLOS, gavino talked me out of OO. :)

&gt;&gt;&gt;&gt;&gt;What is your interest in RDF?

&gt;&gt;&gt;&gt;I think triples are a better way to represent data. Triples are to
&gt;&gt;&gt;&gt;objects what objects are to tables and rows, and what dynamic typing

&gt;&gt;&gt;I think you have this backwards/upside down.  Triples are basically a
&gt;&gt;&gt;(sparse) representation of adjacency matrices (which are typically and
&gt;&gt;&gt;more directly modeled by tables).  From a representational POV, all
&gt;&gt;&gt;this stuff is equivalent (including objects or structures which can be
&gt;&gt;&gt;modeled as sets of triples, [after all it's pretty easy to see a that
&gt;&gt;&gt;slot basically encodes a single triple]).  Things start to separate
&gt;&gt;&gt;out when you curry in the context of the particular task at hand and
&gt;&gt;&gt;the underlying details of specific implementations of the
&gt;&gt;&gt;representations.

&gt;&gt;If you have to use so many big words, you must be wrong.

&gt;&gt;&gt;&gt;Triples have the power of natural language without the
&gt;&gt;&gt;&gt;ambiguity.

&gt;&gt;&gt;Have you been drinking before writing this??

&gt;&gt;I think our different perspectives arise from me being a serious
&gt;&gt;application developer and you being a Usenet asshole wannabe.

&gt;&gt;Please follow up, I want to see if my killfile is working.

&gt; You fell victim to one of the classic blunders! The most famous is
&gt; never get involved in a land war in Asia, but only slightly less
&gt; well-known is this: never go in against Ken Tilton when drinking is on
&gt; the line! Ha ha ha ha ha ha ha! Ha ha ha ha ha ha ha! Ha ha ha...
">

I should have made it clear to Jon that his job was at stake.

Let's save his yammering about representational Turing equivalence in
the context of an engineering discussion for the C.L.L. Blooper show.

Overall his babbling makes for a nice segue into a larger theme of most
folks not understanding RDF, because most people just read hype. Just as
actual Lisp programmers overruled McCarthy on sexpr/mexpr, actually
programming with triples is needed to get past the (mistaken) hype machine.

Unfortunately the combination of &quot;c.l.l.&quot; and &quot;actual programming&quot;...
inconceivable!

I just wish financial realities did not make it necessary for me to
concentrate on the Algebra software. I think it is time for KennyCL
featuring an OpenGL-based GUI lib, an RDF substitute for CLOS,
persistence via Redland, and... and... I know I am forgetting something.
Now if only the so-called cliki young tigers could stop preening on
#lisp and get SBCL stabilized on win32.

kt

--
http://www.theoryyalgebra.com/

&quot;In the morning, hear the Way;
in the evening, die content!&quot;
-- Confucius
</POST>
<POST>
<POSTER> jayessay &lt;nos...@foo.com&gt; </POSTER>
<POSTDATE> 2007-12-10T12:45:00 </POSTDATE>
<QUOTE PREVIOUSPOST="
Ken Tilton &lt;kennytil ... @optonline.net&gt; writes:
&gt; Let's save his yammering about representational Turing equivalence in
&gt; the context of an engineering discussion for the C.L.L. Blooper show.
">

I note you missed the speicific bits about how the context and task
(and implementations) change the expressiveness and choices.  So, I
was not talking merely &quot;turing equivalence&quot; of representations.  Also,
you still had it backwards/upside down.

<QUOTE PREVIOUSPOST="
&gt; Overall his babbling makes for a nice segue into a larger theme of
&gt; most folks not understanding RDF, because most people just read
&gt; hype.
">

Could be.  But I've been working in this general area (KR) for 15
years and specifically with/on RDF and triple stores and such for
about 4 years or so.  How long have you been dabbling with it?

<QUOTE PREVIOUSPOST="
&gt; Just as actual Lisp programmers overruled McCarthy on sexpr/mexpr,
&gt; actually programming with triples is needed to get past the
&gt; (mistaken) hype machine.
">

Right.  Go for it.  You will learn about the trade offs soon enough.
Maybe your application will be perfect for them.

<QUOTE PREVIOUSPOST="
&gt; Unfortunately the combination of &quot;c.l.l.&quot; and &quot;actual
&gt; programming&quot;... inconceivable!
">

Speaking of yourself?

<QUOTE PREVIOUSPOST="
&gt; concentrate on the Algebra software. I think it is time for KennyCL
&gt; featuring an OpenGL-based GUI lib, an RDF substitute for CLOS,
&gt; persistence via Redland
">

That GUI lib sounds great.  I think I could offer you a better
substrate (not just for CLOS, but in general) and with persistence.
Certainly outperforms the current offerings...

/Jon

--
'j' - a n t h o n y at romeo/charley/november com
</POST>
<POST>
<POSTER> &quot;John K. Hinsdale&quot; &lt;h...@alma.com&gt; </POSTER>
<POSTDATE> 2007-12-11T09:59:00 </POSTDATE>
Hi gavino,

On Dec 4, 7:56 am, gavino &lt;gavcom ... @gmail.com&gt; wrote:

<QUOTE PREVIOUSPOST="
&gt; paul graham said he did not use arelationaldb for viaweb
">

Yes, Graham mentioned there was no database, see:

http://209.85.135.104/search?q=cache:h6H2sLL-EEYJ:www.paulgraham.com/...

However, take note most of his VCs thought they were nuts.  And having
been involved in similar startup situation, they had a point.  Viaweb
created online stores for merchants w/ customers, orders, etc.  Every
business dealing w/ that kind of data puts it into a database so you
can query it later, e.g., to report sales, do incident management, and
a thousand other things.  The VCs can be slimy but are not total
idiots.

So I'd disagree w/ Graham on that point, and I'm sure at some point
there appeared some sort of database at ViaWeb being fed w/ the data
produced by the Lisp-based app.  No business could be run w/out one.

Back in 2002 I had decided I wanted to do some Oracle database work in
some alternative to Java/Perl.  It was Graham's success w/ Lisp at
ViaWeb that led me to use Lisp, specifically CLISP.  Out of that came
CLISP's Oracle module, which really worked well for me since.

In my 15 yrs or so dealing w/ relational databases, I've yet to
encounter a general purpose programming language that was by nature
more or less well-suited to apps dealing w/ manipulation of relational
database based data.  Except possibly that Lisp has some features that
put it slightly above others.  (I can elaborate more on that if there
is interest).

Not all Lisp fans dislike databases, either.  Phil Greenspun has this
to say about Oracle:

http://209.85.135.104/search?q=cache:ZrCM-0MiSCYJ:philip.greenspun.co...

... and on this I agree w/ Phil completely.

<QUOTE PREVIOUSPOST="
&gt; can one do webapps withlispand avoid use of arelationaldb?
">

You should think carefully why you are avoiding a relational database.
Are you sure you don't want one?  They're not hard to learn to use,
and it's not an accident declarative queries in SQL have been around
and used to good effect since the '70s.  Just as Lisp's longevity is
also no accident.

If your data lends itself to representation a relational model, and
you put your data into a decent database early, the time may come when
you need to do analysis and reporting on that data.  This is
particularly true of &quot;business&quot; data like sales, reservations,
customers, etc.  I think it was mentioned that ITA uses Lisp for part
of their reservation system and Oracle RAC as the data house.  None
of that is surprising to me.

Happy hacking,

John Hinsdale
</POST>
</TEXT>
</BODY>
</DOC>
